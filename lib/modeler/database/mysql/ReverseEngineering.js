"use strict";

require("source-map-support/register");

const path = require('path');

const Util = require('rk-utils');

const {
  _,
  fs
} = Util;

const GemlCodeGen = require('../../../lang/GemlCodeGen');

const GemlUtils = require('../../../lang/GemlUtils');

class MySQLReverseEngineering {
  constructor(logger, connector) {
    this.logger = logger;
    this.connector = connector;
    this.reverseRules = this.connector.options.reverseRules || {};
    this.saveDatabaseMeta = this.connector.options.saveDatabaseMeta || false;
  }

  async reverse_(outputDir) {
    this.logger.log('verbose', `Reverse engineering against ${this.connector.driver} database "${this.connector.database}" ...`);
    fs.ensureDirSync(outputDir);
    console.log(outputDir);
    let tables = await this.connector.execute_("select * from information_schema.tables where table_schema = ?", [this.connector.database]);

    if (this.saveDatabaseMeta) {
      fs.writeFileSync(path.join(outputDir, this.connector.database + '.meta.json'), JSON.stringify(tables, null, 2));
    }

    let entities = [],
        mapOfEntities = {};
    let entitiesOolPath = path.join(outputDir, 'entities');
    fs.ensureDirSync(entitiesOolPath);
    await Util.eachAsync_(tables, async table => {
      let entityName = this._entityNaming(table.TABLE_NAME);

      entities.push({
        entity: entityName
      });
      mapOfEntities[entityName] = await this.extractTable_(entityName, table, entitiesOolPath);
    });

    this._refineEntityRelationships(mapOfEntities);

    _.forOwn(mapOfEntities, ({
      types,
      entityInfo
    }, entityName) => {
      let entity = {
        type: types,
        entity: {
          [entityName]: entityInfo
        }
      };
      let entityContent = GemlCodeGen.transform(entity);
      let entityFile = path.join(entitiesOolPath, entityName + '.ool');
      fs.writeFileSync(entityFile + '.json', JSON.stringify(entity, null, 2));
      fs.writeFileSync(entityFile, entityContent);
      this.logger.log('info', `Extracted entity definition file "${entityFile}".`);
    });

    let schemaName = this._schemaNaming(this.connector.database);

    let json = {
      "namespace": ["entities/**"],
      "schema": {
        [schemaName]: {
          "entities": entities
        }
      }
    };
    let schemaContent = GemlCodeGen.transform(json);
    let schemaFile = path.join(outputDir, schemaName + '.ool');
    fs.writeFileSync(schemaFile + '.json', JSON.stringify(json, null, 2));
    fs.writeFileSync(schemaFile, schemaContent);
    this.logger.log('info', `Extracted schema entry file "${schemaFile}".`);
  }

  async extractTable_(entityName, table, extractedOolPath) {
    let columns = await this.connector.execute_("select * from information_schema.columns where table_schema = ? and table_name = ?", [this.connector.database, table.TABLE_NAME]);

    if (this.saveDatabaseMeta) {
      fs.writeFileSync(path.join(extractedOolPath, table.TABLE_NAME + '.meta.json'), JSON.stringify(columns, null, 2));
    }

    let {
      features,
      fields,
      types
    } = this._processFields(table, columns);

    let indexInfo = await this.connector.execute_("SHOW INDEXES FROM ??", [table.TABLE_NAME]);

    if (this.saveDatabaseMeta && !_.isEmpty(indexInfo)) {
      fs.writeFileSync(path.join(extractedOolPath, table.TABLE_NAME + '.index.json'), JSON.stringify(indexInfo, null, 2));
    }

    let {
      pk,
      indexes,
      mapNameToIndex
    } = this._processIndexes(indexInfo);

    let referencesInfo = await this.connector.execute_("SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE `REFERENCED_TABLE_SCHEMA` = ? AND `TABLE_NAME` = ? AND `REFERENCED_TABLE_NAME` IS NOT NULL", [this.connector.database, table.TABLE_NAME]);

    if (this.saveDatabaseMeta && !_.isEmpty(referencesInfo)) {
      fs.writeFileSync(path.join(extractedOolPath, table.TABLE_NAME + '.ref.json'), JSON.stringify(referencesInfo, null, 2));
    }

    let associations = await this._processReferences_(referencesInfo, mapNameToIndex, fields);
    let entityInfo = {
      comment: table.TABLE_COMMENT,
      features,
      fields,
      associations,
      key: pk.length > 1 ? pk : pk[0],
      indexes
    };

    if (entityName !== table.TABLE_NAME) {
      entityInfo.code = table.TABLE_NAME;
    }

    return {
      types,
      entityInfo
    };
  }

  async _processReferences_(referencesInfo, mapNameToIndex, fields) {
    let associations = [];
    let l = referencesInfo.length;

    for (let i = 0; i < l; i++) {
      let ref = referencesInfo[i];
      let [refTableKey] = await this.connector.execute_("SHOW INDEXES FROM ?? WHERE `Key_name` = 'PRIMARY'", [ref.REFERENCED_TABLE_NAME]);

      if (refTableKey.Column_name.toLowerCase() !== ref.REFERENCED_COLUMN_NAME.toLowerCase()) {
        throw new Error(`Foreign key "${ref.COLUMN_NAME}" not reference to the primary key.`);
      }

      let unique = false;
      let fkInfo = mapNameToIndex[ref.CONSTRAINT_NAME];

      if (fkInfo) {
        if (fkInfo.length > 1) {
          throw new Error(`Combination foreign key is not supported: "${ref.CONSTRAINT_NAME}"`);
        }

        unique = fkInfo[0].Non_unique === 0;
      }

      let fkColName = this._fieldNaming(ref.COLUMN_NAME);

      if (unique) {
        associations.push({
          type: 'belongsTo',
          srcField: fkColName,
          destEntity: this._entityNaming(ref.REFERENCED_TABLE_NAME)
        });
      } else {
        associations.push({
          type: 'hasMany',
          srcField: fkColName,
          destEntity: this._entityNaming(ref.REFERENCED_TABLE_NAME)
        });
      }

      delete fields[fkColName];
    }

    return associations;
  }

  _processIndexes(indexInfo) {
    let pk = [],
        indexes = [];
    let mapNameToIndex = {};
    indexInfo.forEach(i => {
      Util.putIntoBucket(mapNameToIndex, i.Key_name, i);
    });

    _.forOwn(mapNameToIndex, (fields, name) => {
      if (name === 'PRIMARY') {
        pk.push(fields.map(f => this._fieldNaming(f.Column_name)));
      } else {
        indexes.push({
          name: name,
          fields: fields.map(f => this._fieldNaming(f.Column_name)),
          unique: fields[0].Non_unique === 0,
          nullable: fields[0].Null === 'YES'
        });
      }
    });

    return {
      pk,
      indexes,
      mapNameToIndex
    };
  }

  _processFields(table, columns) {
    let features = [],
        fields = {},
        types = {};
    columns.forEach(col => {
      let fieldName = this._fieldNaming(col.COLUMN_NAME);

      if (col.EXTRA === 'auto_increment') {
        let featureInfo = {
          "name": "autoId",
          "options": table.AUTO_INCREMENT ? {
            "startFrom": table.AUTO_INCREMENT
          } : {}
        };

        if (fieldName !== 'id') {
          featureInfo.options.name = fieldName;
        }

        features.push(featureInfo);
        return;
      }

      if (col.COLUMN_DEFAULT === 'CURRENT_TIMESTAMP') {
        let featureInfo = {
          "name": "createTimestamp"
        };
        features.push(featureInfo);
        return;
      }

      if (col.EXTRA === 'on update CURRENT_TIMESTAMP') {
        let featureInfo = {
          "name": "updateTimestamp"
        };
        features.push(featureInfo);
        return;
      }

      if (fieldName === 'isDeleted' && col.COLUMN_TYPE === 'tinyint(1)') {
        let featureInfo = {
          "name": "logicalDeletion"
        };
        features.push(featureInfo);
        return;
      }

      let fieldInfo = this._mysqlTypeToOolType(table, col, fieldName, types);

      if (col.IS_NULLABLE === 'YES') {
        fieldInfo.optional = true;
      }

      if (col.COLUMN_DEFAULT) {
        fieldInfo.default = col.COLUMN_DEFAULT;
      }

      if (col.COLUMN_COMMENT) {
        fieldInfo.comment = col.COLUMN_COMMENT;
      }

      fields[fieldName] = fieldInfo;
    });
    return {
      features,
      fields,
      types
    };
  }

  _fieldNaming(name) {
    if (this.reverseRules.fieldNaming) {
      return this.reverseRules.fieldNamin(name);
    }

    return GemlUtils.fieldNaming(name);
  }

  _entityNaming(name) {
    if (this.reverseRules.entityNaming) {
      return this.reverseRules.entityNaming(name);
    }

    return GemlUtils.entityNaming(name);
  }

  _schemaNaming(name) {
    if (this.reverseRules.schemaNaming) {
      return this.reverseRules.schemaNaming(name);
    }

    return GemlUtils.schemaNaming(name);
  }

  _mysqlTypeToOolType(table, col, fieldName, types) {
    let applicableRule = _.find(this.reverseRules.columnTypeConversion, rule => rule.test(table, col));

    if (applicableRule) {
      return applicableRule.apply(table, col);
    }

    let typeInfo = {};

    if (col.COLUMN_NAME !== fieldName) {
      typeInfo.code = col.COLUMN_NAME;
    }

    switch (col.DATA_TYPE) {
      case 'varchar':
        typeInfo.type = 'text';

        if (col.CHARACTER_MAXIMUM_LENGTH) {
          typeInfo.maxLength = col.CHARACTER_MAXIMUM_LENGTH;
        }

        break;

      case 'char':
        typeInfo.type = 'text';

        if (col.CHARACTER_MAXIMUM_LENGTH) {
          typeInfo.fixedLength = col.CHARACTER_MAXIMUM_LENGTH;
        }

        break;

      case 'bigint':
        typeInfo.type = 'integer';
        typeInfo.digits = col.NUMERIC_PRECISION || 18;
        typeInfo.bytes = 8;
        if (_.endsWith(col.COLUMN_TYPE, ' unsigned')) typeInfo.unsigned = true;
        break;

      case 'int':
        typeInfo.type = 'integer';
        typeInfo.digits = col.NUMERIC_PRECISION || 10;
        typeInfo.bytes = 4;
        if (_.endsWith(col.COLUMN_TYPE, ' unsigned')) typeInfo.unsigned = true;
        break;

      case 'mediumint':
        typeInfo.type = 'integer';
        typeInfo.digits = col.NUMERIC_PRECISION || 7;
        typeInfo.bytes = 3;
        if (_.endsWith(col.COLUMN_TYPE, ' unsigned')) typeInfo.unsigned = true;
        break;

      case 'smallint':
        typeInfo.type = 'integer';
        typeInfo.digits = col.NUMERIC_PRECISION || 4;
        typeInfo.bytes = 2;
        if (_.endsWith(col.COLUMN_TYPE, ' unsigned')) typeInfo.unsigned = true;
        break;

      case 'tinyint':
        if (_.startsWith(col.COLUMN_TYPE, 'tinyint(1)')) {
          typeInfo.type = 'boolean';
        } else {
          typeInfo.type = 'integer';
          typeInfo.digits = col.NUMERIC_PRECISION || 2;
          typeInfo.bytes = 1;
          if (_.endsWith(col.COLUMN_TYPE, ' unsigned')) typeInfo.unsigned = true;
        }

        break;

      case 'enum':
        let left = col.COLUMN_TYPE.indexOf('(');
        let right = col.COLUMN_TYPE.lastIndexOf(')');

        let typeName = table.TABLE_NAME + _.upperFirst(col.COLUMN_NAME);

        types[typeName] = {
          type: 'enum',
          values: col.COLUMN_TYPE.substring(left + 1, right).split(',').map(v => v.substr(1, v.length - 2))
        };
        typeInfo.type = typeName;
        break;

      case 'text':
        typeInfo.type = 'text';
        typeInfo.maxLength = col.CHARACTER_MAXIMUM_LENGTH;
        break;

      case 'datetime':
      case 'timestamp':
        typeInfo.type = 'datetime';
        break;

      case 'decimal':
        typeInfo.type = 'number';
        typeInfo.totalDigits = col.NUMERIC_PRECISION;
        typeInfo.decimalDigits = col.NUMERIC_SCALE;
        typeInfo.exact = true;
        break;

      case 'float':
        typeInfo.type = 'number';
        typeInfo.totalDigits = col.NUMERIC_PRECISION;
        typeInfo.decimalDigits = col.NUMERIC_SCALE;
        break;

      default:
        console.log(col);
        throw new Error('To be implemented.');
    }

    return typeInfo;
  }

  _refineEntityRelationships(mapOfEntities) {
    let entityAssoc = {};

    _.forOwn(mapOfEntities, ({
      entityInfo
    }, name) => {
      if (_.isEmpty(entityInfo.associations)) return;
      entityInfo.associations.forEach(({
        type,
        srcField,
        destEntity
      }) => {
        let refedEntity = mapOfEntities[destEntity];

        let backRef = _.find(refedEntity.associations, assoc => assoc.destEntity === name);

        if (type === 'hasMany') {
          if (!backRef) {
            Util.putIntoBucket(entityAssoc, name, {
              type: 'refersTo',
              srcField,
              destEntity
            });
            return;
          }

          console.log(entityInfo);
          throw new Error(`Back reference: ${backRef.entity} ${backRef.type} ${name}`);
        } else if (type === 'belongsTo') {
          Util.putIntoBucket(entityAssoc, name, {
            type,
            srcField,
            destEntity
          });

          if (!backRef) {
            Util.putIntoBucket(entityAssoc, entity, {
              type: 'hasMany',
              destEntity: name
            });
            return;
          }
        } else {
          throw new Error('Unexpected association type: ' + type);
        }
      });
    });

    _.forOwn(entityAssoc, (associations, name) => {
      let {
        entityInfo
      } = mapOfEntities[name];
      let keyAssocs;

      if (Array.isArray(entityInfo.key) && entityInfo.key.length === 2) {
        keyAssocs = _.filter(associations, assoc => entityInfo.key.indexOf(assoc.srcField) !== -1);

        if (keyAssocs.length === 2) {
          this._makeEntityManyToMany(keyAssocs[0].destEntity, keyAssocs[1].destEntity, entityAssoc);
        }
      }

      entityInfo.indexes.forEach(({
        fields
      }) => {
        if (fields.length === 2) {
          keyAssocs = _.filter(associations, assoc => fields.indexOf(assoc.srcField) !== -1);

          if (keyAssocs.length === 2) {
            this._makeEntityManyToMany(keyAssocs[0].destEntity, keyAssocs[1].destEntity, entityAssoc);
          }
        }
      });
    });

    _.forOwn(mapOfEntities, ({
      entityInfo
    }, name) => {
      entityInfo.associations = entityAssoc[name];
    });
  }

  _makeEntityManyToMany(entityName1, entityName2, entityAssoc) {
    Util.putIntoBucket(entityAssoc, entityName1, {
      type: 'hasMany',
      destEntity: entityName2
    });
    Util.putIntoBucket(entityAssoc, entityName2, {
      type: 'hasMany',
      destEntity: entityName1
    });
  }

}

module.exports = MySQLReverseEngineering;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2RlbGVyL2RhdGFiYXNlL215c3FsL1JldmVyc2VFbmdpbmVlcmluZy5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIlV0aWwiLCJfIiwiZnMiLCJHZW1sQ29kZUdlbiIsIkdlbWxVdGlscyIsIk15U1FMUmV2ZXJzZUVuZ2luZWVyaW5nIiwiY29uc3RydWN0b3IiLCJsb2dnZXIiLCJjb25uZWN0b3IiLCJyZXZlcnNlUnVsZXMiLCJvcHRpb25zIiwic2F2ZURhdGFiYXNlTWV0YSIsInJldmVyc2VfIiwib3V0cHV0RGlyIiwibG9nIiwiZHJpdmVyIiwiZGF0YWJhc2UiLCJlbnN1cmVEaXJTeW5jIiwiY29uc29sZSIsInRhYmxlcyIsImV4ZWN1dGVfIiwid3JpdGVGaWxlU3luYyIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5IiwiZW50aXRpZXMiLCJtYXBPZkVudGl0aWVzIiwiZW50aXRpZXNPb2xQYXRoIiwiZWFjaEFzeW5jXyIsInRhYmxlIiwiZW50aXR5TmFtZSIsIl9lbnRpdHlOYW1pbmciLCJUQUJMRV9OQU1FIiwicHVzaCIsImVudGl0eSIsImV4dHJhY3RUYWJsZV8iLCJfcmVmaW5lRW50aXR5UmVsYXRpb25zaGlwcyIsImZvck93biIsInR5cGVzIiwiZW50aXR5SW5mbyIsInR5cGUiLCJlbnRpdHlDb250ZW50IiwidHJhbnNmb3JtIiwiZW50aXR5RmlsZSIsInNjaGVtYU5hbWUiLCJfc2NoZW1hTmFtaW5nIiwianNvbiIsInNjaGVtYUNvbnRlbnQiLCJzY2hlbWFGaWxlIiwiZXh0cmFjdGVkT29sUGF0aCIsImNvbHVtbnMiLCJmZWF0dXJlcyIsImZpZWxkcyIsIl9wcm9jZXNzRmllbGRzIiwiaW5kZXhJbmZvIiwiaXNFbXB0eSIsInBrIiwiaW5kZXhlcyIsIm1hcE5hbWVUb0luZGV4IiwiX3Byb2Nlc3NJbmRleGVzIiwicmVmZXJlbmNlc0luZm8iLCJhc3NvY2lhdGlvbnMiLCJfcHJvY2Vzc1JlZmVyZW5jZXNfIiwiY29tbWVudCIsIlRBQkxFX0NPTU1FTlQiLCJrZXkiLCJsZW5ndGgiLCJjb2RlIiwibCIsImkiLCJyZWYiLCJyZWZUYWJsZUtleSIsIlJFRkVSRU5DRURfVEFCTEVfTkFNRSIsIkNvbHVtbl9uYW1lIiwidG9Mb3dlckNhc2UiLCJSRUZFUkVOQ0VEX0NPTFVNTl9OQU1FIiwiRXJyb3IiLCJDT0xVTU5fTkFNRSIsInVuaXF1ZSIsImZrSW5mbyIsIkNPTlNUUkFJTlRfTkFNRSIsIk5vbl91bmlxdWUiLCJma0NvbE5hbWUiLCJfZmllbGROYW1pbmciLCJzcmNGaWVsZCIsImRlc3RFbnRpdHkiLCJmb3JFYWNoIiwicHV0SW50b0J1Y2tldCIsIktleV9uYW1lIiwibmFtZSIsIm1hcCIsImYiLCJudWxsYWJsZSIsIk51bGwiLCJjb2wiLCJmaWVsZE5hbWUiLCJFWFRSQSIsImZlYXR1cmVJbmZvIiwiQVVUT19JTkNSRU1FTlQiLCJDT0xVTU5fREVGQVVMVCIsIkNPTFVNTl9UWVBFIiwiZmllbGRJbmZvIiwiX215c3FsVHlwZVRvT29sVHlwZSIsIklTX05VTExBQkxFIiwib3B0aW9uYWwiLCJkZWZhdWx0IiwiQ09MVU1OX0NPTU1FTlQiLCJmaWVsZE5hbWluZyIsImZpZWxkTmFtaW4iLCJlbnRpdHlOYW1pbmciLCJzY2hlbWFOYW1pbmciLCJhcHBsaWNhYmxlUnVsZSIsImZpbmQiLCJjb2x1bW5UeXBlQ29udmVyc2lvbiIsInJ1bGUiLCJ0ZXN0IiwiYXBwbHkiLCJ0eXBlSW5mbyIsIkRBVEFfVFlQRSIsIkNIQVJBQ1RFUl9NQVhJTVVNX0xFTkdUSCIsIm1heExlbmd0aCIsImZpeGVkTGVuZ3RoIiwiZGlnaXRzIiwiTlVNRVJJQ19QUkVDSVNJT04iLCJieXRlcyIsImVuZHNXaXRoIiwidW5zaWduZWQiLCJzdGFydHNXaXRoIiwibGVmdCIsImluZGV4T2YiLCJyaWdodCIsImxhc3RJbmRleE9mIiwidHlwZU5hbWUiLCJ1cHBlckZpcnN0IiwidmFsdWVzIiwic3Vic3RyaW5nIiwic3BsaXQiLCJ2Iiwic3Vic3RyIiwidG90YWxEaWdpdHMiLCJkZWNpbWFsRGlnaXRzIiwiTlVNRVJJQ19TQ0FMRSIsImV4YWN0IiwiZW50aXR5QXNzb2MiLCJyZWZlZEVudGl0eSIsImJhY2tSZWYiLCJhc3NvYyIsImtleUFzc29jcyIsIkFycmF5IiwiaXNBcnJheSIsImZpbHRlciIsIl9tYWtlRW50aXR5TWFueVRvTWFueSIsImVudGl0eU5hbWUxIiwiZW50aXR5TmFtZTIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsSUFBSSxHQUFHQyxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxNQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQyxVQUFELENBQXBCOztBQUNBLE1BQU07QUFBRUUsRUFBQUEsQ0FBRjtBQUFLQyxFQUFBQTtBQUFMLElBQVlGLElBQWxCOztBQUNBLE1BQU1HLFdBQVcsR0FBR0osT0FBTyxDQUFDLDJCQUFELENBQTNCOztBQUNBLE1BQU1LLFNBQVMsR0FBR0wsT0FBTyxDQUFDLHlCQUFELENBQXpCOztBQUVBLE1BQU1NLHVCQUFOLENBQThCO0FBQzFCQyxFQUFBQSxXQUFXLENBQUNDLE1BQUQsRUFBU0MsU0FBVCxFQUFvQjtBQUMzQixTQUFLRCxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUVBLFNBQUtDLFlBQUwsR0FBb0IsS0FBS0QsU0FBTCxDQUFlRSxPQUFmLENBQXVCRCxZQUF2QixJQUF1QyxFQUEzRDtBQUNBLFNBQUtFLGdCQUFMLEdBQXdCLEtBQUtILFNBQUwsQ0FBZUUsT0FBZixDQUF1QkMsZ0JBQXZCLElBQTJDLEtBQW5FO0FBQ0g7O0FBRUQsUUFBTUMsUUFBTixDQUFlQyxTQUFmLEVBQTBCO0FBQ3RCLFNBQUtOLE1BQUwsQ0FBWU8sR0FBWixDQUFnQixTQUFoQixFQUE0QiwrQkFBOEIsS0FBS04sU0FBTCxDQUFlTyxNQUFPLGNBQWEsS0FBS1AsU0FBTCxDQUFlUSxRQUFTLE9BQXJIO0FBRUFkLElBQUFBLEVBQUUsQ0FBQ2Us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QUEyQlYsV0FBM0IsRUFBd0M7QUFDekQvSSxJQUFBQSxJQUFJLENBQUN1RixhQUFMLENBQW1Cd0QsV0FBbkIsRUFBZ0NTLFdBQWhDLEVBQTZDO0FBQUVoSCxNQUFBQSxJQUFJLEVBQUUsU0FBUjtBQUFtQjZDLE1BQUFBLFVBQVUsRUFBRW9FO0FBQS9CLEtBQTdDO0FBQ0F6SixJQUFBQSxJQUFJLENBQUN1RixhQUFMLENBQW1Cd0QsV0FBbkIsRUFBZ0NVLFdBQWhDLEVBQTZDO0FBQUVqSCxNQUFBQSxJQUFJLEVBQUUsU0FBUjtBQUFtQjZDLE1BQUFBLFVBQVUsRUFBRW1FO0FBQS9CLEtBQTdDO0FBQ0g7O0FBbGN5Qjs7QUFxYzlCRSxNQUFNLENBQUNDLE9BQVAsR0FBaUJ0Six1QkFBakIiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJ3JrLXV0aWxzJyk7XG5jb25zdCB7IF8sIGZzIH0gPSBVdGlsO1xuY29uc3QgR2VtbENvZGVHZW4gPSByZXF1aXJlKCcuLi8uLi8uLi9sYW5nL0dlbWxDb2RlR2VuJyk7XG5jb25zdCBHZW1sVXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9sYW5nL0dlbWxVdGlscycpO1xuXG5jbGFzcyBNeVNRTFJldmVyc2VFbmdpbmVlcmluZyB7XG4gICAgY29uc3RydWN0b3IobG9nZ2VyLCBjb25uZWN0b3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yOyAgICAgICAgXG5cbiAgICAgICAgdGhpcy5yZXZlcnNlUnVsZXMgPSB0aGlzLmNvbm5lY3Rvci5vcHRpb25zLnJldmVyc2VSdWxlcyB8fCB7fTsgICAgICAgXG4gICAgICAgIHRoaXMuc2F2ZURhdGFiYXNlTWV0YSA9IHRoaXMuY29ubmVjdG9yLm9wdGlvbnMuc2F2ZURhdGFiYXNlTWV0YSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICBhc3luYyByZXZlcnNlXyhvdXRwdXREaXIpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKCd2ZXJib3NlJywgYFJldmVyc2UgZW5naW5lZXJpbmcgYWdhaW5zdCAke3RoaXMuY29ubmVjdG9yLmRyaXZlcn0gZGF0YWJhc2UgXCIke3RoaXMuY29ubmVjdG9yLmRhdGFiYXNlfVwiIC4uLmApO1xuXG4gICAgICAgIGZzLmVuc3VyZURpclN5bmMob3V0cHV0RGlyKTtcbiAgICAgICAgY29uc29sZS5sb2cob3V0cHV0RGlyKTtcblxuICAgICAgICBsZXQgdGFibGVzID0gYXdhaXQgdGhpcy5jb25uZWN0b3IuZXhlY3V0ZV8oXCJzZWxlY3QgKiBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgd2hlcmUgdGFibGVfc2NoZW1hID0gP1wiLCBbIHRoaXMuY29ubmVjdG9yLmRhdGFiYXNlIF0pOyAgICAgICAgXG5cbiAgICAgICAgaWYgKHRoaXMuc2F2ZURhdGFiYXNlTWV0YSkge1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ob3V0cHV0RGlyLCB0aGlzLmNvbm5lY3Rvci5kYXRhYmFzZSArICcubWV0YS5qc29uJyksIEpTT04uc3RyaW5naWZ5KHRhYmxlcywgbnVsbCwgMikpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVudGl0aWVzID0gW10sIG1hcE9mRW50aXRpZXMgPSB7fTtcbiAgICAgICAgXG4gICAgICAgIGxldCBlbnRpdGllc09vbFBhdGggPSBwYXRoLmpvaW4ob3V0cHV0RGlyLCAnZW50aXRpZXMnKTtcbiAgICAgICAgZnMuZW5zdXJlRGlyU3luYyhlbnRpdGllc09vbFBhdGgpO1xuXG4gICAgICAgIGF3YWl0IFV0aWwuZWFjaEFzeW5jXyh0YWJsZXMsIGFzeW5jIHRhYmxlID0+IHtcbiAgICAgICAgICAgIGxldCBlbnRpdHlOYW1lID0gdGhpcy5fZW50aXR5TmFtaW5nKHRhYmxlLlRBQkxFX05BTUUpO1xuXG4gICAgICAgICAgICBlbnRpdGllcy5wdXNoKHsgZW50aXR5OiBlbnRpdHlOYW1lIH0pOyAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBtYXBPZkVudGl0aWVzW2VudGl0eU5hbWVdID0gYXdhaXQgdGhpcy5leHRyYWN0VGFibGVfKGVudGl0eU5hbWUsIHRhYmxlLCBlbnRpdGllc09vbFBhdGgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9yZWZpbmVFbnRpdHlSZWxhdGlvbnNoaXBzKG1hcE9mRW50aXRpZXMpO1xuXG4gICAgICAgIF8uZm9yT3duKG1hcE9mRW50aXRpZXMsICh7IHR5cGVzLCBlbnRpdHlJbmZvIH0sIGVudGl0eU5hbWUpID0+IHtcbiAgICAgICAgICAgIGxldCBlbnRpdHkgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZXMsXG4gICAgICAgICAgICAgICAgZW50aXR5OiB7XG4gICAgICAgICAgICAgICAgICAgIFtlbnRpdHlOYW1lXTogZW50aXR5SW5mb1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBsZXQgZW50aXR5Q29udGVudCA9IEdlbWxDb2RlR2VuLnRyYW5zZm9ybShlbnRpdHkpO1xuICAgICAgICAgICAgbGV0IGVudGl0eUZpbGUgPSBwYXRoLmpvaW4oZW50aXRpZXNPb2xQYXRoLCBlbnRpdHlOYW1lICsgJy5vb2wnKTtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZW50aXR5RmlsZSArICcuanNvbicsIEpTT04uc3RyaW5naWZ5KGVudGl0eSwgbnVsbCwgMikpO1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhlbnRpdHlGaWxlLCBlbnRpdHlDb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZygnaW5mbycsIGBFeHRyYWN0ZWQgZW50aXR5IGRlZmluaXRpb24gZmlsZSBcIiR7ZW50aXR5RmlsZX1cIi5gKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHNjaGVtYU5hbWUgPSB0aGlzLl9zY2hlbWFOYW1pbmcodGhpcy5jb25uZWN0b3IuZGF0YWJhc2UpO1xuXG4gICAgICAgIGxldCBqc29uID0ge1xuICAgICAgICAgICAgXCJuYW1lc3BhY2VcIjogW1xuICAgICAgICAgICAgICAgIFwiZW50aXRpZXMvKipcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwic2NoZW1hXCI6IHtcbiAgICAgICAgICAgICAgICBbc2NoZW1hTmFtZV06IHtcbiAgICAgICAgICAgICAgICAgICAgXCJlbnRpdGllc1wiOiBlbnRpdGllcyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgc2NoZW1hQ29udGVudCA9IEdlbWxDb2RlR2VuLnRyYW5zZm9ybShqc29uKTtcbiAgICAgICAgbGV0IHNjaGVtYUZpbGUgPSBwYXRoLmpvaW4ob3V0cHV0RGlyLCBzY2hlbWFOYW1lICsgJy5vb2wnKTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhzY2hlbWFGaWxlICsgJy5qc29uJywgSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMikpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHNjaGVtYUZpbGUsIHNjaGVtYUNvbnRlbnQpO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ2luZm8nLCBgRXh0cmFjdGVkIHNjaGVtYSBlbnRyeSBmaWxlIFwiJHtzY2hlbWFGaWxlfVwiLmApO1xuICAgIH1cblxuICAgIGFzeW5jIGV4dHJhY3RUYWJsZV8oZW50aXR5TmFtZSwgdGFibGUsIGV4dHJhY3RlZE9vbFBhdGgpIHtcbiAgICAgICAgbGV0IGNvbHVtbnMgPSBhd2FpdCB0aGlzLmNvbm5lY3Rvci5leGVjdXRlXyhcInNlbGVjdCAqIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLmNvbHVtbnMgd2hlcmUgdGFibGVfc2NoZW1hID0gPyBhbmQgdGFibGVfbmFtZSA9ID9cIixcbiAgICAgICAgICAgIFt0aGlzLmNvbm5lY3Rvci5kYXRhYmFzZSwgdGFibGUuVEFCTEVfTkFNRV0pO1xuXG4gICAgICAgIGlmICh0aGlzLnNhdmVEYXRhYmFzZU1ldGEpIHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKGV4dHJhY3RlZE9vbFBhdGgsIHRhYmxlLlRBQkxFX05BTUUgKyAnLm1ldGEuanNvbicpLCBKU09OLnN0cmluZ2lmeShjb2x1bW5zLCBudWxsLCAyKSk7XG4gICAgICAgIH0gICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgIGxldCB7IGZlYXR1cmVzLCBmaWVsZHMsIHR5cGVzIH0gPSB0aGlzLl9wcm9jZXNzRmllbGRzKHRhYmxlLCBjb2x1bW5zKTtcblxuICAgICAgICBsZXQgaW5kZXhJbmZvID0gYXdhaXQgdGhpcy5jb25uZWN0b3IuZXhlY3V0ZV8oXCJTSE9XIElOREVYRVMgRlJPTSA/P1wiLCBbIHRhYmxlLlRBQkxFX05BTUUgXSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2F2ZURhdGFiYXNlTWV0YSAmJiAhXy5pc0VtcHR5KGluZGV4SW5mbykpIHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKGV4dHJhY3RlZE9vbFBhdGgsIHRhYmxlLlRBQkxFX05BTUUgKyAnLmluZGV4Lmpzb24nKSwgSlNPTi5zdHJpbmdpZnkoaW5kZXhJbmZvLCBudWxsLCAyKSk7XG4gICAgICAgIH0gICAgICAgXG5cbiAgICAgICAgbGV0IHsgcGssIGluZGV4ZXMsIG1hcE5hbWVUb0luZGV4IH0gPSB0aGlzLl9wcm9jZXNzSW5kZXhlcyhpbmRleEluZm8pO1xuXG4gICAgICAgIGFzc2VydDogcGsubGVuZ3RoID4gMDsgICAgICAgIFxuXG4gICAgICAgIGxldCByZWZlcmVuY2VzSW5mbyA9IGF3YWl0IHRoaXMuY29ubmVjdG9yLmV4ZWN1dGVfKFwiU0VMRUNUICogRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRSBXSEVSRSBgUkVGRVJFTkNFRF9UQUJMRV9TQ0hFTUFgID0gPyBBTkQgYFRBQkxFX05BTUVgID0gPyBBTkQgYFJFRkVSRU5DRURfVEFCTEVfTkFNRWAgSVMgTk9UIE5VTExcIixcbiAgICAgICAgICAgIFsgdGhpcy5jb25uZWN0b3IuZGF0YWJhc2UsIHRhYmxlLlRBQkxFX05BTUUgXSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2F2ZURhdGFiYXNlTWV0YSAmJiAhXy5pc0VtcHR5KHJlZmVyZW5jZXNJbmZvKSkge1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oZXh0cmFjdGVkT29sUGF0aCwgdGFibGUuVEFCTEVfTkFNRSArICcucmVmLmpzb24nKSwgSlNPTi5zdHJpbmdpZnkocmVmZXJlbmNlc0luZm8sIG51bGwsIDIpKTtcbiAgICAgICAgfSAgICAgICBcblxuICAgICAgICBsZXQgYXNzb2NpYXRpb25zID0gYXdhaXQgdGhpcy5fcHJvY2Vzc1JlZmVyZW5jZXNfKHJlZmVyZW5jZXNJbmZvLCBtYXBOYW1lVG9JbmRleCwgZmllbGRzKTtcblxuICAgICAgICBsZXQgZW50aXR5SW5mbyA9IHsgICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbW1lbnQ6IHRhYmxlLlRBQkxFX0NPTU1FTlQsXG4gICAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgIGFzc29jaWF0aW9ucyxcbiAgICAgICAgICAgIGtleSA6IHBrLmxlbmd0aCA+IDEgPyBwayA6IHBrWzBdLFxuICAgICAgICAgICAgaW5kZXhlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChlbnRpdHlOYW1lICE9PSB0YWJsZS5UQUJMRV9OQU1FKSB7XG4gICAgICAgICAgICBlbnRpdHlJbmZvLmNvZGUgPSB0YWJsZS5UQUJMRV9OQU1FO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdHlwZXMsIGVudGl0eUluZm8gfTtcbiAgICB9XG5cbiAgICBhc3luYyBfcHJvY2Vzc1JlZmVyZW5jZXNfKHJlZmVyZW5jZXNJbmZvLCBtYXBOYW1lVG9JbmRleCwgZmllbGRzKSB7XG4gICAgICAgIGxldCBhc3NvY2lhdGlvbnMgPSBbXTtcblxuICAgICAgICBsZXQgbCA9IHJlZmVyZW5jZXNJbmZvLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlZiA9IHJlZmVyZW5jZXNJbmZvW2ldO1xuXG4gICAgICAgICAgICBsZXQgW3JlZlRhYmxlS2V5XSA9IGF3YWl0IHRoaXMuY29ubmVjdG9yLmV4ZWN1dGVfKFwiU0hPVyBJTkRFWEVTIEZST00gPz8gV0hFUkUgYEtleV9uYW1lYCA9ICdQUklNQVJZJ1wiLCBbcmVmLlJFRkVSRU5DRURfVEFCTEVfTkFNRV0pO1xuXG4gICAgICAgICAgICBpZiAocmVmVGFibGVLZXkuQ29sdW1uX25hbWUudG9Mb3dlckNhc2UoKSAhPT0gcmVmLlJFRkVSRU5DRURfQ09MVU1OX05BTUUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9yZWlnbiBrZXkgXCIke3JlZi5DT0xVTU5fTkFNRX1cIiBub3QgcmVmZXJlbmNlIHRvIHRoZSBwcmltYXJ5IGtleS5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHVuaXF1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBsZXQgZmtJbmZvID0gbWFwTmFtZVRvSW5kZXhbcmVmLkNPTlNUUkFJTlRfTkFNRV07IFxuICAgICAgICAgICAgaWYgKGZrSW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChma0luZm8ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbWJpbmF0aW9uIGZvcmVpZ24ga2V5IGlzIG5vdCBzdXBwb3J0ZWQ6IFwiJHtyZWYuQ09OU1RSQUlOVF9OQU1FfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdW5pcXVlID0gZmtJbmZvWzBdLk5vbl91bmlxdWUgPT09IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBma0NvbE5hbWUgPSB0aGlzLl9maWVsZE5hbWluZyhyZWYuQ09MVU1OX05BTUUpO1xuXG4gICAgICAgICAgICBpZiAodW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgYXNzb2NpYXRpb25zLnB1c2goeyB0eXBlOiAnYmVsb25nc1RvJywgc3JjRmllbGQ6IGZrQ29sTmFtZSwgZGVzdEVudGl0eTogdGhpcy5fZW50aXR5TmFtaW5nKHJlZi5SRUZFUkVOQ0VEX1RBQkxFX05BTUUpIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbnMucHVzaCh7IHR5cGU6ICdoYXNNYW55Jywgc3JjRmllbGQ6IGZrQ29sTmFtZSwgIGRlc3RFbnRpdHk6IHRoaXMuX2VudGl0eU5hbWluZyhyZWYuUkVGRVJFTkNFRF9UQUJMRV9OQU1FKSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGZpZWxkc1tma0NvbE5hbWVdOy8vID0geyB0eXBlOiAnJGFzc29jaWF0aW9uJywgY29kZTogZmllbGRzW2ZrQ29sTmFtZV0uY29kZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzc29jaWF0aW9ucztcbiAgICB9XG5cbiAgICBfcHJvY2Vzc0luZGV4ZXMoaW5kZXhJbmZvKSB7XG4gICAgICAgIGxldCBwayA9IFtdLCBpbmRleGVzID0gW107XG5cbiAgICAgICAgbGV0IG1hcE5hbWVUb0luZGV4ID0ge307XG5cbiAgICAgICAgaW5kZXhJbmZvLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBVdGlsLnB1dEludG9CdWNrZXQobWFwTmFtZVRvSW5kZXgsIGkuS2V5X25hbWUsIGkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfLmZvck93bihtYXBOYW1lVG9JbmRleCwgKGZpZWxkcywgbmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdQUklNQVJZJykge1xuICAgICAgICAgICAgICAgIHBrLnB1c2goZmllbGRzLm1hcChmID0+IHRoaXMuX2ZpZWxkTmFtaW5nKGYuQ29sdW1uX25hbWUpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkczogZmllbGRzLm1hcChmID0+IHRoaXMuX2ZpZWxkTmFtaW5nKGYuQ29sdW1uX25hbWUpKSxcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiBmaWVsZHNbMF0uTm9uX3VuaXF1ZSA9PT0gMCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbGFibGU6IGZpZWxkc1swXS5OdWxsID09PSAnWUVTJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBwaywgaW5kZXhlcywgbWFwTmFtZVRvSW5kZXggfTtcbiAgICB9XG5cbiAgICBfcHJvY2Vzc0ZpZWxkcyh0YWJsZSwgY29sdW1ucykge1xuICAgICAgICBsZXQgZmVhdHVyZXMgPSBbXSwgZmllbGRzID0ge30sIHR5cGVzID0ge307XG5cbiAgICAgICAgY29sdW1ucy5mb3JFYWNoKGNvbCA9PiB7XG4gICAgICAgICAgICBsZXQgZmllbGROYW1lID0gdGhpcy5fZmllbGROYW1pbmcoY29sLkNPTFVNTl9OQU1FKTtcbiAgICAgICAgICAgIGlmIChjb2wuRVhUUkEgPT09ICdhdXRvX2luY3JlbWVudCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmVhdHVyZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImF1dG9JZFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9wdGlvbnNcIjogdGFibGUuQVVUT19JTkNSRU1FTlQgPyB7ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0YXJ0RnJvbVwiOiB0YWJsZS5BVVRPX0lOQ1JFTUVOVFxuICAgICAgICAgICAgICAgICAgICB9IDoge31cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lkJykge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlSW5mby5vcHRpb25zLm5hbWUgPSBmaWVsZE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZUluZm8pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbC5DT0xVTU5fREVGQVVMVCA9PT0gJ0NVUlJFTlRfVElNRVNUQU1QJykge1xuICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY3JlYXRlVGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZUluZm8pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbC5FWFRSQSA9PT0gJ29uIHVwZGF0ZSBDVVJSRU5UX1RJTUVTVEFNUCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmVhdHVyZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInVwZGF0ZVRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmVJbmZvKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09ICdpc0RlbGV0ZWQnICYmIGNvbC5DT0xVTU5fVFlQRSA9PT0gJ3RpbnlpbnQoMSknKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZlYXR1cmVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJsb2dpY2FsRGVsZXRpb25cIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlSW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZmllbGRJbmZvID0gdGhpcy5fbXlzcWxUeXBlVG9Pb2xUeXBlKHRhYmxlLCBjb2wsIGZpZWxkTmFtZSwgdHlwZXMpO1xuXG4gICAgICAgICAgICBpZiAoY29sLklTX05VTExBQkxFID09PSAnWUVTJykge1xuICAgICAgICAgICAgICAgIGZpZWxkSW5mby5vcHRpb25hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2wuQ09MVU1OX0RFRkFVTFQpIHtcbiAgICAgICAgICAgICAgICBmaWVsZEluZm8uZGVmYXVsdCA9IGNvbC5DT0xVTU5fREVGQVVMVDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbC5DT0xVTU5fQ09NTUVOVCkge1xuICAgICAgICAgICAgICAgIGZpZWxkSW5mby5jb21tZW50ID0gY29sLkNPTFVNTl9DT01NRU5UO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXSA9IGZpZWxkSW5mbztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgZmVhdHVyZXMsIGZpZWxkcywgdHlwZXMgfTtcbiAgICB9XG5cbiAgICBfZmllbGROYW1pbmcobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5yZXZlcnNlUnVsZXMuZmllbGROYW1pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2VSdWxlcy5maWVsZE5hbWluKG5hbWUpO1xuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIEdlbWxVdGlscy5maWVsZE5hbWluZyhuYW1lKTtcbiAgICB9XG5cbiAgICBfZW50aXR5TmFtaW5nKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmV2ZXJzZVJ1bGVzLmVudGl0eU5hbWluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZVJ1bGVzLmVudGl0eU5hbWluZyhuYW1lKTtcbiAgICAgICAgfSBcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBHZW1sVXRpbHMuZW50aXR5TmFtaW5nKG5hbWUpO1xuICAgIH1cblxuICAgIF9zY2hlbWFOYW1pbmcobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5yZXZlcnNlUnVsZXMuc2NoZW1hTmFtaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlUnVsZXMuc2NoZW1hTmFtaW5nKG5hbWUpO1xuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIEdlbWxVdGlscy5zY2hlbWFOYW1pbmcobmFtZSk7XG4gICAgfVxuXG4gICAgX215c3FsVHlwZVRvT29sVHlwZSh0YWJsZSwgY29sLCBmaWVsZE5hbWUsIHR5cGVzKSB7XG4gICAgICAgIGxldCBhcHBsaWNhYmxlUnVsZSA9IF8uZmluZCh0aGlzLnJldmVyc2VSdWxlcy5jb2x1bW5UeXBlQ29udmVyc2lvbiwgcnVsZSA9PiBydWxlLnRlc3QodGFibGUsIGNvbCkpO1xuICAgICAgICBpZiAoYXBwbGljYWJsZVJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBsaWNhYmxlUnVsZS5hcHBseSh0YWJsZSwgY29sKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGV0IHR5cGVJbmZvID0ge307ICAgICAgICBcbiAgICAgICAgaWYgKGNvbC5DT0xVTU5fTkFNRSAhPT0gZmllbGROYW1lKSB7XG4gICAgICAgICAgICB0eXBlSW5mby5jb2RlID0gY29sLkNPTFVNTl9OQU1FO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjb2wuREFUQV9UWVBFKSB7XG4gICAgICAgICAgICBjYXNlICd2YXJjaGFyJzpcbiAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gJ3RleHQnO1xuICAgICAgICAgICAgICAgIGlmIChjb2wuQ0hBUkFDVEVSX01BWElNVU1fTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLm1heExlbmd0aCA9IGNvbC5DSEFSQUNURVJfTUFYSU1VTV9MRU5HVEg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdjaGFyJzpcbiAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gJ3RleHQnO1xuICAgICAgICAgICAgICAgIGlmIChjb2wuQ0hBUkFDVEVSX01BWElNVU1fTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLmZpeGVkTGVuZ3RoID0gY29sLkNIQVJBQ1RFUl9NQVhJTVVNX0xFTkdUSDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZSA9ICdpbnRlZ2VyJztcbiAgICAgICAgICAgICAgICB0eXBlSW5mby5kaWdpdHMgPSBjb2wuTlVNRVJJQ19QUkVDSVNJT04gfHwgMTg7XG4gICAgICAgICAgICAgICAgdHlwZUluZm8uYnl0ZXMgPSA4O1xuICAgICAgICAgICAgICAgIGlmIChfLmVuZHNXaXRoKGNvbC5DT0xVTU5fVFlQRSwgJyB1bnNpZ25lZCcpKSB0eXBlSW5mby51bnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2ludCc6XG4gICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZSA9ICdpbnRlZ2VyJztcbiAgICAgICAgICAgICAgICB0eXBlSW5mby5kaWdpdHMgPSBjb2wuTlVNRVJJQ19QUkVDSVNJT04gfHwgMTA7XG4gICAgICAgICAgICAgICAgdHlwZUluZm8uYnl0ZXMgPSA0O1xuICAgICAgICAgICAgICAgIGlmIChfLmVuZHNXaXRoKGNvbC5DT0xVTU5fVFlQRSwgJyB1bnNpZ25lZCcpKSB0eXBlSW5mby51bnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ21lZGl1bWludCc6XG4gICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZSA9ICdpbnRlZ2VyJztcbiAgICAgICAgICAgICAgICB0eXBlSW5mby5kaWdpdHMgPSBjb2wuTlVNRVJJQ19QUkVDSVNJT04gfHwgNztcbiAgICAgICAgICAgICAgICB0eXBlSW5mby5ieXRlcyA9IDM7XG4gICAgICAgICAgICAgICAgaWYgKF8uZW5kc1dpdGgoY29sLkNPTFVNTl9UWVBFLCAnIHVuc2lnbmVkJykpIHR5cGVJbmZvLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc21hbGxpbnQnOlxuICAgICAgICAgICAgICAgIHR5cGVJbmZvLnR5cGUgPSAnaW50ZWdlcic7XG4gICAgICAgICAgICAgICAgdHlwZUluZm8uZGlnaXRzID0gY29sLk5VTUVSSUNfUFJFQ0lTSU9OIHx8IDQ7XG4gICAgICAgICAgICAgICAgdHlwZUluZm8uYnl0ZXMgPSAyO1xuICAgICAgICAgICAgICAgIGlmIChfLmVuZHNXaXRoKGNvbC5DT0xVTU5fVFlQRSwgJyB1bnNpZ25lZCcpKSB0eXBlSW5mby51bnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3RpbnlpbnQnOlxuICAgICAgICAgICAgICAgIGlmIChfLnN0YXJ0c1dpdGgoY29sLkNPTFVNTl9UWVBFLCAndGlueWludCgxKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLnR5cGUgPSAnYm9vbGVhbic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZSA9ICdpbnRlZ2VyJztcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8uZGlnaXRzID0gY29sLk5VTUVSSUNfUFJFQ0lTSU9OIHx8IDI7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLmJ5dGVzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uZW5kc1dpdGgoY29sLkNPTFVNTl9UWVBFLCAnIHVuc2lnbmVkJykpIHR5cGVJbmZvLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gY29sLkNPTFVNTl9UWVBFLmluZGV4T2YoJygnKTtcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSBjb2wuQ09MVU1OX1RZUEUubGFzdEluZGV4T2YoJyknKTtcblxuICAgICAgICAgICAgICAgIGxldCB0eXBlTmFtZSA9IHRhYmxlLlRBQkxFX05BTUUgKyBfLnVwcGVyRmlyc3QoY29sLkNPTFVNTl9OQU1FKTtcblxuICAgICAgICAgICAgICAgIHR5cGVzW3R5cGVOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VudW0nLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGNvbC5DT0xVTU5fVFlQRS5zdWJzdHJpbmcobGVmdCArIDEsIHJpZ2h0KS5zcGxpdCgnLCcpLm1hcCh2ID0+IHYuc3Vic3RyKDEsIHYubGVuZ3RoIC0gMikpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHR5cGVJbmZvLnR5cGUgPSB0eXBlTmFtZTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gJ3RleHQnO1xuICAgICAgICAgICAgICAgIHR5cGVJbmZvLm1heExlbmd0aCA9IGNvbC5DSEFSQUNURVJfTUFYSU1VTV9MRU5HVEg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZSA9ICdkYXRldGltZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgICAgIHR5cGVJbmZvLnR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICB0eXBlSW5mby50b3RhbERpZ2l0cyA9IGNvbC5OVU1FUklDX1BSRUNJU0lPTjtcbiAgICAgICAgICAgICAgICB0eXBlSW5mby5kZWNpbWFsRGlnaXRzID0gY29sLk5VTUVSSUNfU0NBTEU7XG4gICAgICAgICAgICAgICAgdHlwZUluZm8uZXhhY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZSA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIHR5cGVJbmZvLnRvdGFsRGlnaXRzID0gY29sLk5VTUVSSUNfUFJFQ0lTSU9OO1xuICAgICAgICAgICAgICAgIHR5cGVJbmZvLmRlY2ltYWxEaWdpdHMgPSBjb2wuTlVNRVJJQ19TQ0FMRTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb2wpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gYmUgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL18uZmluZCh0aGlzLnJldmVyc2VSdWxlcy5jb2x1bW5UeXBlT3B0aW1pemF0aW9uLCBydWxlID0+IHJ1bGUudGVzdCh0YWJsZSwgY29sKSk7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVJbmZvO1xuICAgIH1cblxuICAgIF9yZWZpbmVFbnRpdHlSZWxhdGlvbnNoaXBzKG1hcE9mRW50aXRpZXMpIHtcbiAgICAgICAgbGV0IGVudGl0eUFzc29jID0ge307XG5cbiAgICAgICAgLy8xc3Qgcm91bmRcbiAgICAgICAgXy5mb3JPd24obWFwT2ZFbnRpdGllcywgKHsgZW50aXR5SW5mbyB9LCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoXy5pc0VtcHR5KGVudGl0eUluZm8uYXNzb2NpYXRpb25zKSkgcmV0dXJuOyAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBlbnRpdHlJbmZvLmFzc29jaWF0aW9ucy5mb3JFYWNoKCh7IHR5cGUsIHNyY0ZpZWxkLCBkZXN0RW50aXR5IH0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVmZWRFbnRpdHkgPSBtYXBPZkVudGl0aWVzW2Rlc3RFbnRpdHldO1xuICAgICAgICAgICAgICAgIGxldCBiYWNrUmVmID0gXy5maW5kKHJlZmVkRW50aXR5LmFzc29jaWF0aW9ucywgYXNzb2MgPT4gYXNzb2MuZGVzdEVudGl0eSA9PT0gbmFtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2hhc01hbnknKSB7ICAgXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiYWNrUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL29uZS1zaWRlIHJlbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlsLnB1dEludG9CdWNrZXQoZW50aXR5QXNzb2MsIG5hbWUsIHsgdHlwZTogJ3JlZmVyc1RvJywgc3JjRmllbGQsIGRlc3RFbnRpdHkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL3RvZG86XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVudGl0eUluZm8pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhY2sgcmVmZXJlbmNlOiAke2JhY2tSZWYuZW50aXR5fSAke2JhY2tSZWYudHlwZX0gJHtuYW1lfWApOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYmVsb25nc1RvJykge1xuXG4gICAgICAgICAgICAgICAgICAgIFV0aWwucHV0SW50b0J1Y2tldChlbnRpdHlBc3NvYywgbmFtZSwgeyB0eXBlLCBzcmNGaWVsZCwgZGVzdEVudGl0eSB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhY2tSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb25lLXNpZGUgcmVsYXRpb24gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwucHV0SW50b0J1Y2tldChlbnRpdHlBc3NvYywgZW50aXR5LCB7IHR5cGU6ICdoYXNNYW55JywgZGVzdEVudGl0eTogbmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgYXNzb2NpYXRpb24gdHlwZTogJyArIHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pOyAgICAgICAgICAgIFxuICAgICAgICB9KTsgICAgICAgIFxuXG4gICAgICAgIC8vMm5kIHJvdW5kXG4gICAgICAgIF8uZm9yT3duKGVudGl0eUFzc29jLCAoYXNzb2NpYXRpb25zLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBlbnRpdHlJbmZvIH0gPSBtYXBPZkVudGl0aWVzW25hbWVdO1xuXG4gICAgICAgICAgICBsZXQga2V5QXNzb2NzO1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRpdHlJbmZvLmtleSkgJiYgZW50aXR5SW5mby5rZXkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAga2V5QXNzb2NzID0gXy5maWx0ZXIoYXNzb2NpYXRpb25zLCBhc3NvYyA9PiBlbnRpdHlJbmZvLmtleS5pbmRleE9mKGFzc29jLnNyY0ZpZWxkKSAhPT0gLTEpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlBc3NvY3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VFbnRpdHlNYW55VG9NYW55KGtleUFzc29jc1swXS5kZXN0RW50aXR5LCBrZXlBc3NvY3NbMV0uZGVzdEVudGl0eSwgZW50aXR5QXNzb2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW50aXR5SW5mby5pbmRleGVzLmZvckVhY2goKHsgZmllbGRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBrZXlBc3NvY3MgPSBfLmZpbHRlcihhc3NvY2lhdGlvbnMsIGFzc29jID0+IGZpZWxkcy5pbmRleE9mKGFzc29jLnNyY0ZpZWxkKSAhPT0gLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5QXNzb2NzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUVudGl0eU1hbnlUb01hbnkoa2V5QXNzb2NzWzBdLmRlc3RFbnRpdHksIGtleUFzc29jc1sxXS5kZXN0RW50aXR5LCBlbnRpdHlBc3NvYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXy5mb3JPd24obWFwT2ZFbnRpdGllcywgKHsgZW50aXR5SW5mbyB9LCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBlbnRpdHlJbmZvLmFzc29jaWF0aW9ucyA9IGVudGl0eUFzc29jW25hbWVdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfbWFrZUVudGl0eU1hbnlUb01hbnkoZW50aXR5TmFtZTEsIGVudGl0eU5hbWUyLCBlbnRpdHlBc3NvYykge1xuICAgICAgICBVdGlsLnB1dEludG9CdWNrZXQoZW50aXR5QXNzb2MsIGVudGl0eU5hbWUxLCB7IHR5cGU6ICdoYXNNYW55JywgZGVzdEVudGl0eTogZW50aXR5TmFtZTIgfSk7XG4gICAgICAgIFV0aWwucHV0SW50b0J1Y2tldChlbnRpdHlBc3NvYywgZW50aXR5TmFtZTIsIHsgdHlwZTogJ2hhc01hbnknLCBkZXN0RW50aXR5OiBlbnRpdHlOYW1lMSB9KTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTXlTUUxSZXZlcnNlRW5naW5lZXJpbmc7Il19