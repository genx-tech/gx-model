"use strict";

require("source-map-support/register");

const path = require('path');

const Util = require('rk-utils');

const {
  _,
  fs
} = Util;

const GemlCodeGen = require('../../../lang/GemlCodeGen');

const GemlUtils = require('../../../lang/GemlUtils');

class MySQLReverseEngineering {
  constructor(context, connector) {
    this.logger = context.logger;
    this.connector = connector;
    this.reverseRules = this.connector.options.reverseRules || {};
    this.saveDatabaseMeta = this.connector.options.saveDatabaseMeta || false;
  }

  async reverse_(outputDir) {
    this.logger.log('verbose', `Reverse engineering against ${this.connector.driver} database "${this.connector.database}" ...`);
    fs.ensureDirSync(outputDir);
    let tables = await this.connector.execute_("select * from information_schema.tables where table_schema = ?", [this.connector.database]);

    if (this.saveDatabaseMeta) {
      fs.writeFileSync(path.join(outputDir, this.connector.database + '.meta.json'), JSON.stringify(tables, null, 2));
    }

    let entities = [],
        mapOfEntities = {};
    let entitiesOolPath = path.join(outputDir, 'entities');
    fs.ensureDirSync(entitiesOolPath);
    await Util.eachAsync_(tables, async table => {
      let entityName = this._entityNaming(table.TABLE_NAME);

      entities.push({
        entity: entityName
      });
      mapOfEntities[entityName] = await this.extractTable_(entityName, table, entitiesOolPath);
    });

    this._refineEntityRelationships(mapOfEntities);

    _.forOwn(mapOfEntities, ({
      types,
      entityInfo
    }, entityName) => {
      let entity = {
        type: types,
        entity: {
          [entityName]: entityInfo
        }
      };
      let entityContent = GemlCodeGen.transform(entity);
      let entityFile = path.join(entitiesOolPath, entityName + '.ool');
      fs.writeFileSync(entityFile + '.json', JSON.stringify(entity, null, 2));
      fs.writeFileSync(entityFile, entityContent);
      this.logger.log('info', `Extracted entity definition file "${entityFile}".`);
    });

    let schemaName = this._schemaNaming(this.connector.database);

    let json = {
      "namespace": ["entities/**"],
      "schema": {
        [schemaName]: {
          "entities": entities
        }
      }
    };
    let schemaContent = GemlCodeGen.transform(json);
    let schemaFile = path.join(outputDir, schemaName + '.ool');
    fs.writeFileSync(schemaFile + '.json', JSON.stringify(json, null, 2));
    fs.writeFileSync(schemaFile, schemaContent);
    this.logger.log('info', `Extracted schema entry file "${schemaFile}".`);
  }

  async extractTable_(entityName, table, extractedOolPath) {
    let columns = await this.connector.execute_("select * from information_schema.columns where table_schema = ? and table_name = ?", [this.connector.database, table.TABLE_NAME]);

    if (this.saveDatabaseMeta) {
      fs.writeFileSync(path.join(extractedOolPath, table.TABLE_NAME + '.meta.json'), JSON.stringify(columns, null, 2));
    }

    let {
      features,
      fields,
      types
    } = this._processFields(table, columns);

    let indexInfo = await this.connector.execute_("SHOW INDEXES FROM ??", [table.TABLE_NAME]);

    if (this.saveDatabaseMeta && !_.isEmpty(indexInfo)) {
      fs.writeFileSync(path.join(extractedOolPath, table.TABLE_NAME + '.index.json'), JSON.stringify(indexInfo, null, 2));
    }

    let {
      pk,
      indexes,
      mapNameToIndex
    } = this._processIndexes(indexInfo);

    if (!(pk.length > 0)) {
      throw new Error("Assertion failed: pk.length > 0");
    }

    let referencesInfo = await this.connector.execute_("SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE `REFERENCED_TABLE_SCHEMA` = ? AND `TABLE_NAME` = ? AND `REFERENCED_TABLE_NAME` IS NOT NULL", [this.connector.database, table.TABLE_NAME]);

    if (this.saveDatabaseMeta && !_.isEmpty(referencesInfo)) {
      fs.writeFileSync(path.join(extractedOolPath, table.TABLE_NAME + '.ref.json'), JSON.stringify(referencesInfo, null, 2));
    }

    let associations = await this._processReferences_(referencesInfo, mapNameToIndex, fields);
    let entityInfo = {
      comment: table.TABLE_COMMENT,
      features,
      fields,
      associations,
      key: pk.length > 1 ? pk : pk[0],
      indexes
    };

    if (entityName !== table.TABLE_NAME) {
      entityInfo.code = table.TABLE_NAME;
    }

    return {
      types,
      entityInfo
    };
  }

  async _processReferences_(referencesInfo, mapNameToIndex, fields) {
    let associations = [];
    let l = referencesInfo.length;

    for (let i = 0; i < l; i++) {
      let ref = referencesInfo[i];
      let [refTableKey] = await this.connector.execute_("SHOW INDEXES FROM ?? WHERE `Key_name` = 'PRIMARY'", [ref.REFERENCED_TABLE_NAME]);

      if (refTableKey.Column_name.toLowerCase() !== ref.REFERENCED_COLUMN_NAME.toLowerCase()) {
        throw new Error(`Foreign key "${ref.COLUMN_NAME}" not reference to the primary key.`);
      }

      let unique = false;
      let fkInfo = mapNameToIndex[ref.CONSTRAINT_NAME];

      if (fkInfo) {
        if (fkInfo.length > 1) {
          throw new Error(`Combination foreign key is not supported: "${ref.CONSTRAINT_NAME}"`);
        }

        unique = fkInfo[0].Non_unique === 0;
      }

      let fkColName = this._fieldNaming(ref.COLUMN_NAME);

      if (unique) {
        associations.push({
          type: 'belongsTo',
          srcField: fkColName,
          destEntity: this._entityNaming(ref.REFERENCED_TABLE_NAME)
        });
      } else {
        associations.push({
          type: 'hasMany',
          srcField: fkColName,
          destEntity: this._entityNaming(ref.REFERENCED_TABLE_NAME)
        });
      }

      delete fields[fkColName];
    }

    return associations;
  }

  _processIndexes(indexInfo) {
    let pk = [],
        indexes = [];
    let mapNameToIndex = {};
    indexInfo.forEach(i => {
      Util.putIntoBucket(mapNameToIndex, i.Key_name, i);
    });

    _.forOwn(mapNameToIndex, (fields, name) => {
      if (name === 'PRIMARY') {
        pk.push(fields.map(f => this._fieldNaming(f.Column_name)));
      } else {
        indexes.push({
          name: name,
          fields: fields.map(f => this._fieldNaming(f.Column_name)),
          unique: fields[0].Non_unique === 0,
          nullable: fields[0].Null === 'YES'
        });
      }
    });

    return {
      pk,
      indexes,
      mapNameToIndex
    };
  }

  _processFields(table, columns) {
    let features = [],
        fields = {},
        types = {};
    columns.forEach(col => {
      let fieldName = this._fieldNaming(col.COLUMN_NAME);

      if (col.EXTRA === 'auto_increment') {
        let featureInfo = {
          "name": "autoId",
          "options": table.AUTO_INCREMENT ? {
            "startFrom": table.AUTO_INCREMENT
          } : {}
        };

        if (fieldName !== 'id') {
          featureInfo.options.name = fieldName;
        }

        features.push(featureInfo);
        return;
      }

      if (col.COLUMN_DEFAULT === 'CURRENT_TIMESTAMP') {
        let featureInfo = {
          "name": "createTimestamp"
        };
        features.push(featureInfo);
        return;
      }

      if (col.EXTRA === 'on update CURRENT_TIMESTAMP') {
        let featureInfo = {
          "name": "updateTimestamp"
        };
        features.push(featureInfo);
        return;
      }

      if (fieldName === 'isDeleted' && col.COLUMN_TYPE === 'tinyint(1)') {
        let featureInfo = {
          "name": "logicalDeletion"
        };
        features.push(featureInfo);
        return;
      }

      let fieldInfo = this._mysqlTypeToOolType(table, col, fieldName, types);

      if (col.IS_NULLABLE === 'YES') {
        fieldInfo.optional = true;
      }

      if (col.COLUMN_DEFAULT) {
        fieldInfo.default = col.COLUMN_DEFAULT;
      }

      if (col.COLUMN_COMMENT) {
        fieldInfo.comment = col.COLUMN_COMMENT;
      }

      fields[fieldName] = fieldInfo;
    });
    return {
      features,
      fields,
      types
    };
  }

  _fieldNaming(name) {
    if (this.reverseRules.fieldNaming) {
      return this.reverseRules.fieldNamin(name);
    }

    return GemlUtils.fieldNaming(name);
  }

  _entityNaming(name) {
    if (this.reverseRules.entityNaming) {
      return this.reverseRules.entityNaming(name);
    }

    return GemlUtils.entityNaming(name);
  }

  _schemaNaming(name) {
    if (this.reverseRules.schemaNaming) {
      return this.reverseRules.schemaNaming(name);
    }

    return GemlUtils.schemaNaming(name);
  }

  _mysqlTypeToOolType(table, col, fieldName, types) {
    let applicableRule = _.find(this.reverseRules.columnTypeConversion, rule => rule.test(table, col));

    if (applicableRule) {
      return applicableRule.apply(table, col);
    }

    let typeInfo = {};

    if (col.COLUMN_NAME !== fieldName) {
      typeInfo.code = col.COLUMN_NAME;
    }

    switch (col.DATA_TYPE) {
      case 'varchar':
        typeInfo.type = 'text';

        if (col.CHARACTER_MAXIMUM_LENGTH) {
          typeInfo.maxLength = col.CHARACTER_MAXIMUM_LENGTH;
        }

        break;

      case 'char':
        typeInfo.type = 'text';

        if (col.CHARACTER_MAXIMUM_LENGTH) {
          typeInfo.fixedLength = col.CHARACTER_MAXIMUM_LENGTH;
        }

        break;

      case 'bigint':
        typeInfo.type = 'integer';
        typeInfo.digits = col.NUMERIC_PRECISION || 18;
        typeInfo.bytes = 8;
        if (_.endsWith(col.COLUMN_TYPE, ' unsigned')) typeInfo.unsigned = true;
        break;

      case 'int':
        typeInfo.type = 'integer';
        typeInfo.digits = col.NUMERIC_PRECISION || 10;
        typeInfo.bytes = 4;
        if (_.endsWith(col.COLUMN_TYPE, ' unsigned')) typeInfo.unsigned = true;
        break;

      case 'mediumint':
        typeInfo.type = 'integer';
        typeInfo.digits = col.NUMERIC_PRECISION || 7;
        typeInfo.bytes = 3;
        if (_.endsWith(col.COLUMN_TYPE, ' unsigned')) typeInfo.unsigned = true;
        break;

      case 'smallint':
        typeInfo.type = 'integer';
        typeInfo.digits = col.NUMERIC_PRECISION || 4;
        typeInfo.bytes = 2;
        if (_.endsWith(col.COLUMN_TYPE, ' unsigned')) typeInfo.unsigned = true;
        break;

      case 'tinyint':
        if (_.startsWith(col.COLUMN_TYPE, 'tinyint(1)')) {
          typeInfo.type = 'boolean';
        } else {
          typeInfo.type = 'integer';
          typeInfo.digits = col.NUMERIC_PRECISION || 2;
          typeInfo.bytes = 1;
          if (_.endsWith(col.COLUMN_TYPE, ' unsigned')) typeInfo.unsigned = true;
        }

        break;

      case 'enum':
        let left = col.COLUMN_TYPE.indexOf('(');
        let right = col.COLUMN_TYPE.lastIndexOf(')');

        let typeName = table.TABLE_NAME + _.upperFirst(col.COLUMN_NAME);

        types[typeName] = {
          type: 'enum',
          values: col.COLUMN_TYPE.substring(left + 1, right).split(',').map(v => v.substr(1, v.length - 2))
        };
        typeInfo.type = typeName;
        break;

      case 'text':
        typeInfo.type = 'text';
        typeInfo.maxLength = col.CHARACTER_MAXIMUM_LENGTH;
        break;

      case 'datetime':
      case 'timestamp':
        typeInfo.type = 'datetime';
        break;

      case 'decimal':
        typeInfo.type = 'number';
        typeInfo.totalDigits = col.NUMERIC_PRECISION;
        typeInfo.decimalDigits = col.NUMERIC_SCALE;
        typeInfo.exact = true;
        break;

      case 'float':
        typeInfo.type = 'number';
        typeInfo.totalDigits = col.NUMERIC_PRECISION;
        typeInfo.decimalDigits = col.NUMERIC_SCALE;
        break;

      default:
        console.log(col);
        throw new Error('To be implemented.');
    }

    return typeInfo;
  }

  _refineEntityRelationships(mapOfEntities) {
    let entityAssoc = {};

    _.forOwn(mapOfEntities, ({
      entityInfo
    }, name) => {
      if (_.isEmpty(entityInfo.associations)) return;
      entityInfo.associations.forEach(({
        type,
        srcField,
        destEntity
      }) => {
        let refedEntity = mapOfEntities[destEntity];

        let backRef = _.find(refedEntity.associations, assoc => assoc.destEntity === name);

        if (type === 'hasMany') {
          if (!backRef) {
            Util.putIntoBucket(entityAssoc, name, {
              type: 'refersTo',
              srcField,
              destEntity
            });
            return;
          }

          console.log(entityInfo);
          throw new Error(`Back reference: ${backRef.entity} ${backRef.type} ${name}`);
        } else if (type === 'belongsTo') {
          Util.putIntoBucket(entityAssoc, name, {
            type,
            srcField,
            destEntity
          });

          if (!backRef) {
            Util.putIntoBucket(entityAssoc, entity, {
              type: 'hasMany',
              destEntity: name
            });
            return;
          }
        } else {
          throw new Error('Unexpected association type: ' + type);
        }
      });
    });

    _.forOwn(entityAssoc, (associations, name) => {
      let {
        entityInfo
      } = mapOfEntities[name];
      let keyAssocs;

      if (Array.isArray(entityInfo.key) && entityInfo.key.length === 2) {
        keyAssocs = _.filter(associations, assoc => entityInfo.key.indexOf(assoc.srcField) !== -1);

        if (keyAssocs.length === 2) {
          this._makeEntityManyToMany(keyAssocs[0].destEntity, keyAssocs[1].destEntity, entityAssoc);
        }
      }

      entityInfo.indexes.forEach(({
        fields
      }) => {
        if (fields.length === 2) {
          keyAssocs = _.filter(associations, assoc => fields.indexOf(assoc.srcField) !== -1);

          if (keyAssocs.length === 2) {
            this._makeEntityManyToMany(keyAssocs[0].destEntity, keyAssocs[1].destEntity, entityAssoc);
          }
        }
      });
    });

    _.forOwn(mapOfEntities, ({
      entityInfo
    }, name) => {
      entityInfo.associations = entityAssoc[name];
    });
  }

  _makeEntityManyToMany(entityName1, entityName2, entityAssoc) {
    Util.putIntoBucket(entityAssoc, entityName1, {
      type: 'hasMany',
      destEntity: entityName2
    });
    Util.putIntoBucket(entityAssoc, entityName2, {
      type: 'hasMany',
      destEntity: entityName1
    });
  }

}

module.exports = MySQLReverseEngineering;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2RlbGVyL2RhdGFiYXNlL215c3FsL1JldmVyc2VFbmdpbmVlcmluZy5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIlV0aWwiLCJfIiwiZnMiLCJHZW1sQ29kZUdlbiIsIkdlbWxVdGlscyIsIk15U1FMUmV2ZXJzZUVuZ2luZWVyaW5nIiwiY29uc3RydWN0b3IiLCJjb250ZXh0IiwiY29ubmVjdG9yIiwibG9nZ2VyIiwicmV2ZXJzZVJ1bGVzIiwib3B0aW9ucyIsInNhdmVEYXRhYmFzZU1ldGEiLCJyZXZlcnNlXyIsIm91dHB1dERpciIsImxvZyIsImRyaXZlciIsImRhdGFiYXNlIiwiZW5zdXJlRGlyU3luYyIsInRhYmxlcyIsImV4ZWN1dGVfIiwid3JpdGVGaWxlU3luYyIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5IiwiZW50aXRpZXMiLCJtYXBPZkVudGl0aWVzIiwiZW50aXRpZXNPb2xQYXRoIiwiZWFjaEFzeW5jXyIsInRhYmxlIiwiZW50aXR5TmFtZSIsIl9lbnRpdHlOYW1pbmciLCJUQUJMRV9OQU1FIiwicHVzaCIsImVudGl0eSIsImV4dHJhY3RUYWJsZV8iLCJfcmVmaW5lRW50aXR5UmVsYXRpb25zaGlwcyIsImZvck93biIsInR5cGVzIiwiZW50aXR5SW5mbyIsInR5cGUiLCJlbnRpdHlDb250ZW50IiwidHJhbnNmb3JtIiwiZW50aXR5RmlsZSIsInNjaGVtYU5hbWUiLCJfc2NoZW1hTmFtaW5nIiwianNvbiIsInNjaGVtYUNvbnRlbnQiLCJzY2hlbWFGaWxlIiwiZXh0cmFjdGVkT29sUGF0aCIsImNvbHVtbnMiLCJmZWF0dXJlcyIsImZpZWxkcyIsIl9wcm9jZXNzRmllbGRzIiwiaW5kZXhJbmZvIiwiaXNFbXB0eSIsInBrIiwiaW5kZXhlcyIsIm1hcE5hbWVUb0luZGV4IiwiX3Byb2Nlc3NJbmRleGVzIiwibGVuZ3RoIiwicmVmZXJlbmNlc0luZm8iLCJhc3NvY2lhdGlvbnMiLCJfcHJvY2Vzc1JlZmVyZW5jZXNfIiwiY29tbWVudCIsIlRBQkxFX0NPTU1FTlQiLCJrZXkiLCJjb2RlIiwibCIsImkiLCJyZWYiLCJyZWZUYWJsZUtleSIsIlJFRkVSRU5DRURfVEFCTEVfTkFNRSIsIkNvbHVtbl9uYW1lIiwidG9Mb3dlckNhc2UiLCJSRUZFUkVOQ0VEX0NPTFVNTl9OQU1FIiwiRXJyb3IiLCJDT0xVTU5fTkFNRSIsInVuaXF1ZSIsImZrSW5mbyIsIkNPTlNUUkFJTlRfTkFNRSIsIk5vbl91bmlxdWUiLCJma0NvbE5hbWUiLCJfZmllbGROYW1pbmciLCJzcmNGaWVsZCIsImRlc3RFbnRpdHkiLCJmb3JFYWNoIiwicHV0SW50b0J1Y2tldCIsIktleV9uYW1lIiwibmFtZSIsIm1hcCIsImYiLCJudWxsYWJsZSIsIk51bGwiLCJjb2wiLCJmaWVsZE5hbWUiLCJFWFRSQSIsImZlYXR1cmVJbmZvIiwiQVVUT19JTkNSRU1FTlQiLCJDT0xVTU5fREVGQVVMVCIsIkNPTFVNTl9UWVBFIiwiZmllbGRJbmZvIiwiX215c3FsVHlwZVRvT29sVHlwZSIsIklTX05VTExBQkxFIiwib3B0aW9uYWwiLCJkZWZhdWx0IiwiQ09MVU1OX0NPTU1FTlQiLCJmaWVsZE5hbWluZyIsImZpZWxkTmFtaW4iLCJlbnRpdHlOYW1pbmciLCJzY2hlbWFOYW1pbmciLCJhcHBsaWNhYmxlUnVsZSIsImZpbmQiLCJjb2x1bW5UeXBlQ29udmVyc2lvbiIsInJ1bGUiLCJ0ZXN0IiwiYXBwbHkiLCJ0eXBlSW5mbyIsIkRBVEFfVFlQRSIsIkNIQVJBQ1RFUl9NQVhJTVVNX0xFTkdUSCIsIm1heExlbmd0aCIsImZpeGVkTGVuZ3RoIiwiZGlnaXRzIiwiTlVNRVJJQ19QUkVDSVNJT04iLCJieXRlcyIsImVuZHNXaXRoIiwidW5zaWduZWQiLCJzdGFydHNXaXRoIiwibGVmdCIsImluZGV4T2YiLCJyaWdodCIsImxhc3RJbmRleE9mIiwidHlwZU5hbWUiLCJ1cHBlckZpcnN0IiwidmFsdWVzIiwic3Vic3RyaW5nIiwic3BsaXQiLCJ2Iiwic3Vic3RyIiwidG90YWxEaWdpdHMiLCJkZWNpbWFsRGlnaXRzIiwiTlVNRVJJQ19TQ0FMRSIsImV4YWN0IiwiY29uc29sZSIsImVudGl0eUFzc29jIiwicmVmZWRFbnRpdHkiLCJiYWNrUmVmIiwiYXNzb2MiLCJrZXlBc3NvY3MiLCJBcnJheSIsImlzQXJyYXkiLCJmaWx0ZXIiLCJfbWFrZUVudGl0eU1hbnlUb01hbnkiLCJlbnRpdHlOYW1lMSIsImVudGl0eU5hbWUyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsTUFBTUMsSUFBSSxHQUFHRCxPQUFPLENBQUMsVUFBRCxDQUFwQjs7QUFDQSxNQUFNO0FBQUVFLEVBQUFBLENBQUY7QUFBS0MsRUFBQUE7QUFBTCxJQUFZRixJQUFsQjs7QUFDQSxNQUFNRyxXQUFXLEdBQUdKLE9BQU8sQ0FBQywyQkFBRCxDQUEzQjs7QUFDQSxNQUFNSyxTQUFTLEdBQUdMLE9BQU8sQ0FBQyx5QkFBRCxDQUF6Qjs7QUFFQSxNQUFNTSx1QkFBTixDQUE4QjtBQUMxQkMsRUFBQUEsV0FBVyxDQUFDQyxPQUFELEVBQVVDLFNBQVYsRUFBcUI7QUFDNUIsU0FBS0MsTUFBTCxHQUFjRixPQUFPLENBQUNFLE1BQXRCO0FBQ0EsU0FBS0QsU0FBTCxHQUFpQkEsU0FBakI7QUFFQSxTQUFLRSxZQUFMLEdBQW9CLEtBQUtGLFNBQUwsQ0FBZUcsT0FBZixDQUF1QkQsWUFBdkIsSUFBdUMsRUFBM0Q7QUFDQSxTQUFLRSxnQkFBTCxHQUF3QixLQUFLSixTQUFMLENBQWVHLE9BQWYsQ0FBdUJDLGdCQUF2QixJQUEyQyxLQUFuRTtBQUNIOztBQUVELFFBQU1DLFFBQU4sQ0FBZUMsU0FBZixFQUEwQjtBQUN0QixTQUFLTCxNQUFMLENBQVlNLEdBQVosQ0FBZ0IsU0FBaEIsRUFBNEIsK0JBQThCLEtBQUtQLFNBQUwsQ0FBZVEsTUFBTyxjQUFhLEtBQUtSLFNBQUwsQ0FBZVMsUUFBUyxPQUFySDtB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O0FBRUQrRCxFQUFBQSxxQkFBcUIsQ0FBQ0MsV0FBRCxFQUFjQyxXQUFkLEVBQTJCVixXQUEzQixFQUF3QztBQUN6RGhKLElBQUFBLElBQUksQ0FBQ3VGLGFBQUwsQ0FBbUJ5RCxXQUFuQixFQUFnQ1MsV0FBaEMsRUFBNkM7QUFBRWpILE1BQUFBLElBQUksRUFBRSxTQUFSO0FBQW1CNkMsTUFBQUEsVUFBVSxFQUFFcUU7QUFBL0IsS0FBN0M7QUFDQTFKLElBQUFBLElBQUksQ0FBQ3VGLGFBQUwsQ0FBbUJ5RCxXQUFuQixFQUFnQ1UsV0FBaEMsRUFBNkM7QUFBRWxILE1BQUFBLElBQUksRUFBRSxTQUFSO0FBQW1CNkMsTUFBQUEsVUFBVSxFQUFFb0U7QUFBL0IsS0FBN0M7QUFDSDs7QUFqY3lCOztBQW9jOUJFLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQnZKLHVCQUFqQiIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgncmstdXRpbHMnKTtcbmNvbnN0IHsgXywgZnMgfSA9IFV0aWw7XG5jb25zdCBHZW1sQ29kZUdlbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xhbmcvR2VtbENvZGVHZW4nKTtcbmNvbnN0IEdlbWxVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xhbmcvR2VtbFV0aWxzJyk7XG5cbmNsYXNzIE15U1FMUmV2ZXJzZUVuZ2luZWVyaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjb25uZWN0b3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjb250ZXh0LmxvZ2dlcjtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBjb25uZWN0b3I7ICAgICAgICBcblxuICAgICAgICB0aGlzLnJldmVyc2VSdWxlcyA9IHRoaXMuY29ubmVjdG9yLm9wdGlvbnMucmV2ZXJzZVJ1bGVzIHx8IHt9OyAgICAgICBcbiAgICAgICAgdGhpcy5zYXZlRGF0YWJhc2VNZXRhID0gdGhpcy5jb25uZWN0b3Iub3B0aW9ucy5zYXZlRGF0YWJhc2VNZXRhIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIGFzeW5jIHJldmVyc2VfKG91dHB1dERpcikge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ3ZlcmJvc2UnLCBgUmV2ZXJzZSBlbmdpbmVlcmluZyBhZ2FpbnN0ICR7dGhpcy5jb25uZWN0b3IuZHJpdmVyfSBkYXRhYmFzZSBcIiR7dGhpcy5jb25uZWN0b3IuZGF0YWJhc2V9XCIgLi4uYCk7XG5cbiAgICAgICAgZnMuZW5zdXJlRGlyU3luYyhvdXRwdXREaXIpO1xuXG4gICAgICAgIGxldCB0YWJsZXMgPSBhd2FpdCB0aGlzLmNvbm5lY3Rvci5leGVjdXRlXyhcInNlbGVjdCAqIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyB3aGVyZSB0YWJsZV9zY2hlbWEgPSA/XCIsIFsgdGhpcy5jb25uZWN0b3IuZGF0YWJhc2UgXSk7ICAgICAgICBcblxuICAgICAgICBpZiAodGhpcy5zYXZlRGF0YWJhc2VNZXRhKSB7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihvdXRwdXREaXIsIHRoaXMuY29ubmVjdG9yLmRhdGFiYXNlICsgJy5tZXRhLmpzb24nKSwgSlNPTi5zdHJpbmdpZnkodGFibGVzLCBudWxsLCAyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZW50aXRpZXMgPSBbXSwgbWFwT2ZFbnRpdGllcyA9IHt9O1xuICAgICAgICBcbiAgICAgICAgbGV0IGVudGl0aWVzT29sUGF0aCA9IHBhdGguam9pbihvdXRwdXREaXIsICdlbnRpdGllcycpO1xuICAgICAgICBmcy5lbnN1cmVEaXJTeW5jKGVudGl0aWVzT29sUGF0aCk7XG5cbiAgICAgICAgYXdhaXQgVXRpbC5lYWNoQXN5bmNfKHRhYmxlcywgYXN5bmMgdGFibGUgPT4ge1xuICAgICAgICAgICAgbGV0IGVudGl0eU5hbWUgPSB0aGlzLl9lbnRpdHlOYW1pbmcodGFibGUuVEFCTEVfTkFNRSk7XG5cbiAgICAgICAgICAgIGVudGl0aWVzLnB1c2goeyBlbnRpdHk6IGVudGl0eU5hbWUgfSk7ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIG1hcE9mRW50aXRpZXNbZW50aXR5TmFtZV0gPSBhd2FpdCB0aGlzLmV4dHJhY3RUYWJsZV8oZW50aXR5TmFtZSwgdGFibGUsIGVudGl0aWVzT29sUGF0aCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlZmluZUVudGl0eVJlbGF0aW9uc2hpcHMobWFwT2ZFbnRpdGllcyk7XG5cbiAgICAgICAgXy5mb3JPd24obWFwT2ZFbnRpdGllcywgKHsgdHlwZXMsIGVudGl0eUluZm8gfSwgZW50aXR5TmFtZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGVudGl0eSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlcyxcbiAgICAgICAgICAgICAgICBlbnRpdHk6IHtcbiAgICAgICAgICAgICAgICAgICAgW2VudGl0eU5hbWVdOiBlbnRpdHlJbmZvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICBcbiAgICAgICAgICAgIGxldCBlbnRpdHlDb250ZW50ID0gR2VtbENvZGVHZW4udHJhbnNmb3JtKGVudGl0eSk7XG4gICAgICAgICAgICBsZXQgZW50aXR5RmlsZSA9IHBhdGguam9pbihlbnRpdGllc09vbFBhdGgsIGVudGl0eU5hbWUgKyAnLm9vbCcpO1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhlbnRpdHlGaWxlICsgJy5qc29uJywgSlNPTi5zdHJpbmdpZnkoZW50aXR5LCBudWxsLCAyKSk7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGVudGl0eUZpbGUsIGVudGl0eUNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKCdpbmZvJywgYEV4dHJhY3RlZCBlbnRpdHkgZGVmaW5pdGlvbiBmaWxlIFwiJHtlbnRpdHlGaWxlfVwiLmApO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgc2NoZW1hTmFtZSA9IHRoaXMuX3NjaGVtYU5hbWluZyh0aGlzLmNvbm5lY3Rvci5kYXRhYmFzZSk7XG5cbiAgICAgICAgbGV0IGpzb24gPSB7XG4gICAgICAgICAgICBcIm5hbWVzcGFjZVwiOiBbXG4gICAgICAgICAgICAgICAgXCJlbnRpdGllcy8qKlwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJzY2hlbWFcIjoge1xuICAgICAgICAgICAgICAgIFtzY2hlbWFOYW1lXToge1xuICAgICAgICAgICAgICAgICAgICBcImVudGl0aWVzXCI6IGVudGl0aWVzICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBzY2hlbWFDb250ZW50ID0gR2VtbENvZGVHZW4udHJhbnNmb3JtKGpzb24pO1xuICAgICAgICBsZXQgc2NoZW1hRmlsZSA9IHBhdGguam9pbihvdXRwdXREaXIsIHNjaGVtYU5hbWUgKyAnLm9vbCcpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHNjaGVtYUZpbGUgKyAnLmpzb24nLCBKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCAyKSk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoc2NoZW1hRmlsZSwgc2NoZW1hQ29udGVudCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnaW5mbycsIGBFeHRyYWN0ZWQgc2NoZW1hIGVudHJ5IGZpbGUgXCIke3NjaGVtYUZpbGV9XCIuYCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZXh0cmFjdFRhYmxlXyhlbnRpdHlOYW1lLCB0YWJsZSwgZXh0cmFjdGVkT29sUGF0aCkge1xuICAgICAgICBsZXQgY29sdW1ucyA9IGF3YWl0IHRoaXMuY29ubmVjdG9yLmV4ZWN1dGVfKFwic2VsZWN0ICogZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyB3aGVyZSB0YWJsZV9zY2hlbWEgPSA/IGFuZCB0YWJsZV9uYW1lID0gP1wiLFxuICAgICAgICAgICAgW3RoaXMuY29ubmVjdG9yLmRhdGFiYXNlLCB0YWJsZS5UQUJMRV9OQU1FXSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2F2ZURhdGFiYXNlTWV0YSkge1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oZXh0cmFjdGVkT29sUGF0aCwgdGFibGUuVEFCTEVfTkFNRSArICcubWV0YS5qc29uJyksIEpTT04uc3RyaW5naWZ5KGNvbHVtbnMsIG51bGwsIDIpKTtcbiAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgbGV0IHsgZmVhdHVyZXMsIGZpZWxkcywgdHlwZXMgfSA9IHRoaXMuX3Byb2Nlc3NGaWVsZHModGFibGUsIGNvbHVtbnMpO1xuXG4gICAgICAgIGxldCBpbmRleEluZm8gPSBhd2FpdCB0aGlzLmNvbm5lY3Rvci5leGVjdXRlXyhcIlNIT1cgSU5ERVhFUyBGUk9NID8/XCIsIFsgdGFibGUuVEFCTEVfTkFNRSBdKTtcblxuICAgICAgICBpZiAodGhpcy5zYXZlRGF0YWJhc2VNZXRhICYmICFfLmlzRW1wdHkoaW5kZXhJbmZvKSkge1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oZXh0cmFjdGVkT29sUGF0aCwgdGFibGUuVEFCTEVfTkFNRSArICcuaW5kZXguanNvbicpLCBKU09OLnN0cmluZ2lmeShpbmRleEluZm8sIG51bGwsIDIpKTtcbiAgICAgICAgfSAgICAgICBcblxuICAgICAgICBsZXQgeyBwaywgaW5kZXhlcywgbWFwTmFtZVRvSW5kZXggfSA9IHRoaXMuX3Byb2Nlc3NJbmRleGVzKGluZGV4SW5mbyk7XG5cbiAgICAgICAgYXNzZXJ0OiBway5sZW5ndGggPiAwOyAgICAgICAgXG5cbiAgICAgICAgbGV0IHJlZmVyZW5jZXNJbmZvID0gYXdhaXQgdGhpcy5jb25uZWN0b3IuZXhlY3V0ZV8oXCJTRUxFQ1QgKiBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFIFdIRVJFIGBSRUZFUkVOQ0VEX1RBQkxFX1NDSEVNQWAgPSA/IEFORCBgVEFCTEVfTkFNRWAgPSA/IEFORCBgUkVGRVJFTkNFRF9UQUJMRV9OQU1FYCBJUyBOT1QgTlVMTFwiLFxuICAgICAgICAgICAgWyB0aGlzLmNvbm5lY3Rvci5kYXRhYmFzZSwgdGFibGUuVEFCTEVfTkFNRSBdKTtcblxuICAgICAgICBpZiAodGhpcy5zYXZlRGF0YWJhc2VNZXRhICYmICFfLmlzRW1wdHkocmVmZXJlbmNlc0luZm8pKSB7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihleHRyYWN0ZWRPb2xQYXRoLCB0YWJsZS5UQUJMRV9OQU1FICsgJy5yZWYuanNvbicpLCBKU09OLnN0cmluZ2lmeShyZWZlcmVuY2VzSW5mbywgbnVsbCwgMikpO1xuICAgICAgICB9ICAgICAgIFxuXG4gICAgICAgIGxldCBhc3NvY2lhdGlvbnMgPSBhd2FpdCB0aGlzLl9wcm9jZXNzUmVmZXJlbmNlc18ocmVmZXJlbmNlc0luZm8sIG1hcE5hbWVUb0luZGV4LCBmaWVsZHMpO1xuXG4gICAgICAgIGxldCBlbnRpdHlJbmZvID0geyAgICAgICAgICAgIFxuICAgICAgICAgICAgY29tbWVudDogdGFibGUuVEFCTEVfQ09NTUVOVCxcbiAgICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgICAgZmllbGRzLFxuICAgICAgICAgICAgYXNzb2NpYXRpb25zLFxuICAgICAgICAgICAga2V5IDogcGsubGVuZ3RoID4gMSA/IHBrIDogcGtbMF0sXG4gICAgICAgICAgICBpbmRleGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGVudGl0eU5hbWUgIT09IHRhYmxlLlRBQkxFX05BTUUpIHtcbiAgICAgICAgICAgIGVudGl0eUluZm8uY29kZSA9IHRhYmxlLlRBQkxFX05BTUU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB0eXBlcywgZW50aXR5SW5mbyB9O1xuICAgIH1cblxuICAgIGFzeW5jIF9wcm9jZXNzUmVmZXJlbmNlc18ocmVmZXJlbmNlc0luZm8sIG1hcE5hbWVUb0luZGV4LCBmaWVsZHMpIHtcbiAgICAgICAgbGV0IGFzc29jaWF0aW9ucyA9IFtdO1xuXG4gICAgICAgIGxldCBsID0gcmVmZXJlbmNlc0luZm8ubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVmID0gcmVmZXJlbmNlc0luZm9baV07XG5cbiAgICAgICAgICAgIGxldCBbcmVmVGFibGVLZXldID0gYXdhaXQgdGhpcy5jb25uZWN0b3IuZXhlY3V0ZV8oXCJTSE9XIElOREVYRVMgRlJPTSA/PyBXSEVSRSBgS2V5X25hbWVgID0gJ1BSSU1BUlknXCIsIFtyZWYuUkVGRVJFTkNFRF9UQUJMRV9OQU1FXSk7XG5cbiAgICAgICAgICAgIGlmIChyZWZUYWJsZUtleS5Db2x1bW5fbmFtZS50b0xvd2VyQ2FzZSgpICE9PSByZWYuUkVGRVJFTkNFRF9DT0xVTU5fTkFNRS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JlaWduIGtleSBcIiR7cmVmLkNPTFVNTl9OQU1FfVwiIG5vdCByZWZlcmVuY2UgdG8gdGhlIHByaW1hcnkga2V5LmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgdW5pcXVlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxldCBma0luZm8gPSBtYXBOYW1lVG9JbmRleFtyZWYuQ09OU1RSQUlOVF9OQU1FXTsgXG4gICAgICAgICAgICBpZiAoZmtJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZrSW5mby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tYmluYXRpb24gZm9yZWlnbiBrZXkgaXMgbm90IHN1cHBvcnRlZDogXCIke3JlZi5DT05TVFJBSU5UX05BTUV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1bmlxdWUgPSBma0luZm9bMF0uTm9uX3VuaXF1ZSA9PT0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGZrQ29sTmFtZSA9IHRoaXMuX2ZpZWxkTmFtaW5nKHJlZi5DT0xVTU5fTkFNRSk7XG5cbiAgICAgICAgICAgIGlmICh1bmlxdWUpIHtcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbnMucHVzaCh7IHR5cGU6ICdiZWxvbmdzVG8nLCBzcmNGaWVsZDogZmtDb2xOYW1lLCBkZXN0RW50aXR5OiB0aGlzLl9lbnRpdHlOYW1pbmcocmVmLlJFRkVSRU5DRURfVEFCTEVfTkFNRSkgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9ucy5wdXNoKHsgdHlwZTogJ2hhc01hbnknLCBzcmNGaWVsZDogZmtDb2xOYW1lLCAgZGVzdEVudGl0eTogdGhpcy5fZW50aXR5TmFtaW5nKHJlZi5SRUZFUkVOQ0VEX1RBQkxFX05BTUUpIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgZmllbGRzW2ZrQ29sTmFtZV07Ly8gPSB7IHR5cGU6ICckYXNzb2NpYXRpb24nLCBjb2RlOiBmaWVsZHNbZmtDb2xOYW1lXS5jb2RlIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNzb2NpYXRpb25zO1xuICAgIH1cblxuICAgIF9wcm9jZXNzSW5kZXhlcyhpbmRleEluZm8pIHtcbiAgICAgICAgbGV0IHBrID0gW10sIGluZGV4ZXMgPSBbXTtcblxuICAgICAgICBsZXQgbWFwTmFtZVRvSW5kZXggPSB7fTtcblxuICAgICAgICBpbmRleEluZm8uZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIFV0aWwucHV0SW50b0J1Y2tldChtYXBOYW1lVG9JbmRleCwgaS5LZXlfbmFtZSwgaSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uZm9yT3duKG1hcE5hbWVUb0luZGV4LCAoZmllbGRzLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ1BSSU1BUlknKSB7XG4gICAgICAgICAgICAgICAgcGsucHVzaChmaWVsZHMubWFwKGYgPT4gdGhpcy5fZmllbGROYW1pbmcoZi5Db2x1bW5fbmFtZSkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzOiBmaWVsZHMubWFwKGYgPT4gdGhpcy5fZmllbGROYW1pbmcoZi5Db2x1bW5fbmFtZSkpLFxuICAgICAgICAgICAgICAgICAgICB1bmlxdWU6IGZpZWxkc1swXS5Ob25fdW5pcXVlID09PSAwLFxuICAgICAgICAgICAgICAgICAgICBudWxsYWJsZTogZmllbGRzWzBdLk51bGwgPT09ICdZRVMnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHBrLCBpbmRleGVzLCBtYXBOYW1lVG9JbmRleCB9O1xuICAgIH1cblxuICAgIF9wcm9jZXNzRmllbGRzKHRhYmxlLCBjb2x1bW5zKSB7XG4gICAgICAgIGxldCBmZWF0dXJlcyA9IFtdLCBmaWVsZHMgPSB7fSwgdHlwZXMgPSB7fTtcblxuICAgICAgICBjb2x1bW5zLmZvckVhY2goY29sID0+IHtcbiAgICAgICAgICAgIGxldCBmaWVsZE5hbWUgPSB0aGlzLl9maWVsZE5hbWluZyhjb2wuQ09MVU1OX05BTUUpO1xuICAgICAgICAgICAgaWYgKGNvbC5FWFRSQSA9PT0gJ2F1dG9faW5jcmVtZW50Jykge1xuICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXV0b0lkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwib3B0aW9uc1wiOiB0YWJsZS5BVVRPX0lOQ1JFTUVOVCA/IHsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhcnRGcm9tXCI6IHRhYmxlLkFVVE9fSU5DUkVNRU5UXG4gICAgICAgICAgICAgICAgICAgIH0gOiB7fVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAnaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVJbmZvLm9wdGlvbnMubmFtZSA9IGZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlSW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sLkNPTFVNTl9ERUZBVUxUID09PSAnQ1VSUkVOVF9USU1FU1RBTVAnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZlYXR1cmVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjcmVhdGVUaW1lc3RhbXBcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlSW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sLkVYVFJBID09PSAnb24gdXBkYXRlIENVUlJFTlRfVElNRVNUQU1QJykge1xuICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidXBkYXRlVGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZUluZm8pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ2lzRGVsZXRlZCcgJiYgY29sLkNPTFVNTl9UWVBFID09PSAndGlueWludCgxKScpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmVhdHVyZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImxvZ2ljYWxEZWxldGlvblwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmVJbmZvKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBmaWVsZEluZm8gPSB0aGlzLl9teXNxbFR5cGVUb09vbFR5cGUodGFibGUsIGNvbCwgZmllbGROYW1lLCB0eXBlcyk7XG5cbiAgICAgICAgICAgIGlmIChjb2wuSVNfTlVMTEFCTEUgPT09ICdZRVMnKSB7XG4gICAgICAgICAgICAgICAgZmllbGRJbmZvLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbC5DT0xVTU5fREVGQVVMVCkge1xuICAgICAgICAgICAgICAgIGZpZWxkSW5mby5kZWZhdWx0ID0gY29sLkNPTFVNTl9ERUZBVUxUO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sLkNPTFVNTl9DT01NRU5UKSB7XG4gICAgICAgICAgICAgICAgZmllbGRJbmZvLmNvbW1lbnQgPSBjb2wuQ09MVU1OX0NPTU1FTlQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gZmllbGRJbmZvO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBmZWF0dXJlcywgZmllbGRzLCB0eXBlcyB9O1xuICAgIH1cblxuICAgIF9maWVsZE5hbWluZyhuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnJldmVyc2VSdWxlcy5maWVsZE5hbWluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZVJ1bGVzLmZpZWxkTmFtaW4obmFtZSk7XG4gICAgICAgIH0gXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gR2VtbFV0aWxzLmZpZWxkTmFtaW5nKG5hbWUpO1xuICAgIH1cblxuICAgIF9lbnRpdHlOYW1pbmcobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5yZXZlcnNlUnVsZXMuZW50aXR5TmFtaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlUnVsZXMuZW50aXR5TmFtaW5nKG5hbWUpO1xuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIEdlbWxVdGlscy5lbnRpdHlOYW1pbmcobmFtZSk7XG4gICAgfVxuXG4gICAgX3NjaGVtYU5hbWluZyhuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnJldmVyc2VSdWxlcy5zY2hlbWFOYW1pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldmVyc2VSdWxlcy5zY2hlbWFOYW1pbmcobmFtZSk7XG4gICAgICAgIH0gXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gR2VtbFV0aWxzLnNjaGVtYU5hbWluZyhuYW1lKTtcbiAgICB9XG5cbiAgICBfbXlzcWxUeXBlVG9Pb2xUeXBlKHRhYmxlLCBjb2wsIGZpZWxkTmFtZSwgdHlwZXMpIHtcbiAgICAgICAgbGV0IGFwcGxpY2FibGVSdWxlID0gXy5maW5kKHRoaXMucmV2ZXJzZVJ1bGVzLmNvbHVtblR5cGVDb252ZXJzaW9uLCBydWxlID0+IHJ1bGUudGVzdCh0YWJsZSwgY29sKSk7XG4gICAgICAgIGlmIChhcHBsaWNhYmxlUnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGxpY2FibGVSdWxlLmFwcGx5KHRhYmxlLCBjb2wpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgdHlwZUluZm8gPSB7fTsgICAgICAgIFxuICAgICAgICBpZiAoY29sLkNPTFVNTl9OQU1FICE9PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHR5cGVJbmZvLmNvZGUgPSBjb2wuQ09MVU1OX05BTUU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNvbC5EQVRBX1RZUEUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3ZhcmNoYXInOlxuICAgICAgICAgICAgICAgIHR5cGVJbmZvLnR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5DSEFSQUNURVJfTUFYSU1VTV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8ubWF4TGVuZ3RoID0gY29sLkNIQVJBQ1RFUl9NQVhJTVVNX0xFTkdUSDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2NoYXInOlxuICAgICAgICAgICAgICAgIHR5cGVJbmZvLnR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5DSEFSQUNURVJfTUFYSU1VTV9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8uZml4ZWRMZW5ndGggPSBjb2wuQ0hBUkFDVEVSX01BWElNVU1fTEVOR1RIO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gJ2ludGVnZXInO1xuICAgICAgICAgICAgICAgIHR5cGVJbmZvLmRpZ2l0cyA9IGNvbC5OVU1FUklDX1BSRUNJU0lPTiB8fCAxODtcbiAgICAgICAgICAgICAgICB0eXBlSW5mby5ieXRlcyA9IDg7XG4gICAgICAgICAgICAgICAgaWYgKF8uZW5kc1dpdGgoY29sLkNPTFVNTl9UWVBFLCAnIHVuc2lnbmVkJykpIHR5cGVJbmZvLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gJ2ludGVnZXInO1xuICAgICAgICAgICAgICAgIHR5cGVJbmZvLmRpZ2l0cyA9IGNvbC5OVU1FUklDX1BSRUNJU0lPTiB8fCAxMDtcbiAgICAgICAgICAgICAgICB0eXBlSW5mby5ieXRlcyA9IDQ7XG4gICAgICAgICAgICAgICAgaWYgKF8uZW5kc1dpdGgoY29sLkNPTFVNTl9UWVBFLCAnIHVuc2lnbmVkJykpIHR5cGVJbmZvLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbWVkaXVtaW50JzpcbiAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gJ2ludGVnZXInO1xuICAgICAgICAgICAgICAgIHR5cGVJbmZvLmRpZ2l0cyA9IGNvbC5OVU1FUklDX1BSRUNJU0lPTiB8fCA3O1xuICAgICAgICAgICAgICAgIHR5cGVJbmZvLmJ5dGVzID0gMztcbiAgICAgICAgICAgICAgICBpZiAoXy5lbmRzV2l0aChjb2wuQ09MVU1OX1RZUEUsICcgdW5zaWduZWQnKSkgdHlwZUluZm8udW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzbWFsbGludCc6XG4gICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZSA9ICdpbnRlZ2VyJztcbiAgICAgICAgICAgICAgICB0eXBlSW5mby5kaWdpdHMgPSBjb2wuTlVNRVJJQ19QUkVDSVNJT04gfHwgNDtcbiAgICAgICAgICAgICAgICB0eXBlSW5mby5ieXRlcyA9IDI7XG4gICAgICAgICAgICAgICAgaWYgKF8uZW5kc1dpdGgoY29sLkNPTFVNTl9UWVBFLCAnIHVuc2lnbmVkJykpIHR5cGVJbmZvLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAndGlueWludCc6XG4gICAgICAgICAgICAgICAgaWYgKF8uc3RhcnRzV2l0aChjb2wuQ09MVU1OX1RZUEUsICd0aW55aW50KDEpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZSA9ICdib29sZWFuJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gJ2ludGVnZXInO1xuICAgICAgICAgICAgICAgICAgICB0eXBlSW5mby5kaWdpdHMgPSBjb2wuTlVNRVJJQ19QUkVDSVNJT04gfHwgMjtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8uYnl0ZXMgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5lbmRzV2l0aChjb2wuQ09MVU1OX1RZUEUsICcgdW5zaWduZWQnKSkgdHlwZUluZm8udW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBjb2wuQ09MVU1OX1RZUEUuaW5kZXhPZignKCcpO1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9IGNvbC5DT0xVTU5fVFlQRS5sYXN0SW5kZXhPZignKScpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHR5cGVOYW1lID0gdGFibGUuVEFCTEVfTkFNRSArIF8udXBwZXJGaXJzdChjb2wuQ09MVU1OX05BTUUpO1xuXG4gICAgICAgICAgICAgICAgdHlwZXNbdHlwZU5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW51bScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogY29sLkNPTFVNTl9UWVBFLnN1YnN0cmluZyhsZWZ0ICsgMSwgcmlnaHQpLnNwbGl0KCcsJykubWFwKHYgPT4gdi5zdWJzdHIoMSwgdi5sZW5ndGggLSAyKSlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZSA9IHR5cGVOYW1lO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgIHR5cGVJbmZvLnR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgICAgICAgdHlwZUluZm8ubWF4TGVuZ3RoID0gY29sLkNIQVJBQ1RFUl9NQVhJTVVNX0xFTkdUSDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICAgICAgY2FzZSAndGltZXN0YW1wJzpcbiAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gJ2RhdGV0aW1lJztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZGVjaW1hbCc6XG4gICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZSA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIHR5cGVJbmZvLnRvdGFsRGlnaXRzID0gY29sLk5VTUVSSUNfUFJFQ0lTSU9OO1xuICAgICAgICAgICAgICAgIHR5cGVJbmZvLmRlY2ltYWxEaWdpdHMgPSBjb2wuTlVNRVJJQ19TQ0FMRTtcbiAgICAgICAgICAgICAgICB0eXBlSW5mby5leGFjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgdHlwZUluZm8udG90YWxEaWdpdHMgPSBjb2wuTlVNRVJJQ19QUkVDSVNJT047XG4gICAgICAgICAgICAgICAgdHlwZUluZm8uZGVjaW1hbERpZ2l0cyA9IGNvbC5OVU1FUklDX1NDQUxFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vXy5maW5kKHRoaXMucmV2ZXJzZVJ1bGVzLmNvbHVtblR5cGVPcHRpbWl6YXRpb24sIHJ1bGUgPT4gcnVsZS50ZXN0KHRhYmxlLCBjb2wpKTtcblxuICAgICAgICByZXR1cm4gdHlwZUluZm87XG4gICAgfVxuXG4gICAgX3JlZmluZUVudGl0eVJlbGF0aW9uc2hpcHMobWFwT2ZFbnRpdGllcykge1xuICAgICAgICBsZXQgZW50aXR5QXNzb2MgPSB7fTtcblxuICAgICAgICAvLzFzdCByb3VuZFxuICAgICAgICBfLmZvck93bihtYXBPZkVudGl0aWVzLCAoeyBlbnRpdHlJbmZvIH0sIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChfLmlzRW1wdHkoZW50aXR5SW5mby5hc3NvY2lhdGlvbnMpKSByZXR1cm47ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGVudGl0eUluZm8uYXNzb2NpYXRpb25zLmZvckVhY2goKHsgdHlwZSwgc3JjRmllbGQsIGRlc3RFbnRpdHkgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZWZlZEVudGl0eSA9IG1hcE9mRW50aXRpZXNbZGVzdEVudGl0eV07XG4gICAgICAgICAgICAgICAgbGV0IGJhY2tSZWYgPSBfLmZpbmQocmVmZWRFbnRpdHkuYXNzb2NpYXRpb25zLCBhc3NvYyA9PiBhc3NvYy5kZXN0RW50aXR5ID09PSBuYW1lKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnaGFzTWFueScpIHsgICBcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhY2tSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb25lLXNpZGUgcmVsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWwucHV0SW50b0J1Y2tldChlbnRpdHlBc3NvYywgbmFtZSwgeyB0eXBlOiAncmVmZXJzVG8nLCBzcmNGaWVsZCwgZGVzdEVudGl0eSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vdG9kbzpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZW50aXR5SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFjayByZWZlcmVuY2U6ICR7YmFja1JlZi5lbnRpdHl9ICR7YmFja1JlZi50eXBlfSAke25hbWV9YCk7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdiZWxvbmdzVG8nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgVXRpbC5wdXRJbnRvQnVja2V0KGVudGl0eUFzc29jLCBuYW1lLCB7IHR5cGUsIHNyY0ZpZWxkLCBkZXN0RW50aXR5IH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFja1JlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9vbmUtc2lkZSByZWxhdGlvbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5wdXRJbnRvQnVja2V0KGVudGl0eUFzc29jLCBlbnRpdHksIHsgdHlwZTogJ2hhc01hbnknLCBkZXN0RW50aXR5OiBuYW1lIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBhc3NvY2lhdGlvbiB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7ICAgICAgICAgICAgXG4gICAgICAgIH0pOyAgICAgICAgXG5cbiAgICAgICAgLy8ybmQgcm91bmRcbiAgICAgICAgXy5mb3JPd24oZW50aXR5QXNzb2MsIChhc3NvY2lhdGlvbnMsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGVudGl0eUluZm8gfSA9IG1hcE9mRW50aXRpZXNbbmFtZV07XG5cbiAgICAgICAgICAgIGxldCBrZXlBc3NvY3M7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVudGl0eUluZm8ua2V5KSAmJiBlbnRpdHlJbmZvLmtleS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBrZXlBc3NvY3MgPSBfLmZpbHRlcihhc3NvY2lhdGlvbnMsIGFzc29jID0+IGVudGl0eUluZm8ua2V5LmluZGV4T2YoYXNzb2Muc3JjRmllbGQpICE9PSAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKGtleUFzc29jcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUVudGl0eU1hbnlUb01hbnkoa2V5QXNzb2NzWzBdLmRlc3RFbnRpdHksIGtleUFzc29jc1sxXS5kZXN0RW50aXR5LCBlbnRpdHlBc3NvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRpdHlJbmZvLmluZGV4ZXMuZm9yRWFjaCgoeyBmaWVsZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleUFzc29jcyA9IF8uZmlsdGVyKGFzc29jaWF0aW9ucywgYXNzb2MgPT4gZmllbGRzLmluZGV4T2YoYXNzb2Muc3JjRmllbGQpICE9PSAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlBc3NvY3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlRW50aXR5TWFueVRvTWFueShrZXlBc3NvY3NbMF0uZGVzdEVudGl0eSwga2V5QXNzb2NzWzFdLmRlc3RFbnRpdHksIGVudGl0eUFzc29jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBfLmZvck93bihtYXBPZkVudGl0aWVzLCAoeyBlbnRpdHlJbmZvIH0sIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGVudGl0eUluZm8uYXNzb2NpYXRpb25zID0gZW50aXR5QXNzb2NbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9tYWtlRW50aXR5TWFueVRvTWFueShlbnRpdHlOYW1lMSwgZW50aXR5TmFtZTIsIGVudGl0eUFzc29jKSB7XG4gICAgICAgIFV0aWwucHV0SW50b0J1Y2tldChlbnRpdHlBc3NvYywgZW50aXR5TmFtZTEsIHsgdHlwZTogJ2hhc01hbnknLCBkZXN0RW50aXR5OiBlbnRpdHlOYW1lMiB9KTtcbiAgICAgICAgVXRpbC5wdXRJbnRvQnVja2V0KGVudGl0eUFzc29jLCBlbnRpdHlOYW1lMiwgeyB0eXBlOiAnaGFzTWFueScsIGRlc3RFbnRpdHk6IGVudGl0eU5hbWUxIH0pO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNeVNRTFJldmVyc2VFbmdpbmVlcmluZzsiXX0=