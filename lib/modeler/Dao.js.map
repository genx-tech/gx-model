{"version":3,"sources":["../../src/modeler/Dao.js"],"names":["path","require","_","naming","text","pushIntoBucket","fs","swig","GemlTypes","JsLang","GemlToAst","Snippets","Types","ChainableType","AST_BLK_VALIDATOR_CALL","AST_BLK_PROCESSOR_CALL","AST_BLK_ACTIVATOR_CALL","getFieldName","t","split","pop","isChainable","current","next","indexOf","type","target","chainCall","lastBlock","lastType","currentBlock","currentType","assert","astBinExp","arguments","asyncMethodNaming","name","indentLines","lines","indentation","map","line","i","repeat","join","OOL_MODIFIER_RETURN","Modifier","VALIDATOR","astThrow","astReturn","PROCESSOR","args","astId","ACTIVATOR","DaoModeler","constructor","context","linker","connector","outputPath","modelPath","manifestPath","modeling_","schema","log","_generateSchemaModel","_generateEntityModel","_generateEnumTypes","_generateEntityInputSchema","_generateEntityManifest","capitalized","pascalCase","locals","driver","className","schemaName","entities","JSON","stringify","Object","keys","classTemplate","resolve","__dirname","classCode","renderFile","modelFilePath","ensureFileSync","writeFileSync","forOwn","types","location","typeInfo","getTypeInfo","ENUM","content","values","val","snakeCase","toUpperCase","entity","entityInstanceName","sharedContext","mapOfFunctorToFile","newFunctorFiles","ast","astClassMain","fieldReferences","_processFieldModifiers","uniqueKeys","castArray","key","indexes","forEach","index","unique","push","fields","modelMeta","keyField","mapValues","f","omit","toJSON","features","baseClasses","isEmpty","associations","fieldDependencies","interfaces","astInterfaces","_buildInterfaces","concat","importLines","fileName","functionName","astToCode","astRequire","each","entry","_generateFunctionTemplateFile","packageName","gemlModule","fromPackage","packagePath","app","settings","geml","dependencies","imports","entityMeta","classBody","block","functors","astValue","reduce","result","functor","inputs","inputSetName","validationSchema","Set","astProgram","input","startsWith","assoc","substr","assocMeta","Error","spec","dep","add","list","elementSchema","astCall","camelCase","pick","field","exportBody","Array","from","astPushInBody","astAssign","astVarRef","astAnonymousFunction","inputSchemaFilePath","diagram","diagramOutputFilePath","compileContext","createCompileContext","variables","source","finalized","allFinished","createTopoId","fieldName","topoId","compileField","dependsOn","writeOnce","freezeAfterNonDefault","reference","writeProtect","deps","topoSort","sort","filter","mapOfTokenToMeta","has","methodBodyValidateAndFill","lastFieldsGroup","methodBodyCache","lastAstType","_mergeDoValidateAndFillCode","references","astCache","requireTargetField","checker","_fieldRequirementCheck","sourceMap","get","astBlock","astMap","targetFieldName","length","fieldReference","ref","whenNull","undefined","nextType","_validateCheck","_checkAndAssign","astMemberMethod","_applyModifiersHeader","functorType","filePath","existsSync","upperFirst","astFunction","modelMetaInit","method","info","astBody","astVarDeclare","paramMeta","accept","_processParams","params","implementation","operation","compileDbOperation","mainStartId","return","compileExceptionalReturn","needDeclare","replaceAll","kebabCase","acceptParams","param","compileParam","module","exports"],"mappings":"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","sourcesContent":["const path = require(\"path\");\nconst { _, naming, text, pushIntoBucket } = require(\"@genx/july\");\nconst { fs } = require(\"@genx/sys\");\nconst swig = require(\"swig-templates\");\n\nconst GemlTypes = require(\"../lang/GemlTypes\");\nconst JsLang = require(\"./util/ast.js\");\nconst GemlToAst = require(\"./util/gemlToAst.js\");\nconst Snippets = require(\"./dao/snippets\");\nconst { Types } = require(\"@genx/data\");\n\nconst ChainableType = [\n    GemlToAst.AST_BLK_VALIDATOR_CALL,\n    GemlToAst.AST_BLK_PROCESSOR_CALL,\n    GemlToAst.AST_BLK_ACTIVATOR_CALL,\n];\n\nconst getFieldName = (t) => t.split(\".\").pop();\nconst isChainable = (current, next) =>\n    ChainableType.indexOf(current.type) > -1 && current.target === next.target && next.type === current.type;\nconst chainCall = (lastBlock, lastType, currentBlock, currentType) => {\n    if (lastBlock) {\n        if (lastType === \"ValidatorCall\") {\n            assert: currentType === \"ValidatorCall\", \"Unexpected currentType\";\n\n            currentBlock = JsLang.astBinExp(lastBlock, \"&&\", currentBlock);\n        } else {\n            assert: currentType === \"ProcessorCall\", \"Unexpected currentType: \" + currentType + \" last: \" + lastType;\n\n            currentBlock.arguments[0] = lastBlock;\n        }\n    }\n\n    return currentBlock;\n};\nconst asyncMethodNaming = (name) => name + \"_\";\n\nconst indentLines = (lines, indentation) =>\n    lines\n        .split(\"\\n\")\n        .map((line, i) => (i === 0 ? line : _.repeat(\" \", indentation) + line))\n        .join(\"\\n\");\n\nconst OOL_MODIFIER_RETURN = {\n    [GemlTypes.Modifier.VALIDATOR]: () => [JsLang.astThrow('Error', ['To be implemented!']), JsLang.astReturn(true)],\n    [GemlTypes.Modifier.PROCESSOR]: (args) => [JsLang.astThrow('Error', ['To be implemented!']), JsLang.astReturn(JsLang.astId(args[0]))],\n    [GemlTypes.Modifier.ACTIVATOR]: () => [JsLang.astThrow('Error', ['To be implemented!']), JsLang.astReturn(JsLang.astId(\"undefined\"))],\n};\n\n/**\n * Geml database access object (DAO) modeler.\n * @class\n */\nclass DaoModeler {\n    /**\n     * @param {object} context\n     * @property {GemlLinker} context.linker - Geml linker\n     * @property {object} context.modelPath - Generated model output path\n     * @property {object} context.manifestPath - Entities manifest output path\n     * @param {Connector} connector\n     */\n    constructor(context, linker, connector) {\n        this.linker = linker;\n        this.outputPath = context.modelPath;\n        this.manifestPath = context.manifestPath;\n\n        this.connector = connector;\n    }\n\n    modeling_(schema) {\n        this.linker.log(\"info\", 'Generating entity models for schema \"' + schema.name + '\"...');\n\n        this._generateSchemaModel(schema);\n        this._generateEntityModel(schema);\n        this._generateEnumTypes(schema);\n        this._generateEntityInputSchema(schema);\n        //\n        //this._generateViewModel();\n\n        if (this.manifestPath) {\n            this._generateEntityManifest(schema);\n        }\n    }\n\n    _generateSchemaModel(schema) {\n        let capitalized = naming.pascalCase(schema.name);\n\n        let locals = {\n            driver: this.connector.driver,\n            className: capitalized,\n            schemaName: schema.name,\n            entities: JSON.stringify(Object.keys(schema.entities)),\n        };\n\n        let classTemplate = path.resolve(__dirname, \"database\", this.connector.driver, \"Database.js.swig\");\n        let classCode = swig.renderFile(classTemplate, locals);\n\n        let modelFilePath = path.resolve(this.outputPath, capitalized + \".js\");\n        fs.ensureFileSync(modelFilePath);\n        fs.writeFileSync(modelFilePath, classCode);\n\n        this.linker.log(\"info\", \"Generated database model: \" + modelFilePath);\n    }\n\n    _generateEnumTypes(schema) {\n        //build types defined outside of entity\n        _.forOwn(schema.types, (location, type) => {\n            const typeInfo = schema.linker.getTypeInfo(type, location);\n            if (typeInfo.type === Types.ENUM.name) {\n                const capitalized = naming.pascalCase(type);\n\n                const content = `module.exports = {\n    ${typeInfo.values\n        .map((val) => `${naming.snakeCase(val).toUpperCase()}: '${val}'`)\n        .join(\",\\n    \")}                    \n};`;\n\n                const modelFilePath = path.resolve(this.outputPath, schema.name, \"types\", capitalized + \".js\");\n                fs.ensureFileSync(modelFilePath);\n                fs.writeFileSync(modelFilePath, content);\n\n                this.linker.log(\"info\", \"Generated enum type definition: \" + modelFilePath);\n            }\n        });\n    }\n\n    _generateEntityModel(schema) {\n        _.forOwn(schema.entities, (entity, entityInstanceName) => {\n            let capitalized = naming.pascalCase(entityInstanceName);\n\n            //shared information with model CRUD and customized interfaces\n            let sharedContext = {\n                mapOfFunctorToFile: {},\n                newFunctorFiles: [],\n            };\n\n            let { ast: astClassMain, fieldReferences } = this._processFieldModifiers(entity, sharedContext);\n            astClassMain = [astClassMain];\n\n            //prepare meta data\n            let uniqueKeys = [_.castArray(entity.key)];\n\n            if (entity.indexes) {\n                entity.indexes.forEach((index) => {\n                    if (index.unique) {\n                        uniqueKeys.push(index.fields);\n                    }\n                });\n            }\n\n            let modelMeta = {\n                schemaName: schema.name,\n                name: entityInstanceName,\n                keyField: entity.key,\n                fields: _.mapValues(entity.fields, (f) => _.omit(f.toJSON(), \"modifiers\")),\n                features: entity.features || {},\n                uniqueKeys,\n            };\n\n            if (entity.baseClasses) {\n                modelMeta.baseClasses = entity.baseClasses;\n            }\n\n            if (!_.isEmpty(entity.indexes)) {\n                modelMeta.indexes = entity.indexes;\n            }\n\n            if (!_.isEmpty(entity.features)) {\n                modelMeta.features = entity.features;\n            }\n\n            if (!_.isEmpty(entity.associations)) {\n                modelMeta.associations = entity.associations;\n            }\n\n            if (!_.isEmpty(fieldReferences)) {\n                modelMeta.fieldDependencies = fieldReferences;\n            }\n\n            //build customized interfaces\n            if (entity.interfaces) {\n                let astInterfaces = this._buildInterfaces(entity, modelMeta, sharedContext);\n                //console.log(astInterfaces);\n                //let astClass = astClassMain[astClassMain.length - 1];\n                //JsLang.astPushInBody(astClass, astInterfaces);\n                astClassMain = astClassMain.concat(astInterfaces);\n            }\n\n            let importLines = [];\n\n            //generate functors if any\n            if (!_.isEmpty(sharedContext.mapOfFunctorToFile)) {\n                _.forOwn(sharedContext.mapOfFunctorToFile, (fileName, functionName) => {\n                    importLines.push(JsLang.astToCode(JsLang.astRequire(functionName, \".\" + fileName)));\n                });\n            }\n\n            if (!_.isEmpty(sharedContext.newFunctorFiles)) {\n                _.each(sharedContext.newFunctorFiles, (entry) => {\n                    this._generateFunctionTemplateFile(schema, entry);\n                });\n            }\n\n            //add package path\n            const packageName = entity.gemlModule.packageName;\n            if (packageName) {                \n                modelMeta.fromPackage = packageName;                \n                modelMeta.packagePath = this.linker.app.settings.geml.dependencies[packageName]; //path.relative(this.linker.dependencies[packageName], this.linker.app.workingPath);\n            }\n\n            let locals = {\n                imports: importLines.join(\"\\n\"),\n                className: capitalized,\n                entityMeta: indentLines(JSON.stringify(modelMeta, null, 4), 4),\n                classBody: indentLines(astClassMain.map((block) => JsLang.astToCode(block)).join(\"\\n\\n\"), 8),\n                functors: indentLines(\n                    JsLang.astToCode(\n                        JsLang.astValue(\n                            _.reduce(\n                                sharedContext.newFunctorFiles,\n                                (result, functor) => {\n                                    result[\"$\" + functor.functionName] = JsLang.astId(functor.functionName);\n                                    return result;\n                                },\n                                {}\n                            )\n                        )\n                    ),\n                    4\n                ),\n                //mixins\n            };\n\n            let classTemplate = path.resolve(__dirname, \"database\", this.connector.driver, \"EntityModel.js.swig\");\n            let classCode = swig.renderFile(classTemplate, locals);\n\n            let modelFilePath = path.resolve(this.outputPath, schema.name, \"base\", capitalized + \".js\");\n            fs.ensureFileSync(modelFilePath);\n            fs.writeFileSync(modelFilePath, classCode);\n\n            this.linker.log(\"info\", \"Generated entity model: \" + modelFilePath);\n        });\n    }\n\n    _generateEntityInputSchema(schema) {\n        //generate validator config\n        _.forOwn(schema.entities, (entity, entityInstanceName) => {\n            _.each(entity.inputs, (inputs, inputSetName) => {\n                const validationSchema = {};\n                const dependencies = new Set();\n                const ast = JsLang.astProgram();\n\n                inputs.forEach((input) => {\n                    //:address\n                    if (input.name.startsWith(\":\")) {\n                        const assoc = input.name.substr(1);\n                        const assocMeta = entity.associations[assoc];\n\n                        if (!assocMeta) {\n                            throw new Error(`Association \"${assoc}\" not found in entity [${entityInstanceName}].`);\n                        }\n\n                        if (!input.spec) {\n                            throw new Error(\n                                `Input \"spec\" is required for entity reference. Input set: ${inputSetName}, entity: ${entityInstanceName}, local: ${assoc}, referencedEntity: ${assocMeta.entity}`\n                            );\n                        }\n\n                        const dep = `${assocMeta.entity}-${input.spec}`;\n                        dependencies.add(dep);\n\n                        if (assocMeta.list) {\n                            validationSchema[input.name] = JsLang.astValue({\n                                type: \"array\",\n                                elementSchema: {\n                                    type: \"object\",\n                                    schema: JsLang.astCall(_.camelCase(dep), []),\n                                },\n                                ..._.pick(input, [\"optional\"]),\n                            });\n                        } else {\n                            validationSchema[input.name] = JsLang.astValue({\n                                type: \"object\",\n                                schema: JsLang.astCall(_.camelCase(dep), []),\n                                ..._.pick(input, [\"optional\"]),\n                            });\n                        }\n                    } else {\n                        const field = entity.fields[input.name];\n\n                        if (!field) {\n                            throw new Error(`Field \"${input.name}\" not found in entity [${entityInstanceName}].`);\n                        }\n\n                        validationSchema[input.name] = JsLang.astValue({\n                            ..._.pick(field, [\"type\", \"values\"]),\n                            ..._.pick(input, [\"optional\"]),\n                        });\n                    }\n                });\n\n                //console.dir(JsLang.astValue(validationSchema), {depth: 20});\n\n                const exportBody = Array.from(dependencies).map((dep) =>\n                    JsLang.astRequire(_.camelCase(dep), `./${dep}`)\n                );\n\n                JsLang.astPushInBody(\n                    ast,\n                    JsLang.astAssign(\n                        JsLang.astVarRef(\"module.exports\"),\n                        JsLang.astAnonymousFunction([], exportBody.concat(JsLang.astReturn(validationSchema)))\n                    )\n                );\n\n                let inputSchemaFilePath = path.resolve(\n                    this.outputPath,\n                    schema.name,\n                    \"inputs\",\n                    entityInstanceName + \"-\" + inputSetName + \".js\"\n                );\n                fs.ensureFileSync(inputSchemaFilePath);\n                fs.writeFileSync(inputSchemaFilePath, JsLang.astToCode(ast));\n\n                this.linker.log(\"info\", \"Generated entity input schema: \" + inputSchemaFilePath);\n            });\n        });\n    }\n\n    _generateEntityManifest(schema) {\n        /*\n        let manifest = {};\n\n        _.each(schema.entities, (entity, entityName) => {\n            if (entity.info.restful) {\n                _.each(entity.info.restful, ({ type, methods }, relativeUri) => {                    \n                    let apiInfo = {\n                        type,\n                        methods: {}                                            \n                    };\n\n                    if (type === 'entity') {\n                        apiInfo.entity = entityName;\n                        apiInfo.displayName = entity.displayName;\n\n                        if (entity.comment) {\n                            apiInfo.description = entity.comment;\n                        }\n                    }\n\n                    _.each(methods, (meta, methodName) => {\n\n                        switch (methodName) {\n                            case 'create':\n                                apiInfo.methods['post:' + relativeUri] = meta;\n                            break;\n\n                            case 'findOne':\n                            break;\n\n                            case 'fineAll':\n                            break;\n\n                            case 'updateOne':\n                            break;\n\n                            case 'updateMany':\n                            break;\n\n                            case 'deleteOne':\n                            break;\n\n                            case 'deleteMany':\n                            break;\n                        }\n\n                    });\n                });\n            }\n        });\n        */\n\n        /*\n        let outputFilePath = path.resolve(this.manifestPath, schema.name + '.manifest.json');\n        fs.ensureFileSync(outputFilePath);\n        fs.writeFileSync(outputFilePath, JSON.stringify(entities, null, 4));\n\n        this.linker.log('info', 'Generated schema manifest: ' + outputFilePath);\n        */\n\n        const diagram = {};\n\n        //generate validator config\n        _.forOwn(schema.entities, (entity, entityInstanceName) => {\n            /*\n            let validationSchema = {};\n\n            _.forOwn(entity.fields, (field, fieldName) => {\n                if (field.readOnly) return;\n\n                let fieldSchema = {\n                    type: field.type,\n                };\n\n                if (field.type === \"enum\") {\n                    fieldSchema.values = field.values;\n                }\n\n                if (field.optional) {\n                    fieldSchema.optional = true;\n                }\n\n                validationSchema[fieldName] = fieldSchema;\n            });\n            */\n\n            diagram[entityInstanceName] = entity.toJSON();\n\n            /*\n            let entityOutputFilePath = path.resolve(\n                this.manifestPath,\n                schema.name,\n                \"validation\",\n                entityInstanceName + \".manifest.json\"\n            );\n            fs.ensureFileSync(entityOutputFilePath);\n            fs.writeFileSync(entityOutputFilePath, JSON.stringify(validationSchema, null, 4));\n\n            this.linker.log(\"info\", \"Generated entity manifest: \" + entityOutputFilePath);\n            */\n        });\n\n        let diagramOutputFilePath = path.resolve(this.manifestPath, schema.name, \"diagram.json\");\n        fs.ensureFileSync(diagramOutputFilePath);\n        fs.writeFileSync(diagramOutputFilePath, JSON.stringify(diagram, null, 4));\n\n        this.linker.log(\"info\", \"Generated schema manifest: \" + diagramOutputFilePath);\n    }\n\n    /*\n    _generateViewModel(schema, dbService) {        \n        _.forOwn(schema.views, (viewInfo, viewName) => {\n            this.linker.info('Building view: ' + viewName);\n\n            let capitalized = _.upperFirst(viewName);\n\n            let ast = JsLang.astProgram();\n\n            JsLang.astPushInBody(ast, JsLang.astRequire('Mowa', 'mowa'));\n            JsLang.astPushInBody(ast, JsLang.astVarDeclare('Util', JsLang.astVarRef('Mowa.Util'), true));\n            JsLang.astPushInBody(ast, JsLang.astVarDeclare('_', JsLang.astVarRef('Util._'), true));\n            JsLang.astPushInBody(ast, JsLang.astRequire('View', 'mowa/lib/oolong/runtime/view'));\n\n            let compileContext = OolToAst.createCompileContext(viewName, dbService.serviceId, this.linker);\n\n            compileContext.modelVars.add(viewInfo.entity);\n\n            let paramMeta;\n\n            if (viewInfo.params) {\n                paramMeta = this._processParams(viewInfo.params, compileContext);\n            }\n\n            let viewMeta = {\n                isList: viewInfo.isList,\n                params: paramMeta\n            };\n\n            let viewBodyTopoId = OolToAst.createTopoId(compileContext, '$view');\n            OolToAst.dependsOn(compileContext, compileContext.mainStartId, viewBodyTopoId);\n\n            let viewModeler = require(path.resolve(__dirname, './dao/view', dbService.dbType + '.js'));\n            compileContext.astMap[viewBodyTopoId] = viewModeler(dbService, viewName, viewInfo);\n            OolToAst.addCodeBlock(compileContext, viewBodyTopoId, {\n                type: OolToAst.AST_BLK_VIEW_OPERATION\n            });\n\n            let returnTopoId = OolToAst.createTopoId(compileContext, '$return:value');\n            OolToAst.dependsOn(compileContext, viewBodyTopoId, returnTopoId);\n            OolToAst.compileReturn(returnTopoId, {\n                \"oolType\": \"ObjectReference\",\n                \"name\": \"viewData\"\n            }, compileContext);\n\n            let deps = compileContext.topoSort.sort();\n            this.linker.verbose('All dependencies:\\n' + JSON.stringify(deps, null, 2));\n\n            deps = deps.filter(dep => compileContext.mapOfTokenToMeta.has(dep));\n            this.linker.verbose('All necessary source code:\\n' + JSON.stringify(deps, null, 2));\n\n            let astDoLoadMain = [\n                JsLang.astVarDeclare('$meta', JsLang.astVarRef('this.meta'), true, false, 'Retrieving the meta data')\n            ];\n\n            _.each(deps, dep => {\n                let astMeta = compileContext.mapOfTokenToMeta.get(dep);\n\n                let astBlock = compileContext.astMap[dep];\n                assert: astBlock, 'Empty ast block';\n\n                if (astMeta.type === 'ModifierCall') {\n                    let fieldName = getFieldName(astMeta.target);\n                    let astCache = JsLang.astAssign(JsLang.astVarRef(astMeta.target), astBlock, `Modifying ${fieldName}`);\n                    astDoLoadMain.push(astCache);\n                    return;\n                }\n\n                astDoLoadMain = astDoLoadMain.concat(_.castArray(compileContext.astMap[dep]));\n            });\n\n            if (!_.isEmpty(compileContext.mapOfFunctorToFile)) {\n                _.forOwn(compileContext.mapOfFunctorToFile, (fileName, functionName) => {\n                    JsLang.astPushInBody(ast, JsLang.astRequire(functionName, '.' + fileName));\n                });\n            }\n\n            if (!_.isEmpty(compileContext.newFunctorFiles)) {\n                _.each(compileContext.newFunctorFiles, entry => {\n                    this._generateFunctionTemplateFile(dbService, entry);\n                });\n            }\n\n            JsLang.astPushInBody(ast, JsLang.astClassDeclare(capitalized, 'View', [\n                JsLang.astMemberMethod('_doLoad', Object.keys(paramMeta),\n                    astDoLoadMain,\n                    false, true, false, 'Populate view data'\n                )\n            ], `${capitalized} view`));\n            JsLang.astPushInBody(ast, JsLang.astAssign(capitalized + '.meta', JsLang.astValue(viewMeta)));\n            JsLang.astPushInBody(ast, JsLang.astAssign('module.exports', JsLang.astVarRef(capitalized)));\n\n            let modelFilePath = path.resolve(this.outputPath, dbService.dbType, dbService.name, 'views', viewName + '.js');\n            fs.ensureFileSync(modelFilePath);\n            fs.writeFileSync(modelFilePath + '.json', JSON.stringify(ast, null, 2));\n\n            DaoModeler._exportSourceCode(ast, modelFilePath);\n\n            this.linker.log('info', 'Generated view model: ' + modelFilePath);\n        });\n    };\n    */\n\n    _processFieldModifiers(entity, sharedContext) {\n        let compileContext = GemlToAst.createCompileContext(entity.gemlModule.name, this.linker, sharedContext);\n        compileContext.variables[\"raw\"] = { source: \"context\", finalized: true };\n        compileContext.variables[\"i18n\"] = { source: \"context\", finalized: true };\n        compileContext.variables[\"connector\"] = { source: \"context\", finalized: true };\n        compileContext.variables[\"latest\"] = { source: \"context\" };\n\n        const allFinished = GemlToAst.createTopoId(compileContext, \"done.\");\n\n        //map of field name to dependencies\n        let fieldReferences = {};\n\n        _.forOwn(entity.fields, (field, fieldName) => {\n            let topoId = GemlToAst.compileField(fieldName, field, compileContext);\n            GemlToAst.dependsOn(compileContext, topoId, allFinished);\n\n            if (field.writeOnce || field.freezeAfterNonDefault) {\n                pushIntoBucket(fieldReferences, fieldName, { reference: fieldName, writeProtect: true });\n            }\n        });\n\n        let deps = compileContext.topoSort.sort();\n        //this.linker.verbose('All dependencies:\\n' + JSON.stringify(deps, null, 2));\n\n        deps = deps.filter((dep) => compileContext.mapOfTokenToMeta.has(dep));\n        //this.linker.verbose('All necessary source code:\\n' + JSON.stringify(deps, null, 2));\n\n        let methodBodyValidateAndFill = [],\n            lastFieldsGroup,\n            methodBodyCache = [],\n            lastBlock,\n            lastAstType; //, hasValidator = false;\n\n        const _mergeDoValidateAndFillCode = function (fieldName, references, astCache, requireTargetField) {\n            let fields = [fieldName].concat(references);\n            let checker = fields.join(\",\");\n\n            if (lastFieldsGroup && lastFieldsGroup.checker !== checker) {\n                methodBodyValidateAndFill = methodBodyValidateAndFill.concat(\n                    Snippets._fieldRequirementCheck(\n                        lastFieldsGroup.fieldName,\n                        lastFieldsGroup.references,\n                        methodBodyCache,\n                        lastFieldsGroup.requireTargetField\n                    )\n                );\n                methodBodyCache = [];\n            }\n\n            methodBodyCache = methodBodyCache.concat(astCache);\n            lastFieldsGroup = {\n                fieldName,\n                references,\n                requireTargetField,\n                checker,\n            };\n        };\n\n        //console.dir(compileContext.astMap['mobile~isMobilePhone:arg[1]|>stringDasherize'], { depth: 8 });\n\n        _.each(deps, (dep, i) => {\n            //get metadata of source code block\n            let sourceMap = compileContext.mapOfTokenToMeta.get(dep);\n\n            //get source code block\n            let astBlock = compileContext.astMap[dep];\n\n            let targetFieldName = getFieldName(sourceMap.target);\n\n            if (sourceMap.references && sourceMap.references.length > 0) {\n                let fieldReference = fieldReferences[targetFieldName];\n                if (!fieldReference) {\n                    fieldReferences[targetFieldName] = fieldReference = [];\n                }\n\n                if (sourceMap.type === GemlToAst.AST_BLK_ACTIVATOR_CALL) {\n                    sourceMap.references.forEach((ref) => {\n                        fieldReference.push({ reference: ref, whenNull: true });\n                    });\n                } else {\n                    sourceMap.references.forEach((ref) => {\n                        if (fieldReference.indexOf(ref) === -1) fieldReference.push(ref);\n                    });\n                }\n            }\n\n            if (lastBlock) {\n                astBlock = chainCall(lastBlock, lastAstType, astBlock, sourceMap.type);\n                lastBlock = undefined;\n            }\n\n            if (i < deps.length - 1) {\n                let nextType = compileContext.mapOfTokenToMeta.get(deps[i + 1]);\n\n                if (isChainable(sourceMap, nextType)) {\n                    lastBlock = astBlock;\n                    lastAstType = sourceMap.type;\n                    return;\n                }\n            }\n\n            if (sourceMap.type === GemlToAst.AST_BLK_VALIDATOR_CALL) {\n                //hasValidator = true;\n                let astCache = Snippets._validateCheck(targetFieldName, astBlock);\n\n                _mergeDoValidateAndFillCode(targetFieldName, sourceMap.references, astCache, true);\n            } else if (sourceMap.type === GemlToAst.AST_BLK_PROCESSOR_CALL) {\n                let astCache = JsLang.astAssign(\n                    JsLang.astVarRef(sourceMap.target, true),\n                    astBlock,\n                    `Processing \"${targetFieldName}\"`\n                );\n\n                _mergeDoValidateAndFillCode(targetFieldName, sourceMap.references, astCache, true);\n            } else if (sourceMap.type === GemlToAst.AST_BLK_ACTIVATOR_CALL) {\n                let astCache = Snippets._checkAndAssign(\n                    astBlock,\n                    JsLang.astVarRef(sourceMap.target, true),\n                    `Activating \"${targetFieldName}\"`\n                );\n\n                _mergeDoValidateAndFillCode(targetFieldName, sourceMap.references, astCache, false);\n            } else {\n                throw new Error(\"To be implemented.\");\n                //astBlock = _.castArray(astBlock);\n                //_mergeDoValidateAndFillCode(targetFieldName, [], astBlock);\n            }\n        });\n\n        /* Changed to throw error instead of returning a error object\n        if (hasValidator) {\n            let declare = JsLang.astVarDeclare(validStateName, false);\n            methodBodyCreate.unshift(declare);\n            methodBodyUpdate.unshift(declare);\n        }\n        */\n\n        if (!_.isEmpty(methodBodyCache)) {\n            methodBodyValidateAndFill = methodBodyValidateAndFill.concat(\n                Snippets._fieldRequirementCheck(\n                    lastFieldsGroup.fieldName,\n                    lastFieldsGroup.references,\n                    methodBodyCache,\n                    lastFieldsGroup.requireTargetField\n                )\n            );\n        }\n\n        /*\n        let ast = JsLang.astProgram(false);\n        JsLang.astPushInBody(ast, JsLang.astClassDeclare('Abc', 'Model', [\n            JsLang.astMemberMethod(asyncMethodNaming('prepareEntityData_'), [ 'context' ],\n            Snippets._doValidateAndFillHeader.concat(methodBodyValidateAndFill).concat([ JsLang.astReturn(JsLang.astId('context')) ]),\n            false, true, true\n        )], 'comment'));\n        */\n\n        return {\n            ast: JsLang.astMemberMethod(\n                asyncMethodNaming(\"applyModifiers\"),\n                [\"context\", \"isUpdating\"],\n                Snippets._applyModifiersHeader\n                    .concat(methodBodyValidateAndFill)\n                    .concat([JsLang.astReturn(JsLang.astId(\"context\"))]),\n                false,\n                true,\n                true,\n                \"Applying predefined modifiers to entity fields.\"\n            ),\n            fieldReferences,\n        };\n    }\n\n    _generateFunctionTemplateFile(schema, { functionName, functorType, fileName, args }) {\n        let filePath = path.resolve(this.outputPath, schema.name, fileName);\n\n        if (fs.existsSync(filePath)) {\n            //todo: analyse code, compare arguments\n            this.linker.log(\"info\", `${_.upperFirst(functorType)} \"${fileName}\" exists. File generating skipped.`);\n\n            return;\n        }\n\n        let ast = JsLang.astProgram();\n\n        JsLang.astPushInBody(ast, JsLang.astFunction(functionName, args, OOL_MODIFIER_RETURN[functorType](args)));\n        JsLang.astPushInBody(ast, JsLang.astAssign(\"module.exports\", JsLang.astVarRef(functionName)));\n\n        fs.ensureFileSync(filePath);\n        fs.writeFileSync(filePath, JsLang.astToCode(ast));\n        this.linker.log(\"info\", `Generated ${functorType} file: ${filePath}`);\n    }\n\n    _buildInterfaces(entity, modelMetaInit, sharedContext) {\n        let ast = [];\n\n        _.forOwn(entity.interfaces, (method, name) => {\n            this.linker.info(\"Building interface: \" + name);\n\n            let astBody = [\n                JsLang.astVarDeclare(\n                    \"$meta\",\n                    JsLang.astVarRef(\"this.meta.interfaces.\" + name),\n                    true,\n                    false,\n                    \"Retrieving the meta data\"\n                ),\n            ];\n\n            let compileContext = GemlToAst.createCompileContext(entity.gemlModule.name, this.linker, sharedContext);\n\n            let paramMeta;\n\n            if (method.accept) {\n                paramMeta = this._processParams(method.accept, compileContext);\n            }\n\n            //metadata\n            modelMetaInit[\"interfaces\"] || (modelMetaInit[\"interfaces\"] = {});\n            modelMetaInit[\"interfaces\"][name] = { params: Object.values(paramMeta) };\n\n            _.each(method.implementation, (operation, index) => {\n                //let lastTopoId =\n                GemlToAst.compileDbOperation(index, operation, compileContext, compileContext.mainStartId);\n            });\n\n            if (method.return) {\n                GemlToAst.compileExceptionalReturn(method.return, compileContext);\n            }\n\n            let deps = compileContext.topoSort.sort();\n            //this.linker.verbose('All dependencies:\\n' + JSON.stringify(deps, null, 2));\n\n            deps = deps.filter((dep) => compileContext.mapOfTokenToMeta.has(dep));\n            //this.linker.verbose('All necessary source code:\\n' + JSON.stringify(deps, null, 2));\n\n            _.each(deps, (dep) => {\n                let sourceMap = compileContext.mapOfTokenToMeta.get(dep);\n                let astBlock = compileContext.astMap[dep];\n\n                //this.linker.verbose('Code point \"' + dep + '\":\\n' + JSON.stringify(sourceMap, null, 2));\n\n                let targetFieldName = sourceMap.target; //getFieldName(sourceMap.target);\n\n                if (sourceMap.type === GemlToAst.AST_BLK_VALIDATOR_CALL) {\n                    astBlock = Snippets._validateCheck(targetFieldName, astBlock);\n                } else if (sourceMap.type === GemlToAst.AST_BLK_PROCESSOR_CALL) {\n                    if (sourceMap.needDeclare) {\n                        astBlock = JsLang.astVarDeclare(\n                            JsLang.astVarRef(sourceMap.target),\n                            astBlock,\n                            false,\n                            false,\n                            `Processing \"${targetFieldName}\"`\n                        );\n                    } else {\n                        astBlock = JsLang.astAssign(\n                            JsLang.astVarRef(sourceMap.target, true),\n                            astBlock,\n                            `Processing \"${targetFieldName}\"`\n                        );\n                    }\n                } else if (sourceMap.type === GemlToAst.AST_BLK_ACTIVATOR_CALL) {\n                    if (sourceMap.needDeclare) {\n                        astBlock = JsLang.astVarDeclare(\n                            JsLang.astVarRef(sourceMap.target),\n                            astBlock,\n                            false,\n                            false,\n                            `Processing \"${targetFieldName}\"`\n                        );\n                    } else {\n                        astBlock = JsLang.astAssign(\n                            JsLang.astVarRef(sourceMap.target, true),\n                            astBlock,\n                            `Activating \"${targetFieldName}\"`\n                        );\n                    }\n                }\n\n                astBody = astBody.concat(_.castArray(astBlock));\n            });\n\n            ast.push(\n                JsLang.astMemberMethod(\n                    asyncMethodNaming(name),\n                    Object.keys(paramMeta),\n                    astBody,\n                    false,\n                    true,\n                    true,\n                    text.replaceAll(_.kebabCase(name), \"-\", \" \")\n                )\n            );\n        });\n\n        return ast;\n    }\n\n    _processParams(acceptParams, compileContext) {\n        let paramMeta = {};\n\n        acceptParams.forEach((param, i) => {\n            GemlToAst.compileParam(i, param, compileContext);\n            paramMeta[param.name] = param;\n            compileContext.variables[param.name] = { source: \"argument\" };\n        });\n\n        return paramMeta;\n    }\n}\n\nmodule.exports = DaoModeler;\n"],"file":"Dao.js"}