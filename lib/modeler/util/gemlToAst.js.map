{"version":3,"file":"gemlToAst.js","names":["_","require","TopoSort","JsLang","GemlTypes","isDotSeparateName","extractDotSeparateName","extractReferenceBaseName","Types","Validators","Processors","Activators","defaultError","AST_BLK_FIELD_PRE_PROCESS","AST_BLK_PARAM_SANITIZE","AST_BLK_PROCESSOR_CALL","AST_BLK_VALIDATOR_CALL","AST_BLK_ACTIVATOR_CALL","AST_BLK_VIEW_OPERATION","AST_BLK_VIEW_RETURN","AST_BLK_INTERFACE_OPERATION","AST_BLK_INTERFACE_RETURN","AST_BLK_EXCEPTION_ITEM","OOL_MODIFIER_CODE_FLAG","Modifier","VALIDATOR","PROCESSOR","ACTIVATOR","OOL_MODIFIER_OP","OOL_MODIFIER_PATH","OOL_MODIFIER_BUILTIN","OPERATOR_TOKEN","compileConditionalExpression","test","compileContext","startTopoId","isPlainObject","oolType","endTopoId","createTopoId","operandTopoId","dependsOn","lastOperandTopoId","compileConcreteValueExpression","caller","astArgument","getCodeRepresentationOf","retTopoId","compileAdHocValidator","callee","assert","op","operator","Error","leftTopoId","rightTopoId","lastLeftId","left","lastRightId","right","astMap","astBinExp","argument","astNot","astCall","valueStartTopoId","astValue","topoId","value","functor","callArgs","args","translateArgs","arg0","name","concat","compileModifier","declareParams","translateFunctionParams","moduleName","isEmpty","functorId","translateModifier","references","extractReferencedFields","find","ref","astAwait","astVarRef","isTopLevelBlock","startsWith","astConditional","replaceVarRefScope","targetVarName","needDeclare","variables","counter","toString","hasOwnProperty","type","source","addCodeBlock","target","oolArgs","castArray","refs","forEach","a","Array","isArray","result","checkReferenceToField","push","obj","undefined","addModifierToMap","functorType","functorJsFile","mapOfFunctorToFile","functionName","fileName","names","length","refEntityName","upperFirst","builtins","newFunctorFiles","compilePipedValue","varOol","lastTopoId","modifiers","modifier","modifierStartTopoId","compileVariableReference","pre","Set","translateFunctionParam","arg","i","pop","map","baseName","count","has","add","refBase","rest","dependency","ongoing","refFieldName","oorType","translateSymbolToken","mapValues","valueOfElement","key","sid","eid","index","each","argTopoId","compileParam","param","typeObject","sanitizerName","toUpperCase","varRef","callAst","astArrayAccess","prepareTopoId","astAssign","mainStartId","wrapParamReference","readyTopoId","compileField","paramName","contextName","Object","assign","hasModelField","operand","baseVar","split","translateReturnThenAst","startId","endId","then","astThrow","errorType","message","translateReturnValueAst","valueEndId","astReturn","translateThenAst","assignTo","condition","startRightId","valueTopoId","compileReturn","compileFindOne","operation","conditionVarName","ast","astVarDeclare","model","topoIdPrefix","lastStatement","else","elseStart","elseEnd","items","reverse","item","casePrefix","caseTopoId","caseResultVarName","astCaseTtem","ifStart","ifEnd","astIf","astBlock","modelTopoId","compileDbOperation","doBlock","do","compileDoStatement","compileExceptionalReturn","oolNode","lastExceptionId","exceptions","exceptionStartId","exceptionEndId","thenStartId","returnStartTopoId","topoNodes","topoSort","hasDependency","previousOp","currentOp","linker","log","blockMeta","mapOfTokenToMeta","set","lastSourceType","get","object","property","createCompileContext","sharedContext","Map","modelVars","indexOf","targetScope","parts","splice","join","module","exports"],"sources":["../../../src/modeler/util/gemlToAst.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @module\n * @ignore\n */\n\nconst { _ } = require('@genx/july');\nconst { TopoSort } = require('@genx/algorithm');\n\nconst JsLang = require('./ast.js');\nconst GemlTypes = require('../../lang/GemlTypes');\nconst { isDotSeparateName, extractDotSeparateName, extractReferenceBaseName } = require('../../lang/GemlUtils');\nconst { Types, Validators, Processors, Activators } = require('@genx/data');\n\nconst defaultError = 'InvalidRequest';\n\nconst AST_BLK_FIELD_PRE_PROCESS = 'FieldPreProcess';\nconst AST_BLK_PARAM_SANITIZE = 'ParameterSanitize';\nconst AST_BLK_PROCESSOR_CALL = 'ProcessorCall';\nconst AST_BLK_VALIDATOR_CALL = 'ValidatorCall';\nconst AST_BLK_ACTIVATOR_CALL = 'ActivatorCall';\nconst AST_BLK_VIEW_OPERATION = 'ViewOperation';\nconst AST_BLK_VIEW_RETURN = 'ViewReturn';\nconst AST_BLK_INTERFACE_OPERATION = 'InterfaceOperation';\nconst AST_BLK_INTERFACE_RETURN = 'InterfaceReturn';\nconst AST_BLK_EXCEPTION_ITEM = 'ExceptionItem';\n\nconst OOL_MODIFIER_CODE_FLAG = {\n    [GemlTypes.Modifier.VALIDATOR]: AST_BLK_VALIDATOR_CALL,\n    [GemlTypes.Modifier.PROCESSOR]: AST_BLK_PROCESSOR_CALL,\n    [GemlTypes.Modifier.ACTIVATOR]: AST_BLK_ACTIVATOR_CALL\n};\n\nconst OOL_MODIFIER_OP = {\n    [GemlTypes.Modifier.VALIDATOR]: '|~',\n    [GemlTypes.Modifier.PROCESSOR]: '|>',\n    [GemlTypes.Modifier.ACTIVATOR]: '|=' \n};\n\nconst OOL_MODIFIER_PATH = {\n    [GemlTypes.Modifier.VALIDATOR]: 'validators',\n    [GemlTypes.Modifier.PROCESSOR]: 'processors',\n    [GemlTypes.Modifier.ACTIVATOR]: 'activators' \n};\n\nconst OOL_MODIFIER_BUILTIN = {\n    [GemlTypes.Modifier.VALIDATOR]: Validators,\n    [GemlTypes.Modifier.PROCESSOR]: Processors,\n    [GemlTypes.Modifier.ACTIVATOR]: Activators \n};\n\nconst OPERATOR_TOKEN = {\n    \">\": \"$gt\",\n    \"<\": \"$lt\",\n    \">=\": \"$gte\",\n    \"<=\": \"$lte\",\n    \"==\": \"$eq\",\n    \"!=\": \"$ne\",\n    \"in\": \"$in\",\n    \"notIn\": \"$nin\"\n};\n\n/**\n * Compile a conditional expression\n * @param {object} test\n * @param {object} compileContext\n * @property {string} compileContext.moduleName\n * @property {TopoSort} compileContext.topoSort\n * @property {object} compileContext.astMap - Topo Id to ast map\n * @param {string} startTopoId\n * @returns {string} Topo Id\n */\nfunction compileConditionalExpression(test, compileContext, startTopoId) {\n    if (_.isPlainObject(test)) {        \n        if (test.oolType === 'ValidateExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$valiOp:done');\n            let operandTopoId = createTopoId(compileContext, startTopoId + '$valiOp');\n\n            dependsOn(compileContext, startTopoId, operandTopoId);\n\n            let lastOperandTopoId = compileConcreteValueExpression(operandTopoId, test.caller, compileContext);\n            dependsOn(compileContext, lastOperandTopoId, endTopoId);\n\n            let astArgument = getCodeRepresentationOf(lastOperandTopoId, compileContext);\n\n            let retTopoId = compileAdHocValidator(endTopoId, astArgument, test.callee, compileContext);\n\n            assert: retTopoId === endTopoId;\n\n            /*\n            compileContext.astMap[endTopoId] = JsLang.astCall('_.isEmpty', astArgument);\n\n            switch (test.operator) {\n                case 'exists':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isEmpty', astArgument));\n                    break;\n\n                case 'is-not-null':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isNil', astArgument));\n                    break;\n\n                case 'not-exists':\n                    \n                    break;\n\n                case 'is-null':\n                    compileContext.astMap[endTopoId] = JsLang.astCall('_.isNil', astArgument);\n                    break;\n\n                case 'not':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(astArgument);\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n            */\n\n            return endTopoId;\n\n        } else if (test.oolType === 'LogicalExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$lopOp:done');\n\n            let op;\n\n            switch (test.operator) {\n                case 'and':\n                    op = '&&';\n                    break;\n\n                case 'or':\n                    op = '||';\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n\n            let leftTopoId = createTopoId(compileContext, startTopoId + '$lopOp:left');\n            let rightTopoId = createTopoId(compileContext, startTopoId + '$lopOp:right');\n\n            dependsOn(compileContext, startTopoId, leftTopoId);\n            dependsOn(compileContext, startTopoId, rightTopoId);\n\n            let lastLeftId = compileConditionalExpression(test.left, compileContext, leftTopoId);\n            let lastRightId = compileConditionalExpression(test.right, compileContext, rightTopoId);\n\n            dependsOn(compileContext, lastLeftId, endTopoId);\n            dependsOn(compileContext, lastRightId, endTopoId);\n\n            compileContext.astMap[endTopoId] = JsLang.astBinExp(\n                getCodeRepresentationOf(lastLeftId, compileContext),\n                op,\n                getCodeRepresentationOf(lastRightId, compileContext)\n            ); \n\n            return endTopoId;\n\n        } else if (test.oolType === 'BinaryExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$binOp:done');\n\n            let op;\n\n            switch (test.operator) {\n                case '>':\n                case '<':\n                case '>=':\n                case '<=':\n                case 'in':\n                    op = test.operator;\n                    break;\n\n                case '==':\n                    op = '===';\n                    break;\n\n                case '!=':\n                    op = '!==';\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n\n            let leftTopoId = createTopoId(compileContext, startTopoId + '$binOp:left');\n            let rightTopoId = createTopoId(compileContext, startTopoId + '$binOp:right');\n\n            dependsOn(compileContext, startTopoId, leftTopoId);\n            dependsOn(compileContext, startTopoId, rightTopoId);\n\n            let lastLeftId = compileConcreteValueExpression(leftTopoId, test.left, compileContext);\n            let lastRightId = compileConcreteValueExpression(rightTopoId, test.right, compileContext);\n\n            dependsOn(compileContext, lastLeftId, endTopoId);\n            dependsOn(compileContext, lastRightId, endTopoId);\n\n            compileContext.astMap[endTopoId] = JsLang.astBinExp(\n                getCodeRepresentationOf(lastLeftId, compileContext),\n                op,\n                getCodeRepresentationOf(lastRightId, compileContext)\n            ); \n\n            return endTopoId;\n\n        } else if (test.oolType === 'UnaryExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$unaOp:done');\n            let operandTopoId = createTopoId(compileContext, startTopoId + '$unaOp');\n\n            dependsOn(compileContext, startTopoId, operandTopoId);\n\n            let lastOperandTopoId = test.operator === 'not' ? compileConcreteValueExpression(operandTopoId, test.argument, compileContext) : compileConditionalExpression(test.argument, compileContext, operandTopoId);\n            dependsOn(compileContext, lastOperandTopoId, endTopoId);\n\n            let astArgument = getCodeRepresentationOf(lastOperandTopoId, compileContext);\n\n            switch (test.operator) {\n                case 'exists':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isEmpty', astArgument));\n                    break;\n\n                case 'is-not-null':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isNil', astArgument));\n                    break;\n\n                case 'not-exists':\n                    compileContext.astMap[endTopoId] = JsLang.astCall('_.isEmpty', astArgument);\n                    break;\n\n                case 'is-null':\n                    compileContext.astMap[endTopoId] = JsLang.astCall('_.isNil', astArgument);\n                    break;\n\n                case 'not':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(astArgument);\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n\n            return endTopoId;\n\n        } else {\n            let valueStartTopoId = createTopoId(compileContext, startTopoId + '$value');\n            dependsOn(compileContext, startTopoId, valueStartTopoId);\n            return compileConcreteValueExpression(valueStartTopoId, test, compileContext);\n        } \n    }\n\n    compileContext.astMap[startTopoId] = JsLang.astValue(test);\n    return startTopoId;\n}\n\n/**\n * Compile a validator called in a logical expression.\n * @param value\n * @param functors\n * @param compileContext\n * @param topoInfo\n * @property {string} topoInfo.topoIdPrefix\n * @property {string} topoInfo.lastTopoId\n * @returns {*|string}\n */\nfunction compileAdHocValidator(topoId, value, functor, compileContext) {\n    assert: functor.oolType === GemlTypes.Modifier.VALIDATOR;        \n\n    let callArgs;\n    \n    if (functor.args) {\n        callArgs = translateArgs(topoId, functor.args, compileContext);        \n    } else {\n        callArgs = [];\n    }            \n    \n    let arg0 = value;\n    \n    compileContext.astMap[topoId] = JsLang.astCall('Validators.' + functor.name, [ arg0 ].concat(callArgs));\n\n    return topoId;\n}\n\n/**\n * Compile a modifier from ool to ast.\n * @param topoId - startTopoId\n * @param value\n * @param functors\n * @param compileContext\n * @param topoInfo\n * @property {string} topoInfo.topoIdPrefix\n * @property {string} topoInfo.lastTopoId\n * @returns {*|string}\n */\nfunction compileModifier(topoId, value, functor, compileContext) {\n    let declareParams;\n\n    if (functor.oolType === GemlTypes.Modifier.ACTIVATOR) { \n        declareParams = translateFunctionParams([{name: compileContext.moduleName}, {name: 'context'}].concat(functor.args));        \n    } else {\n        declareParams = translateFunctionParams(_.isEmpty(functor.args) ? [value] : [value].concat(functor.args));        \n    }        \n\n    let functorId = translateModifier(functor, compileContext, declareParams);\n\n    let callArgs, references;\n    \n    if (functor.args) {\n        callArgs = translateArgs(topoId, functor.args, compileContext);\n        references = extractReferencedFields(functor.args);\n\n        if (_.find(references, ref => ref === value.name)) {\n            throw new Error('Cannot use the target field itself as an argument of a modifier.');\n        }\n    } else {\n        callArgs = [];\n    }        \n    \n    if (functor.oolType === GemlTypes.Modifier.ACTIVATOR) {            \n        compileContext.astMap[topoId] = JsLang.astAwait(functorId, [ JsLang.astVarRef('this'), JsLang.astVarRef('context') ].concat(callArgs));\n    } else {\n        let arg0 = value;\n        if (!isTopLevelBlock(topoId) && _.isPlainObject(value) && value.oolType === 'ObjectReference' && value.name.startsWith('latest.')) {\n            //let existingRef =            \n            arg0 = JsLang.astConditional(\n                JsLang.astCall('latest.hasOwnProperty', [ extractReferenceBaseName(value.name) ]), /** test */\n                value, /** consequent */\n                replaceVarRefScope(value, 'existing')\n            );  \n        }\n        compileContext.astMap[topoId] = JsLang.astCall(functorId, [ arg0 ].concat(callArgs));\n    }    \n\n    if (isTopLevelBlock(topoId)) {\n        let targetVarName = value.name;\n        let needDeclare = false;\n\n        if (!isDotSeparateName(value.name) && compileContext.variables[value.name] && functor.oolType !== GemlTypes.Modifier.VALIDATOR) {\n            //conflict with existing variables, need to rename to another variable\n            let counter = 1;\n            do {\n                counter++;       \n                targetVarName = value.name + counter.toString();         \n            } while (compileContext.variables.hasOwnProperty(targetVarName));            \n\n            compileContext.variables[targetVarName] = { type: 'localVariable', source: 'modifier' };\n            needDeclare = true;\n        }\n\n        //if (compileContext.variables[])\n\n        addCodeBlock(compileContext, topoId, {\n            type: OOL_MODIFIER_CODE_FLAG[functor.oolType],\n            target: targetVarName,\n            references,   // latest., exsiting., raw.\n            needDeclare\n        });\n    }\n\n    return topoId;\n}  \n      \nfunction extractReferencedFields(oolArgs) {   \n    oolArgs = _.castArray(oolArgs);    \n\n    let refs = [];\n\n    oolArgs.forEach(a => {\n        if (Array.isArray(a)) {\n            refs = refs.concat(extractReferencedFields(a));\n            return;\n        } \n\n        let result = checkReferenceToField(a);\n        if (result) {\n            refs.push(result);\n        }\n    });\n\n    return refs;\n}\n\nfunction checkReferenceToField(obj) {\n    if (_.isPlainObject(obj) && obj.oolType) {\n        if (obj.oolType === 'PipedValue') return checkReferenceToField(obj.value);\n        if (obj.oolType === 'ObjectReference') {\n            return obj.name;\n        }\n    }\n\n    return undefined;\n}\n\nfunction addModifierToMap(functorId, functorType, functorJsFile, mapOfFunctorToFile) {\n    if (mapOfFunctorToFile[functorId] && mapOfFunctorToFile[functorId] !== functorJsFile) {\n        throw new Error(`Conflict: ${functorType} naming \"${functorId}\" conflicts!`);\n    }\n    mapOfFunctorToFile[functorId] = functorJsFile;\n}\n\n/**\n * Check whether a functor is user-defined or built-in\n * @param functor\n * @param compileContext\n * @param args - Used to make up the function signature\n * @returns {string} functor id\n */\nfunction translateModifier(functor, compileContext, args) {\n    let functionName, fileName, functorId;\n\n    //extract validator naming and import information\n    if (isDotSeparateName(functor.name)) {\n        let names = extractDotSeparateName(functor.name);\n        if (names.length > 2) {\n            throw new Error('Not supported reference type: ' + functor.name);\n        }\n\n        //reference to other entity file\n        let refEntityName = names[0];\n        functionName = names[1];\n        fileName = './' + OOL_MODIFIER_PATH[functor.oolType] + '/' + refEntityName + '-' + functionName + '.js';\n        functorId = refEntityName + _.upperFirst(functionName);\n        addModifierToMap(functorId, functor.oolType, fileName, compileContext.mapOfFunctorToFile);\n\n    } else {\n        functionName = functor.name;\n\n        let builtins = OOL_MODIFIER_BUILTIN[functor.oolType];\n\n        if (!(functionName in builtins)) {\n            fileName = './' + OOL_MODIFIER_PATH[functor.oolType] + '/' + compileContext.moduleName + '-' + functionName + '.js';\n            functorId = functionName;\n\n            if (!compileContext.mapOfFunctorToFile[functorId]) {\n                compileContext.newFunctorFiles.push({\n                    functionName,\n                    functorType: functor.oolType,\n                    fileName,\n                    args\n                });\n            }\n\n            addModifierToMap(functorId, functor.oolType, fileName, compileContext.mapOfFunctorToFile);            \n        } else {            \n            functorId = functor.oolType + 's.' + functionName;\n        }\n    }\n\n    return functorId;\n}\n\n/**\n * Compile a piped value from ool to ast.\n * @param {string} startTopoId - The topological id of the starting process to the target value, default as the param name\n * @param {object} varOol - Target value ool node.\n * @param {object} compileContext - Compilation context.\n * @property {string} compileContext.moduleName\n * @property {TopoSort} compileContext.topoSort\n * @property {object} compileContext.astMap - Topo Id to ast map\n * @returns {string} Last topo Id\n */\nfunction compilePipedValue(startTopoId, varOol, compileContext) {\n    let lastTopoId = compileConcreteValueExpression(startTopoId, varOol.value, compileContext);\n\n    varOol.modifiers.forEach(modifier => {\n        let modifierStartTopoId = createTopoId(compileContext, startTopoId + OOL_MODIFIER_OP[modifier.oolType] + modifier.name);\n        dependsOn(compileContext, lastTopoId, modifierStartTopoId);\n\n        lastTopoId = compileModifier(\n            modifierStartTopoId,\n            varOol.value,\n            modifier,\n            compileContext\n        );\n    });\n\n    return lastTopoId;\n}\n\n/**\n * Compile a variable reference from ool to ast.\n * @param {string} startTopoId - The topological id of the starting process to the target value, default as the param name\n * @param {object} varOol - Target value ool node.\n * @param {object} compileContext - Compilation context.\n * @property {string} compileContext.moduleName\n * @property {TopoSort} compileContext.topoSort\n * @property {object} compileContext.astMap - Topo Id to ast map\n * @returns {string} Last topo Id\n */\nfunction compileVariableReference(startTopoId, varOol, compileContext) {\n    pre: _.isPlainObject(varOol) && varOol.oolType === 'ObjectReference';\n\n    //let [ baseName, others ] = varOol.name.split('.', 2);\n    /*\n    if (compileContext.modelVars && compileContext.modelVars.has(baseName) && others) {\n        varOol.name = baseName + '.data' + '.' + others;\n    }*/    \n\n    //simple value\n    compileContext.astMap[startTopoId] = JsLang.astValue(varOol);\n    return startTopoId;\n}\n\n/**\n * Get an array of parameter names.\n * @param {array} args - An array of arguments in ool syntax\n * @returns {array}\n */\nfunction translateFunctionParams(args) {\n    if (_.isEmpty(args)) return [];\n\n    let names = new Set();\n\n    function translateFunctionParam(arg, i) {\n        if (_.isPlainObject(arg)) {\n            if (arg.oolType === 'PipedValue') {\n                return translateFunctionParam(arg.value);\n            }\n\n            if (arg.oolType === 'ObjectReference') {\n                if (isDotSeparateName(arg.name)) {\n                    return extractDotSeparateName(arg.name).pop();\n                }\n            }            \n\n            return arg.name;\n        }\n\n        return 'param' + (i + 1).toString();\n    }\n\n    return _.map(args, (arg, i) => {\n        let baseName = translateFunctionParam(arg, i);\n        let name = baseName;\n        let count = 2;\n        \n        while (names.has(name)) {\n            name = baseName + count.toString();\n            count++;\n        }\n\n        names.add(name);\n        return name;        \n    });\n}\n\n/**\n * Compile a concrete value expression from ool to ast\n * @param {string} startTopoId - The topo id of the starting process to the target value expression\n * @param {object} value - Ool node\n * @param {object} compileContext - Compilation context\n * @returns {string} Last topoId\n */\nfunction compileConcreteValueExpression(startTopoId, value, compileContext) {\n    if (_.isPlainObject(value)) {\n        if (value.oolType === 'PipedValue') {\n            return compilePipedValue(startTopoId, value, compileContext);\n        }\n\n        if (value.oolType === 'ObjectReference') {\n            let [ refBase, ...rest ] = extractDotSeparateName(value.name);\n\n            let dependency;\n\n            if (!compileContext.variables[refBase]) {\n                throw new Error(`Referenced undefined variable: ${value.name}`);                \n            } \n\n            if (compileContext.variables[refBase].type === 'entity' && !compileContext.variables[refBase].ongoing) {\n                dependency = refBase;\n            } else if (refBase === 'latest' && rest.length > 0) {\n                //latest.password\n                let refFieldName = rest.pop();\n                if (refFieldName !== startTopoId) {\n                    dependency = refFieldName + ':ready';\n                }\n            } else if (_.isEmpty(rest)) {\n                dependency = refBase + ':ready';\n            } \n\n            if (dependency) {\n                dependsOn(compileContext, dependency, startTopoId);\n            }\n\n            return compileVariableReference(startTopoId, value, compileContext);\n        }\n\n        if (value.oolType === 'RegExp') {\n            compileContext.astMap[startTopoId] = JsLang.astValue(value);            \n            return startTopoId;\n        }\n\n        if (value.oorType === 'SymbolToken') {\n            compileContext.astMap[startTopoId] = JsLang.astValue(translateSymbolToken(value.name));            \n            return startTopoId;\n        }\n        \n        value = _.mapValues(value, (valueOfElement, key) => { \n            let sid = createTopoId(compileContext, startTopoId + '.' + key);\n            let eid = compileConcreteValueExpression(sid, valueOfElement, compileContext);\n            if (sid !== eid) {\n                dependsOn(compileContext, eid, startTopoId);\n            }\n            return compileContext.astMap[eid];\n        });\n    } else if (Array.isArray(value)) {\n        value = _.map(value, (valueOfElement, index) => { \n            let sid = createTopoId(compileContext, startTopoId + '[' + index + ']');\n            let eid = compileConcreteValueExpression(sid, valueOfElement, compileContext);\n            if (sid !== eid) {\n                dependsOn(compileContext, eid, startTopoId);\n            }\n            return compileContext.astMap[eid];\n        });\n    }\n\n    compileContext.astMap[startTopoId] = JsLang.astValue(value);\n    return startTopoId;\n}\n\nfunction translateSymbolToken(name) {\n    if (name === 'NOW') {\n        return {\n            \"type\": \"CallExpression\",\n            \"callee\": {\n                \"type\": \"MemberExpression\",\n                \"computed\": false,\n                \"object\": {\n                    \"type\": \"MemberExpression\",\n                    \"computed\": false,\n                    \"object\": {\n                        \"type\": \"MemberExpression\",\n                        \"computed\": false,\n                        \"object\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"Types\"\n                        },\n                        \"property\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"DATETIME\"\n                        }\n                    },\n                    \"property\": {\n                        \"type\": \"Identifier\",\n                        \"name\": \"typeObject\"\n                    }\n                },\n                \"property\": {\n                    \"type\": \"Identifier\",\n                    \"name\": \"local\"\n                }\n            },\n            \"arguments\": []\n        };\n    } \n    \n    throw new Error('not support: ' + name);\n}\n\n/**\n * Translate an array of function arguments from ool into ast.\n * @param topoId - The modifier function topo \n * @param args - \n * @param compileContext - \n * @returns {Array}\n */\nfunction translateArgs(topoId, args, compileContext) {\n    args = _.castArray(args);\n    if (_.isEmpty(args)) return [];\n\n    let callArgs = [];\n\n    _.each(args, (arg, i) => {                \n        let argTopoId = createTopoId(compileContext, topoId + ':arg[' + (i+1).toString() + ']');\n        let lastTopoId = compileConcreteValueExpression(argTopoId, arg, compileContext);\n\n        dependsOn(compileContext, lastTopoId, topoId);\n\n        callArgs = callArgs.concat(_.castArray(getCodeRepresentationOf(lastTopoId, compileContext)));\n    });\n\n    return callArgs;\n}\n\n/**\n * Compile a param of interface from ool into ast\n * @param index\n * @param param\n * @param compileContext\n * @returns {string}\n */\nfunction compileParam(index, param, compileContext) {\n    let type = param.type;    \n\n    let typeObject = Types[type];\n\n    if (!typeObject) {\n        throw new Error('Unknown field type: ' + type);\n    }\n\n    let sanitizerName = `Types.${type.toUpperCase()}.sanitize`;\n\n    let varRef = JsLang.astVarRef(param.name);\n    let callAst = JsLang.astCall(sanitizerName, [varRef, JsLang.astArrayAccess('$meta.params', index), JsLang.astVarRef('this.db.i18n')]);\n\n    let prepareTopoId = createTopoId(compileContext, '$params:sanitize[' + index.toString() + ']');\n    //let sanitizeStarting;\n\n    //if (index === 0) {\n        //declare $sanitizeState variable for the first time\n    //    sanitizeStarting = JsLang.astVarDeclare(varRef, callAst, false, false, `Sanitize param \"${param.name}\"`);\n    //} else {\n    //let sanitizeStarting = ;\n\n        //let lastPrepareTopoId = '$params:sanitize[' + (index - 1).toString() + ']';\n        //dependsOn(compileContext, lastPrepareTopoId, prepareTopoId);\n    //}\n\n    compileContext.astMap[prepareTopoId] = [\n        JsLang.astAssign(varRef, callAst, `Sanitize argument \"${param.name}\"`)\n    ];\n\n    addCodeBlock(compileContext, prepareTopoId, {\n        type: AST_BLK_PARAM_SANITIZE\n    });\n\n    dependsOn(compileContext, prepareTopoId, compileContext.mainStartId);\n\n    let topoId = createTopoId(compileContext, param.name);\n    dependsOn(compileContext, compileContext.mainStartId, topoId);\n\n    let value = wrapParamReference(param.name, param);\n    let endTopoId = compileVariableReference(topoId, value, compileContext);\n\n    let readyTopoId = createTopoId(compileContext, topoId + ':ready');\n    dependsOn(compileContext, endTopoId, readyTopoId);\n\n    return readyTopoId;\n}\n\n/**\n * Compile a model field preprocess information into ast.\n * @param {object} param - Field information\n * @param {object} compileContext - Compilation context\n * @returns {string}\n */\nfunction compileField(paramName, param, compileContext) {\n    // 1. reference to the latest object that is passed qualifier checks\n    // 2. if modifiers exist, wrap the ref into a piped value\n    // 3. process the ref (or piped ref) and mark as end\n    // 4. build dependencies: latest.field -> ... -> field:ready \n    let topoId = createTopoId(compileContext, paramName);\n    let contextName = 'latest.' + paramName;\n    //compileContext.astMap[topoId] = JsLang.astVarRef(contextName, true);\n\n    let value = wrapParamReference(contextName, param);    \n    let endTopoId = compileConcreteValueExpression(topoId, value, compileContext);\n\n    let readyTopoId = createTopoId(compileContext, topoId + ':ready');\n    dependsOn(compileContext, endTopoId, readyTopoId);\n\n    return readyTopoId;\n}\n\nfunction wrapParamReference(name, value) {\n    let ref = Object.assign({ oolType: 'ObjectReference', name: name });\n    \n    if (!_.isEmpty(value.modifiers)) {\n        return { oolType: 'PipedValue', value: ref, modifiers: value.modifiers };\n    }\n    \n    return ref;\n}\n\nfunction hasModelField(operand, compileContext) {\n    if (_.isPlainObject(operand) && operand.oolType === 'ObjectReference') {\n        let [ baseVar, ...rest ] = operand.name.split('.');\n\n        return compileContext.variables[baseVar] && compileContext.variables[baseVar].ongoing && rest.length > 0;        \n    }\n\n    return false;    \n}\n\n/**\n * Translate a then clause from ool into ast in return block.\n * @param {string} startId\n * @param {string} endId\n * @param then\n * @param compileContext\n * @returns {object} AST object\n */\nfunction translateReturnThenAst(startId, endId, then, compileContext) {\n    if (_.isPlainObject(then)) {\n        if (then.oolType === 'ThrowExpression') {\n            let args;\n            if (then.args) {\n                args = translateArgs(startId, then.args, compileContext);\n            } else {\n                args = [];\n            }\n            return JsLang.astThrow(then.errorType || defaultError, then.message || args);\n        }\n\n        if (then.oolType === 'ReturnExpression') {\n            return translateReturnValueAst(startId, endId, then.value, compileContext);\n        }        \n    }\n\n    //then expression is an oolong concrete value    \n    if (_.isArray(then) || _.isPlainObject(then)) {\n        let valueEndId = compileConcreteValueExpression(startId, then, compileContext);    \n        then = compileContext.astMap[valueEndId]; \n    }   \n\n    return JsLang.astReturn(then);\n}\n\n/**\n * Translate a then clause from ool into ast\n * @param {string} startId\n * @param {string} endId\n * @param then\n * @param compileContext\n * @param assignTo\n * @returns {object} AST object\n */\nfunction translateThenAst(startId, endId, then, compileContext, assignTo) {\n    if (_.isPlainObject(then)) {\n        if (then.oolType === 'ThrowExpression') {\n            let args;\n            if (then.args) {\n                args = translateArgs(startId, then.args, compileContext);\n            } else {\n                args = [];\n            }\n            return JsLang.astThrow(then.errorType || defaultError, then.message || args);\n        }\n\n        if (then.oolType === 'LogicalExpression') {\n            /*\n            switch (then.operator) {\n                case 'and':\n                    op = '&&';\n                    break;\n\n                case 'or':\n                    op = '||';\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n            */\n        }\n\n        if (then.oolType === 'BinaryExpression') {\n            if (!hasModelField(then.left, compileContext)) {                \n                throw new Error('Invalid query condition: the left operand need to be an entity field.');\n            }\n\n            if (hasModelField(then.right, compileContext)) {                \n                throw new Error('Invalid query condition: the right operand should not be an entity field. Use dataset instead if joining is required.');\n            }\n\n            let condition = {};\n            let startRightId = createTopoId(compileContext, startId + '$binOp:right');\n            dependsOn(compileContext, startId, startRightId);\n\n            let lastRightId = compileConcreteValueExpression(startRightId, then.right, compileContext);\n            dependsOn(compileContext, lastRightId, endId);\n            \n            if (then.operator === '==') {\n                condition[then.left.name.split('.', 2)[1]] = compileContext.astMap[lastRightId];\n            } else {\n                condition[then.left.name.split('.', 2)[1]] = { [OPERATOR_TOKEN[op]]: compileContext.astMap[lastRightId] };\n            }\n\n            return JsLang.astAssign(assignTo, JsLang.astValue(condition));           \n        }\n\n        if (then.oolType === 'UnaryExpression') {\n            \n        }\n    }\n\n    //then expression is an oolong concrete value    \n    if (_.isArray(then) || _.isPlainObject(then)) {\n        let valueEndId = compileConcreteValueExpression(startId, then, compileContext);    \n        then = compileContext.astMap[valueEndId]; \n    }   \n\n    return JsLang.astAssign(assignTo, then);\n}\n\n/**\n * Translate a return clause from ool into ast\n * @param {string} startTopoId - The topo id of the starting state of return clause\n * @param {string} endTopoId - The topo id of the ending state of return clause\n * @param value\n * @param compileContext\n * @returns {object} AST object\n */\nfunction translateReturnValueAst(startTopoId, endTopoId, value, compileContext) {\n    let valueTopoId = compileConcreteValueExpression(startTopoId, value, compileContext);\n    if (valueTopoId !== startTopoId) {\n        dependsOn(compileContext, valueTopoId, endTopoId);\n    }\n\n    return JsLang.astReturn(getCodeRepresentationOf(valueTopoId, compileContext));\n}\n\n/**\n * Compile a return clause from ool into ast\n * @param {string} startTopoId - The topo id of the starting process to the target value expression\n * @param value\n * @param compileContext\n * @returns {object} AST object\n */\nfunction compileReturn(startTopoId, value, compileContext) {\n    let endTopoId = createTopoId(compileContext, '$return');\n    dependsOn(compileContext, startTopoId, endTopoId);\n\n    compileContext.astMap[endTopoId] = translateReturnValueAst(startTopoId, endTopoId, value, compileContext);\n\n    addCodeBlock(compileContext, endTopoId, {\n        type: AST_BLK_VIEW_RETURN\n    });\n\n    return endTopoId;\n}\n\n/**\n * Compile a find one operation from ool into ast\n * @param {int} index\n * @param {object} operation - Ool node\n * @param {object} compileContext -\n * @param {string} dependency\n * @returns {string} last topoId\n */\nfunction compileFindOne(index, operation, compileContext, dependency) {\n    pre: dependency;\n\n    let endTopoId = createTopoId(compileContext, 'op$' + index.toString());\n    let conditionVarName = endTopoId + '$condition';\n\n    let ast = [\n        JsLang.astVarDeclare(conditionVarName)\n    ];\n\n    assert: operation.condition;\n\n    compileContext.variables[operation.model] = { type: 'entity', source: 'findOne', ongoing: true };\n\n    if (operation.condition.oolType) {\n        //special condition\n\n        if (operation.condition.oolType === 'cases') {\n            let topoIdPrefix = endTopoId + '$cases';\n            let lastStatement;\n\n            if (operation.condition.else) {\n                let elseStart = createTopoId(compileContext, topoIdPrefix + ':else');\n                let elseEnd = createTopoId(compileContext, topoIdPrefix + ':end');\n                dependsOn(compileContext, elseStart, elseEnd);\n                dependsOn(compileContext, elseEnd, endTopoId);\n\n                lastStatement = translateThenAst(elseStart, elseEnd, operation.condition.else, compileContext, conditionVarName);\n            } else {\n                lastStatement = JsLang.astThrow('ServerError', 'Unexpected state.');\n            }\n\n            if (_.isEmpty(operation.condition.items)) {\n                throw new Error('Missing case items');\n            }\n\n            _.reverse(operation.condition.items).forEach((item, i) => {\n                if (item.oolType !== 'ConditionalStatement') {\n                    throw new Error('Invalid case item.');\n                }\n\n                i = operation.condition.items.length - i - 1;\n\n                let casePrefix = topoIdPrefix + '[' + i.toString() + ']';\n                let caseTopoId = createTopoId(compileContext, casePrefix);\n                dependsOn(compileContext, dependency, caseTopoId);\n\n                let caseResultVarName = '$' + topoIdPrefix + '_' + i.toString();\n\n                let lastTopoId = compileConditionalExpression(item.test, compileContext, caseTopoId);\n                let astCaseTtem = getCodeRepresentationOf(lastTopoId, compileContext);\n\n                assert: !Array.isArray(astCaseTtem), 'Invalid case item ast.';\n\n                astCaseTtem = JsLang.astVarDeclare(caseResultVarName, astCaseTtem, true, false, `Condition ${i} for find one ${operation.model}`);\n\n                let ifStart = createTopoId(compileContext, casePrefix + ':then');\n                let ifEnd = createTopoId(compileContext, casePrefix + ':end');\n                dependsOn(compileContext, lastTopoId, ifStart);\n                dependsOn(compileContext, ifStart, ifEnd);\n\n                lastStatement = [\n                    astCaseTtem,\n                    JsLang.astIf(JsLang.astVarRef(caseResultVarName), JsLang.astBlock(translateThenAst(ifStart, ifEnd, item.then, compileContext, conditionVarName)), lastStatement)\n                ];\n                dependsOn(compileContext, ifEnd, endTopoId);\n            });\n\n            ast = ast.concat(_.castArray(lastStatement));\n        } else {\n            throw new Error('todo');\n        }\n\n\n    } else {\n        throw new Error('todo');\n    }\n\n    ast.push(\n        JsLang.astVarDeclare(operation.model, JsLang.astAwait(`this.findOne_`, JsLang.astVarRef(conditionVarName)))\n    );\n\n    delete compileContext.variables[operation.model].ongoing;\n\n    let modelTopoId = createTopoId(compileContext, operation.model);\n    dependsOn(compileContext, endTopoId, modelTopoId);\n    compileContext.astMap[endTopoId] = ast;\n    return endTopoId;\n}\n\nfunction compileDbOperation(index, operation, compileContext, dependency) {\n    let lastTopoId;\n\n    switch (operation.oolType) {\n        case 'FindOneStatement':\n            lastTopoId = compileFindOne(index, operation, compileContext, dependency);\n            break;\n\n        case 'find':\n            //prepareDbConnection(compileContext);\n            throw new Error('tbi');\n            break;\n\n        case 'update':\n            throw new Error('tbi');\n            //prepareDbConnection(compileContext);\n            break;\n\n        case 'create':\n            throw new Error('tbi');\n            //prepareDbConnection(compileContext);\n            break;\n\n        case 'delete':\n            throw new Error('tbi');\n            //prepareDbConnection(compileContext);\n            break;\n\n        case 'DoStatement':\n            let doBlock = operation.do;\n            lastTopoId = compileDoStatement(index, doBlock, compileContext, dependency);\n            break;\n\n        case 'assignment':\n            throw new Error('tbi');\n            break;\n\n        default:\n            throw new Error('Unsupported operation type: ' + operation.type);\n    }\n\n    addCodeBlock(compileContext, lastTopoId, {\n        type: AST_BLK_INTERFACE_OPERATION\n    });\n\n    return lastTopoId;\n}\n\nfunction compileDoStatement(index, operation, compileContext, dependency) {\n        \n}\n\n/**\n * Compile exceptional return \n * @param {object} oolNode\n * @param {object} compileContext\n * @param {string} [dependency]\n * @returns {string} last topoId\n */\nfunction compileExceptionalReturn(oolNode, compileContext, dependency) {\n    pre: (_.isPlainObject(oolNode) && oolNode.oolType === 'ReturnExpression');\n\n    let endTopoId = createTopoId(compileContext, '$return'), lastExceptionId = dependency;\n\n    if (!_.isEmpty(oolNode.exceptions)) {\n        oolNode.exceptions.forEach((item, i) => {\n            if (_.isPlainObject(item)) {\n                if (item.oolType !== 'ConditionalStatement') {\n                    throw new Error('Unsupported exceptional type: ' + item.oolType);\n                }\n\n                let exceptionStartId = createTopoId(compileContext, endTopoId + ':except[' + i.toString() + ']');\n                let exceptionEndId = createTopoId(compileContext, endTopoId + ':except[' + i.toString() + ']:done');\n                if (lastExceptionId) {\n                    dependsOn(compileContext, lastExceptionId, exceptionStartId);\n                }\n\n                let lastTopoId = compileConditionalExpression(item.test, compileContext, exceptionStartId);\n\n                let thenStartId = createTopoId(compileContext, exceptionStartId + ':then');\n                dependsOn(compileContext, lastTopoId, thenStartId);\n                dependsOn(compileContext, thenStartId, exceptionEndId);\n\n                compileContext.astMap[exceptionEndId] = JsLang.astIf(\n                    getCodeRepresentationOf(lastTopoId, compileContext),\n                    JsLang.astBlock(translateReturnThenAst(\n                        thenStartId,\n                        exceptionEndId,\n                        item.then, compileContext)),\n                    null,\n                    `Return on exception #${i}`\n                );\n\n                addCodeBlock(compileContext, exceptionEndId, {\n                    type: AST_BLK_EXCEPTION_ITEM\n                });\n\n                lastExceptionId = exceptionEndId;\n            } else {\n                throw new Error('Unexpected.');\n            }\n        });\n    }\n\n    dependsOn(compileContext, lastExceptionId, endTopoId);\n\n    let returnStartTopoId = createTopoId(compileContext, '$return:value');\n    dependsOn(compileContext, returnStartTopoId, endTopoId);\n\n    compileContext.astMap[endTopoId] = translateReturnValueAst(returnStartTopoId, endTopoId, oolNode.value, compileContext);\n\n    addCodeBlock(compileContext, endTopoId, {\n        type: AST_BLK_INTERFACE_RETURN\n    });\n    \n    return endTopoId;\n}\n\nfunction createTopoId(compileContext, name) {\n    if (compileContext.topoNodes.has(name)) {\n        throw new Error(`Topo id \"${name}\" already created.`);\n    }\n\n    assert: !compileContext.topoSort.hasDependency(name), 'Already in topoSort!';\n\n    compileContext.topoNodes.add(name);\n\n    return name;\n}\n\nfunction dependsOn(compileContext, previousOp, currentOp) {\n    pre: previousOp !== currentOp, 'Self depending';\n\n    compileContext.linker.log('debug', currentOp + ' \\x1b[33mdepends on\\x1b[0m ' + previousOp);\n\n    if (!compileContext.topoNodes.has(currentOp)) {\n        throw new Error(`Topo id \"${currentOp}\" not created.`);\n    }\n\n    compileContext.topoSort.add(previousOp, currentOp);\n}\n\nfunction addCodeBlock(compileContext, topoId, blockMeta) {\n    if (!(topoId in compileContext.astMap)) {\n        throw new Error(`AST not found for block with topoId: ${topoId}`);\n    }\n\n    compileContext.mapOfTokenToMeta.set(topoId, blockMeta);\n\n    compileContext.linker.log('verbose', `Adding ${blockMeta.type} \"${topoId}\" into source code.`);    \n}\n\nfunction getCodeRepresentationOf(topoId, compileContext) {\n    let lastSourceType = compileContext.mapOfTokenToMeta.get(topoId);\n\n    if (lastSourceType && (lastSourceType.type === AST_BLK_PROCESSOR_CALL || lastSourceType.type === AST_BLK_ACTIVATOR_CALL)) {\n        //for modifier, just use the final result\n        return JsLang.astVarRef(lastSourceType.target, true);\n    }\n\n    let ast = compileContext.astMap[topoId];\n    if (ast.type === 'MemberExpression' && ast.object.name === 'latest') {\n        return JsLang.astConditional(\n            JsLang.astCall('latest.hasOwnProperty', [ ast.property.value ]), /** test */\n            ast, /** consequent */\n            { ...ast, object: { ...ast.object, name: 'existing' } }\n        );   \n    }\n\n    return compileContext.astMap[topoId];\n}\n\nfunction createCompileContext(moduleName, linker, sharedContext) {\n    let compileContext = {\n        moduleName,        \n        linker,\n        variables: {},\n        topoNodes: new Set(),\n        topoSort: new TopoSort(),\n        astMap: {}, // Store the AST for a node\n        mapOfTokenToMeta: new Map(), // Store the source code block point\n        modelVars: new Set(),\n        mapOfFunctorToFile: (sharedContext && sharedContext.mapOfFunctorToFile) || {}, // Use to record import lines\n        newFunctorFiles: (sharedContext && sharedContext.newFunctorFiles) || []\n    };\n\n    compileContext.mainStartId = createTopoId(compileContext, '$main');\n\n    linker.log('verbose', `Created compilation context for \"${moduleName}\".`);\n\n    return compileContext;\n}\n\nfunction isTopLevelBlock(topoId) {\n    return topoId.indexOf(':arg[') === -1 && topoId.indexOf('$cases[') === -1 && topoId.indexOf('$exceptions[') === -1;\n}\n\nfunction replaceVarRefScope(varRef, targetScope) {\n    if (_.isPlainObject(varRef)) {\n        assert: varRef.oolType === 'ObjectReference';\n\n        return { oolType: 'ObjectReference', name: replaceVarRefScope(varRef.name, targetScope) };        \n    } \n\n    assert: typeof varRef === 'string';\n\n    let parts = varRef.split('.');\n    assert: parts.length > 1;\n\n    parts.splice(0, 1, targetScope);\n    return parts.join('.');\n}\n\nmodule.exports = {\n    compileParam,\n    compileField,\n    compileDbOperation,\n    compileExceptionalReturn,\n    compileReturn,\n    createTopoId,\n    createCompileContext,\n    dependsOn,\n    addCodeBlock,\n\n    AST_BLK_FIELD_PRE_PROCESS,\n    AST_BLK_PROCESSOR_CALL,\n    AST_BLK_VALIDATOR_CALL,\n    AST_BLK_ACTIVATOR_CALL,\n    AST_BLK_VIEW_OPERATION,\n    AST_BLK_VIEW_RETURN,\n    AST_BLK_INTERFACE_OPERATION,\n    AST_BLK_INTERFACE_RETURN, \n    AST_BLK_EXCEPTION_ITEM,\n\n    OOL_MODIFIER_CODE_FLAG\n};"],"mappings":"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"}