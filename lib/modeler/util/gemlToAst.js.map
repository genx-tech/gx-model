{"version":3,"sources":["../../../src/modeler/util/gemlToAst.js"],"names":["_","require","TopoSort","JsLang","GemlTypes","isDotSeparateName","extractDotSeparateName","extractReferenceBaseName","Types","Validators","Processors","Activators","defaultError","AST_BLK_FIELD_PRE_PROCESS","AST_BLK_PARAM_SANITIZE","AST_BLK_PROCESSOR_CALL","AST_BLK_VALIDATOR_CALL","AST_BLK_ACTIVATOR_CALL","AST_BLK_VIEW_OPERATION","AST_BLK_VIEW_RETURN","AST_BLK_INTERFACE_OPERATION","AST_BLK_INTERFACE_RETURN","AST_BLK_EXCEPTION_ITEM","OOL_MODIFIER_CODE_FLAG","Modifier","VALIDATOR","PROCESSOR","ACTIVATOR","OOL_MODIFIER_OP","OOL_MODIFIER_PATH","OOL_MODIFIER_BUILTIN","OPERATOR_TOKEN","compileConditionalExpression","test","compileContext","startTopoId","isPlainObject","oolType","endTopoId","createTopoId","operandTopoId","dependsOn","lastOperandTopoId","compileConcreteValueExpression","caller","astArgument","getCodeRepresentationOf","retTopoId","compileAdHocValidator","callee","assert","op","operator","Error","leftTopoId","rightTopoId","lastLeftId","left","lastRightId","right","astMap","astBinExp","argument","astNot","astCall","valueStartTopoId","astValue","topoId","value","functor","callArgs","args","translateArgs","arg0","name","concat","compileModifier","declareParams","translateFunctionParams","moduleName","isEmpty","functorId","translateModifier","references","extractReferencedFields","find","ref","astAwait","astVarRef","isTopLevelBlock","startsWith","astConditional","replaceVarRefScope","targetVarName","needDeclare","variables","counter","toString","hasOwnProperty","type","source","addCodeBlock","target","oolArgs","castArray","refs","forEach","a","Array","isArray","result","checkReferenceToField","push","obj","undefined","addModifierToMap","functorType","functorJsFile","mapOfFunctorToFile","functionName","fileName","names","length","refEntityName","upperFirst","builtins","newFunctorFiles","compilePipedValue","varOol","lastTopoId","modifiers","modifier","modifierStartTopoId","compileVariableReference","pre","Set","translateFunctionParam","arg","i","pop","map","baseName","count","has","add","refBase","rest","dependency","ongoing","refFieldName","oorType","translateSymbolToken","mapValues","valueOfElement","key","sid","eid","index","each","argTopoId","compileParam","param","typeObject","sanitizerName","toUpperCase","varRef","callAst","astArrayAccess","prepareTopoId","astAssign","mainStartId","wrapParamReference","readyTopoId","compileField","paramName","contextName","Object","assign","hasModelField","operand","baseVar","split","translateReturnThenAst","startId","endId","then","astThrow","errorType","message","translateReturnValueAst","valueEndId","astReturn","translateThenAst","assignTo","condition","startRightId","valueTopoId","compileReturn","compileFindOne","operation","conditionVarName","ast","astVarDeclare","model","topoIdPrefix","lastStatement","else","elseStart","elseEnd","items","reverse","item","casePrefix","caseTopoId","caseResultVarName","astCaseTtem","ifStart","ifEnd","astIf","astBlock","modelTopoId","compileDbOperation","doBlock","do","compileDoStatement","compileExceptionalReturn","oolNode","lastExceptionId","exceptions","exceptionStartId","exceptionEndId","thenStartId","returnStartTopoId","topoNodes","topoSort","hasDependency","previousOp","currentOp","linker","log","blockMeta","mapOfTokenToMeta","set","lastSourceType","get","object","property","createCompileContext","sharedContext","Map","modelVars","indexOf","targetScope","parts","splice","join","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * @module\n * @ignore\n */\n\nconst { _ } = require('@genx/july');\nconst { TopoSort } = require('@genx/algorithm');\n\nconst JsLang = require('./ast.js');\nconst GemlTypes = require('../../lang/GemlTypes');\nconst { isDotSeparateName, extractDotSeparateName, extractReferenceBaseName } = require('../../lang/GemlUtils');\nconst { Types, Validators, Processors, Activators } = require('@genx/data');\n\nconst defaultError = 'InvalidRequest';\n\nconst AST_BLK_FIELD_PRE_PROCESS = 'FieldPreProcess';\nconst AST_BLK_PARAM_SANITIZE = 'ParameterSanitize';\nconst AST_BLK_PROCESSOR_CALL = 'ProcessorCall';\nconst AST_BLK_VALIDATOR_CALL = 'ValidatorCall';\nconst AST_BLK_ACTIVATOR_CALL = 'ActivatorCall';\nconst AST_BLK_VIEW_OPERATION = 'ViewOperation';\nconst AST_BLK_VIEW_RETURN = 'ViewReturn';\nconst AST_BLK_INTERFACE_OPERATION = 'InterfaceOperation';\nconst AST_BLK_INTERFACE_RETURN = 'InterfaceReturn';\nconst AST_BLK_EXCEPTION_ITEM = 'ExceptionItem';\n\nconst OOL_MODIFIER_CODE_FLAG = {\n    [GemlTypes.Modifier.VALIDATOR]: AST_BLK_VALIDATOR_CALL,\n    [GemlTypes.Modifier.PROCESSOR]: AST_BLK_PROCESSOR_CALL,\n    [GemlTypes.Modifier.ACTIVATOR]: AST_BLK_ACTIVATOR_CALL\n};\n\nconst OOL_MODIFIER_OP = {\n    [GemlTypes.Modifier.VALIDATOR]: '|~',\n    [GemlTypes.Modifier.PROCESSOR]: '|>',\n    [GemlTypes.Modifier.ACTIVATOR]: '|=' \n};\n\nconst OOL_MODIFIER_PATH = {\n    [GemlTypes.Modifier.VALIDATOR]: 'validators',\n    [GemlTypes.Modifier.PROCESSOR]: 'processors',\n    [GemlTypes.Modifier.ACTIVATOR]: 'activators' \n};\n\nconst OOL_MODIFIER_BUILTIN = {\n    [GemlTypes.Modifier.VALIDATOR]: Validators,\n    [GemlTypes.Modifier.PROCESSOR]: Processors,\n    [GemlTypes.Modifier.ACTIVATOR]: Activators \n};\n\nconst OPERATOR_TOKEN = {\n    \">\": \"$gt\",\n    \"<\": \"$lt\",\n    \">=\": \"$gte\",\n    \"<=\": \"$lte\",\n    \"==\": \"$eq\",\n    \"!=\": \"$ne\",\n    \"in\": \"$in\",\n    \"notIn\": \"$nin\"\n};\n\n/**\n * Compile a conditional expression\n * @param {object} test\n * @param {object} compileContext\n * @property {string} compileContext.moduleName\n * @property {TopoSort} compileContext.topoSort\n * @property {object} compileContext.astMap - Topo Id to ast map\n * @param {string} startTopoId\n * @returns {string} Topo Id\n */\nfunction compileConditionalExpression(test, compileContext, startTopoId) {\n    if (_.isPlainObject(test)) {        \n        if (test.oolType === 'ValidateExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$valiOp:done');\n            let operandTopoId = createTopoId(compileContext, startTopoId + '$valiOp');\n\n            dependsOn(compileContext, startTopoId, operandTopoId);\n\n            let lastOperandTopoId = compileConcreteValueExpression(operandTopoId, test.caller, compileContext);\n            dependsOn(compileContext, lastOperandTopoId, endTopoId);\n\n            let astArgument = getCodeRepresentationOf(lastOperandTopoId, compileContext);\n\n            let retTopoId = compileAdHocValidator(endTopoId, astArgument, test.callee, compileContext);\n\n            assert: retTopoId === endTopoId;\n\n            /*\n            compileContext.astMap[endTopoId] = JsLang.astCall('_.isEmpty', astArgument);\n\n            switch (test.operator) {\n                case 'exists':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isEmpty', astArgument));\n                    break;\n\n                case 'is-not-null':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isNil', astArgument));\n                    break;\n\n                case 'not-exists':\n                    \n                    break;\n\n                case 'is-null':\n                    compileContext.astMap[endTopoId] = JsLang.astCall('_.isNil', astArgument);\n                    break;\n\n                case 'not':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(astArgument);\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n            */\n\n            return endTopoId;\n\n        } else if (test.oolType === 'LogicalExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$lopOp:done');\n\n            let op;\n\n            switch (test.operator) {\n                case 'and':\n                    op = '&&';\n                    break;\n\n                case 'or':\n                    op = '||';\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n\n            let leftTopoId = createTopoId(compileContext, startTopoId + '$lopOp:left');\n            let rightTopoId = createTopoId(compileContext, startTopoId + '$lopOp:right');\n\n            dependsOn(compileContext, startTopoId, leftTopoId);\n            dependsOn(compileContext, startTopoId, rightTopoId);\n\n            let lastLeftId = compileConditionalExpression(test.left, compileContext, leftTopoId);\n            let lastRightId = compileConditionalExpression(test.right, compileContext, rightTopoId);\n\n            dependsOn(compileContext, lastLeftId, endTopoId);\n            dependsOn(compileContext, lastRightId, endTopoId);\n\n            compileContext.astMap[endTopoId] = JsLang.astBinExp(\n                getCodeRepresentationOf(lastLeftId, compileContext),\n                op,\n                getCodeRepresentationOf(lastRightId, compileContext)\n            ); \n\n            return endTopoId;\n\n        } else if (test.oolType === 'BinaryExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$binOp:done');\n\n            let op;\n\n            switch (test.operator) {\n                case '>':\n                case '<':\n                case '>=':\n                case '<=':\n                case 'in':\n                    op = test.operator;\n                    break;\n\n                case '==':\n                    op = '===';\n                    break;\n\n                case '!=':\n                    op = '!==';\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n\n            let leftTopoId = createTopoId(compileContext, startTopoId + '$binOp:left');\n            let rightTopoId = createTopoId(compileContext, startTopoId + '$binOp:right');\n\n            dependsOn(compileContext, startTopoId, leftTopoId);\n            dependsOn(compileContext, startTopoId, rightTopoId);\n\n            let lastLeftId = compileConcreteValueExpression(leftTopoId, test.left, compileContext);\n            let lastRightId = compileConcreteValueExpression(rightTopoId, test.right, compileContext);\n\n            dependsOn(compileContext, lastLeftId, endTopoId);\n            dependsOn(compileContext, lastRightId, endTopoId);\n\n            compileContext.astMap[endTopoId] = JsLang.astBinExp(\n                getCodeRepresentationOf(lastLeftId, compileContext),\n                op,\n                getCodeRepresentationOf(lastRightId, compileContext)\n            ); \n\n            return endTopoId;\n\n        } else if (test.oolType === 'UnaryExpression') {\n            let endTopoId = createTopoId(compileContext, startTopoId + '$unaOp:done');\n            let operandTopoId = createTopoId(compileContext, startTopoId + '$unaOp');\n\n            dependsOn(compileContext, startTopoId, operandTopoId);\n\n            let lastOperandTopoId = test.operator === 'not' ? compileConcreteValueExpression(operandTopoId, test.argument, compileContext) : compileConditionalExpression(test.argument, compileContext, operandTopoId);\n            dependsOn(compileContext, lastOperandTopoId, endTopoId);\n\n            let astArgument = getCodeRepresentationOf(lastOperandTopoId, compileContext);\n\n            switch (test.operator) {\n                case 'exists':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isEmpty', astArgument));\n                    break;\n\n                case 'is-not-null':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(JsLang.astCall('_.isNil', astArgument));\n                    break;\n\n                case 'not-exists':\n                    compileContext.astMap[endTopoId] = JsLang.astCall('_.isEmpty', astArgument);\n                    break;\n\n                case 'is-null':\n                    compileContext.astMap[endTopoId] = JsLang.astCall('_.isNil', astArgument);\n                    break;\n\n                case 'not':\n                    compileContext.astMap[endTopoId] = JsLang.astNot(astArgument);\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n\n            return endTopoId;\n\n        } else {\n            let valueStartTopoId = createTopoId(compileContext, startTopoId + '$value');\n            dependsOn(compileContext, startTopoId, valueStartTopoId);\n            return compileConcreteValueExpression(valueStartTopoId, test, compileContext);\n        } \n    }\n\n    compileContext.astMap[startTopoId] = JsLang.astValue(test);\n    return startTopoId;\n}\n\n/**\n * Compile a validator called in a logical expression.\n * @param value\n * @param functors\n * @param compileContext\n * @param topoInfo\n * @property {string} topoInfo.topoIdPrefix\n * @property {string} topoInfo.lastTopoId\n * @returns {*|string}\n */\nfunction compileAdHocValidator(topoId, value, functor, compileContext) {\n    assert: functor.oolType === GemlTypes.Modifier.VALIDATOR;        \n\n    let callArgs;\n    \n    if (functor.args) {\n        callArgs = translateArgs(topoId, functor.args, compileContext);        \n    } else {\n        callArgs = [];\n    }            \n    \n    let arg0 = value;\n    \n    compileContext.astMap[topoId] = JsLang.astCall('Validators.' + functor.name, [ arg0 ].concat(callArgs));\n\n    return topoId;\n}\n\n/**\n * Compile a modifier from ool to ast.\n * @param topoId - startTopoId\n * @param value\n * @param functors\n * @param compileContext\n * @param topoInfo\n * @property {string} topoInfo.topoIdPrefix\n * @property {string} topoInfo.lastTopoId\n * @returns {*|string}\n */\nfunction compileModifier(topoId, value, functor, compileContext) {\n    let declareParams;\n\n    if (functor.oolType === GemlTypes.Modifier.ACTIVATOR) { \n        declareParams = translateFunctionParams([{name: compileContext.moduleName}, {name: 'context'}].concat(functor.args));        \n    } else {\n        declareParams = translateFunctionParams(_.isEmpty(functor.args) ? [value] : [value].concat(functor.args));        \n    }        \n\n    let functorId = translateModifier(functor, compileContext, declareParams);\n\n    let callArgs, references;\n    \n    if (functor.args) {\n        callArgs = translateArgs(topoId, functor.args, compileContext);\n        references = extractReferencedFields(functor.args);\n\n        if (_.find(references, ref => ref === value.name)) {\n            throw new Error('Cannot use the target field itself as an argument of a modifier.');\n        }\n    } else {\n        callArgs = [];\n    }        \n    \n    if (functor.oolType === GemlTypes.Modifier.ACTIVATOR) {            \n        compileContext.astMap[topoId] = JsLang.astAwait(functorId, [ JsLang.astVarRef('this'), JsLang.astVarRef('context') ].concat(callArgs));\n    } else {\n        let arg0 = value;\n        if (!isTopLevelBlock(topoId) && _.isPlainObject(value) && value.oolType === 'ObjectReference' && value.name.startsWith('latest.')) {\n            //let existingRef =            \n            arg0 = JsLang.astConditional(\n                JsLang.astCall('latest.hasOwnProperty', [ extractReferenceBaseName(value.name) ]), /** test */\n                value, /** consequent */\n                replaceVarRefScope(value, 'existing')\n            );  \n        }\n        compileContext.astMap[topoId] = JsLang.astCall(functorId, [ arg0 ].concat(callArgs));\n    }    \n\n    if (isTopLevelBlock(topoId)) {\n        let targetVarName = value.name;\n        let needDeclare = false;\n\n        if (!isDotSeparateName(value.name) && compileContext.variables[value.name] && functor.oolType !== GemlTypes.Modifier.VALIDATOR) {\n            //conflict with existing variables, need to rename to another variable\n            let counter = 1;\n            do {\n                counter++;       \n                targetVarName = value.name + counter.toString();         \n            } while (compileContext.variables.hasOwnProperty(targetVarName));            \n\n            compileContext.variables[targetVarName] = { type: 'localVariable', source: 'modifier' };\n            needDeclare = true;\n        }\n\n        //if (compileContext.variables[])\n\n        addCodeBlock(compileContext, topoId, {\n            type: OOL_MODIFIER_CODE_FLAG[functor.oolType],\n            target: targetVarName,\n            references,   // latest., exsiting., raw.\n            needDeclare\n        });\n    }\n\n    return topoId;\n}  \n      \nfunction extractReferencedFields(oolArgs) {   \n    oolArgs = _.castArray(oolArgs);    \n\n    let refs = [];\n\n    oolArgs.forEach(a => {\n        if (Array.isArray(a)) {\n            refs = refs.concat(extractReferencedFields(a));\n            return;\n        } \n\n        let result = checkReferenceToField(a);\n        if (result) {\n            refs.push(result);\n        }\n    });\n\n    return refs;\n}\n\nfunction checkReferenceToField(obj) {\n    if (_.isPlainObject(obj) && obj.oolType) {\n        if (obj.oolType === 'PipedValue') return checkReferenceToField(obj.value);\n        if (obj.oolType === 'ObjectReference') {\n            return obj.name;\n        }\n    }\n\n    return undefined;\n}\n\nfunction addModifierToMap(functorId, functorType, functorJsFile, mapOfFunctorToFile) {\n    if (mapOfFunctorToFile[functorId] && mapOfFunctorToFile[functorId] !== functorJsFile) {\n        throw new Error(`Conflict: ${functorType} naming \"${functorId}\" conflicts!`);\n    }\n    mapOfFunctorToFile[functorId] = functorJsFile;\n}\n\n/**\n * Check whether a functor is user-defined or built-in\n * @param functor\n * @param compileContext\n * @param args - Used to make up the function signature\n * @returns {string} functor id\n */\nfunction translateModifier(functor, compileContext, args) {\n    let functionName, fileName, functorId;\n\n    //extract validator naming and import information\n    if (isDotSeparateName(functor.name)) {\n        let names = extractDotSeparateName(functor.name);\n        if (names.length > 2) {\n            throw new Error('Not supported reference type: ' + functor.name);\n        }\n\n        //reference to other entity file\n        let refEntityName = names[0];\n        functionName = names[1];\n        fileName = './' + OOL_MODIFIER_PATH[functor.oolType] + '/' + refEntityName + '-' + functionName + '.js';\n        functorId = refEntityName + _.upperFirst(functionName);\n        addModifierToMap(functorId, functor.oolType, fileName, compileContext.mapOfFunctorToFile);\n\n    } else {\n        functionName = functor.name;\n\n        let builtins = OOL_MODIFIER_BUILTIN[functor.oolType];\n\n        if (!(functionName in builtins)) {\n            fileName = './' + OOL_MODIFIER_PATH[functor.oolType] + '/' + compileContext.moduleName + '-' + functionName + '.js';\n            functorId = functionName;\n\n            if (!compileContext.mapOfFunctorToFile[functorId]) {\n                compileContext.newFunctorFiles.push({\n                    functionName,\n                    functorType: functor.oolType,\n                    fileName,\n                    args\n                });\n            }\n\n            addModifierToMap(functorId, functor.oolType, fileName, compileContext.mapOfFunctorToFile);            \n        } else {            \n            functorId = functor.oolType + 's.' + functionName;\n        }\n    }\n\n    return functorId;\n}\n\n/**\n * Compile a piped value from ool to ast.\n * @param {string} startTopoId - The topological id of the starting process to the target value, default as the param name\n * @param {object} varOol - Target value ool node.\n * @param {object} compileContext - Compilation context.\n * @property {string} compileContext.moduleName\n * @property {TopoSort} compileContext.topoSort\n * @property {object} compileContext.astMap - Topo Id to ast map\n * @returns {string} Last topo Id\n */\nfunction compilePipedValue(startTopoId, varOol, compileContext) {\n    let lastTopoId = compileConcreteValueExpression(startTopoId, varOol.value, compileContext);\n\n    varOol.modifiers.forEach(modifier => {\n        let modifierStartTopoId = createTopoId(compileContext, startTopoId + OOL_MODIFIER_OP[modifier.oolType] + modifier.name);\n        dependsOn(compileContext, lastTopoId, modifierStartTopoId);\n\n        lastTopoId = compileModifier(\n            modifierStartTopoId,\n            varOol.value,\n            modifier,\n            compileContext\n        );\n    });\n\n    return lastTopoId;\n}\n\n/**\n * Compile a variable reference from ool to ast.\n * @param {string} startTopoId - The topological id of the starting process to the target value, default as the param name\n * @param {object} varOol - Target value ool node.\n * @param {object} compileContext - Compilation context.\n * @property {string} compileContext.moduleName\n * @property {TopoSort} compileContext.topoSort\n * @property {object} compileContext.astMap - Topo Id to ast map\n * @returns {string} Last topo Id\n */\nfunction compileVariableReference(startTopoId, varOol, compileContext) {\n    pre: _.isPlainObject(varOol) && varOol.oolType === 'ObjectReference';\n\n    //let [ baseName, others ] = varOol.name.split('.', 2);\n    /*\n    if (compileContext.modelVars && compileContext.modelVars.has(baseName) && others) {\n        varOol.name = baseName + '.data' + '.' + others;\n    }*/    \n\n    //simple value\n    compileContext.astMap[startTopoId] = JsLang.astValue(varOol);\n    return startTopoId;\n}\n\n/**\n * Get an array of parameter names.\n * @param {array} args - An array of arguments in ool syntax\n * @returns {array}\n */\nfunction translateFunctionParams(args) {\n    if (_.isEmpty(args)) return [];\n\n    let names = new Set();\n\n    function translateFunctionParam(arg, i) {\n        if (_.isPlainObject(arg)) {\n            if (arg.oolType === 'PipedValue') {\n                return translateFunctionParam(arg.value);\n            }\n\n            if (arg.oolType === 'ObjectReference') {\n                if (isDotSeparateName(arg.name)) {\n                    return extractDotSeparateName(arg.name).pop();\n                }\n            }            \n\n            return arg.name;\n        }\n\n        return 'param' + (i + 1).toString();\n    }\n\n    return _.map(args, (arg, i) => {\n        let baseName = translateFunctionParam(arg, i);\n        let name = baseName;\n        let count = 2;\n        \n        while (names.has(name)) {\n            name = baseName + count.toString();\n            count++;\n        }\n\n        names.add(name);\n        return name;        \n    });\n}\n\n/**\n * Compile a concrete value expression from ool to ast\n * @param {string} startTopoId - The topo id of the starting process to the target value expression\n * @param {object} value - Ool node\n * @param {object} compileContext - Compilation context\n * @returns {string} Last topoId\n */\nfunction compileConcreteValueExpression(startTopoId, value, compileContext) {\n    if (_.isPlainObject(value)) {\n        if (value.oolType === 'PipedValue') {\n            return compilePipedValue(startTopoId, value, compileContext);\n        }\n\n        if (value.oolType === 'ObjectReference') {\n            let [ refBase, ...rest ] = extractDotSeparateName(value.name);\n\n            let dependency;\n\n            if (!compileContext.variables[refBase]) {\n                throw new Error(`Referenced undefined variable: ${value.name}`);                \n            } \n\n            if (compileContext.variables[refBase].type === 'entity' && !compileContext.variables[refBase].ongoing) {\n                dependency = refBase;\n            } else if (refBase === 'latest' && rest.length > 0) {\n                //latest.password\n                let refFieldName = rest.pop();\n                if (refFieldName !== startTopoId) {\n                    dependency = refFieldName + ':ready';\n                }\n            } else if (_.isEmpty(rest)) {\n                dependency = refBase + ':ready';\n            } \n\n            if (dependency) {\n                dependsOn(compileContext, dependency, startTopoId);\n            }\n\n            return compileVariableReference(startTopoId, value, compileContext);\n        }\n\n        if (value.oolType === 'RegExp') {\n            compileContext.astMap[startTopoId] = JsLang.astValue(value);            \n            return startTopoId;\n        }\n\n        if (value.oorType === 'SymbolToken') {\n            compileContext.astMap[startTopoId] = JsLang.astValue(translateSymbolToken(value.name));            \n            return startTopoId;\n        }\n        \n        value = _.mapValues(value, (valueOfElement, key) => { \n            let sid = createTopoId(compileContext, startTopoId + '.' + key);\n            let eid = compileConcreteValueExpression(sid, valueOfElement, compileContext);\n            if (sid !== eid) {\n                dependsOn(compileContext, eid, startTopoId);\n            }\n            return compileContext.astMap[eid];\n        });\n    } else if (Array.isArray(value)) {\n        value = _.map(value, (valueOfElement, index) => { \n            let sid = createTopoId(compileContext, startTopoId + '[' + index + ']');\n            let eid = compileConcreteValueExpression(sid, valueOfElement, compileContext);\n            if (sid !== eid) {\n                dependsOn(compileContext, eid, startTopoId);\n            }\n            return compileContext.astMap[eid];\n        });\n    }\n\n    compileContext.astMap[startTopoId] = JsLang.astValue(value);\n    return startTopoId;\n}\n\nfunction translateSymbolToken(name) {\n    if (name === 'NOW') {\n        return {\n            \"type\": \"CallExpression\",\n            \"callee\": {\n                \"type\": \"MemberExpression\",\n                \"computed\": false,\n                \"object\": {\n                    \"type\": \"MemberExpression\",\n                    \"computed\": false,\n                    \"object\": {\n                        \"type\": \"MemberExpression\",\n                        \"computed\": false,\n                        \"object\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"Types\"\n                        },\n                        \"property\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"DATETIME\"\n                        }\n                    },\n                    \"property\": {\n                        \"type\": \"Identifier\",\n                        \"name\": \"typeObject\"\n                    }\n                },\n                \"property\": {\n                    \"type\": \"Identifier\",\n                    \"name\": \"local\"\n                }\n            },\n            \"arguments\": []\n        };\n    } \n    \n    throw new Error('not support: ' + name);\n}\n\n/**\n * Translate an array of function arguments from ool into ast.\n * @param topoId - The modifier function topo \n * @param args - \n * @param compileContext - \n * @returns {Array}\n */\nfunction translateArgs(topoId, args, compileContext) {\n    args = _.castArray(args);\n    if (_.isEmpty(args)) return [];\n\n    let callArgs = [];\n\n    _.each(args, (arg, i) => {                \n        let argTopoId = createTopoId(compileContext, topoId + ':arg[' + (i+1).toString() + ']');\n        let lastTopoId = compileConcreteValueExpression(argTopoId, arg, compileContext);\n\n        dependsOn(compileContext, lastTopoId, topoId);\n\n        callArgs = callArgs.concat(_.castArray(getCodeRepresentationOf(lastTopoId, compileContext)));\n    });\n\n    return callArgs;\n}\n\n/**\n * Compile a param of interface from ool into ast\n * @param index\n * @param param\n * @param compileContext\n * @returns {string}\n */\nfunction compileParam(index, param, compileContext) {\n    let type = param.type;    \n\n    let typeObject = Types[type];\n\n    if (!typeObject) {\n        throw new Error('Unknown field type: ' + type);\n    }\n\n    let sanitizerName = `Types.${type.toUpperCase()}.sanitize`;\n\n    let varRef = JsLang.astVarRef(param.name);\n    let callAst = JsLang.astCall(sanitizerName, [varRef, JsLang.astArrayAccess('$meta.params', index), JsLang.astVarRef('this.db.i18n')]);\n\n    let prepareTopoId = createTopoId(compileContext, '$params:sanitize[' + index.toString() + ']');\n    //let sanitizeStarting;\n\n    //if (index === 0) {\n        //declare $sanitizeState variable for the first time\n    //    sanitizeStarting = JsLang.astVarDeclare(varRef, callAst, false, false, `Sanitize param \"${param.name}\"`);\n    //} else {\n    //let sanitizeStarting = ;\n\n        //let lastPrepareTopoId = '$params:sanitize[' + (index - 1).toString() + ']';\n        //dependsOn(compileContext, lastPrepareTopoId, prepareTopoId);\n    //}\n\n    compileContext.astMap[prepareTopoId] = [\n        JsLang.astAssign(varRef, callAst, `Sanitize argument \"${param.name}\"`)\n    ];\n\n    addCodeBlock(compileContext, prepareTopoId, {\n        type: AST_BLK_PARAM_SANITIZE\n    });\n\n    dependsOn(compileContext, prepareTopoId, compileContext.mainStartId);\n\n    let topoId = createTopoId(compileContext, param.name);\n    dependsOn(compileContext, compileContext.mainStartId, topoId);\n\n    let value = wrapParamReference(param.name, param);\n    let endTopoId = compileVariableReference(topoId, value, compileContext);\n\n    let readyTopoId = createTopoId(compileContext, topoId + ':ready');\n    dependsOn(compileContext, endTopoId, readyTopoId);\n\n    return readyTopoId;\n}\n\n/**\n * Compile a model field preprocess information into ast.\n * @param {object} param - Field information\n * @param {object} compileContext - Compilation context\n * @returns {string}\n */\nfunction compileField(paramName, param, compileContext) {\n    // 1. reference to the latest object that is passed qualifier checks\n    // 2. if modifiers exist, wrap the ref into a piped value\n    // 3. process the ref (or piped ref) and mark as end\n    // 4. build dependencies: latest.field -> ... -> field:ready \n    let topoId = createTopoId(compileContext, paramName);\n    let contextName = 'latest.' + paramName;\n    //compileContext.astMap[topoId] = JsLang.astVarRef(contextName, true);\n\n    let value = wrapParamReference(contextName, param);    \n    let endTopoId = compileConcreteValueExpression(topoId, value, compileContext);\n\n    let readyTopoId = createTopoId(compileContext, topoId + ':ready');\n    dependsOn(compileContext, endTopoId, readyTopoId);\n\n    return readyTopoId;\n}\n\nfunction wrapParamReference(name, value) {\n    let ref = Object.assign({ oolType: 'ObjectReference', name: name });\n    \n    if (!_.isEmpty(value.modifiers)) {\n        return { oolType: 'PipedValue', value: ref, modifiers: value.modifiers };\n    }\n    \n    return ref;\n}\n\nfunction hasModelField(operand, compileContext) {\n    if (_.isPlainObject(operand) && operand.oolType === 'ObjectReference') {\n        let [ baseVar, ...rest ] = operand.name.split('.');\n\n        return compileContext.variables[baseVar] && compileContext.variables[baseVar].ongoing && rest.length > 0;        \n    }\n\n    return false;    \n}\n\n/**\n * Translate a then clause from ool into ast in return block.\n * @param {string} startId\n * @param {string} endId\n * @param then\n * @param compileContext\n * @returns {object} AST object\n */\nfunction translateReturnThenAst(startId, endId, then, compileContext) {\n    if (_.isPlainObject(then)) {\n        if (then.oolType === 'ThrowExpression') {\n            let args;\n            if (then.args) {\n                args = translateArgs(startId, then.args, compileContext);\n            } else {\n                args = [];\n            }\n            return JsLang.astThrow(then.errorType || defaultError, then.message || args);\n        }\n\n        if (then.oolType === 'ReturnExpression') {\n            return translateReturnValueAst(startId, endId, then.value, compileContext);\n        }        \n    }\n\n    //then expression is an oolong concrete value    \n    if (_.isArray(then) || _.isPlainObject(then)) {\n        let valueEndId = compileConcreteValueExpression(startId, then, compileContext);    \n        then = compileContext.astMap[valueEndId]; \n    }   \n\n    return JsLang.astReturn(then);\n}\n\n/**\n * Translate a then clause from ool into ast\n * @param {string} startId\n * @param {string} endId\n * @param then\n * @param compileContext\n * @param assignTo\n * @returns {object} AST object\n */\nfunction translateThenAst(startId, endId, then, compileContext, assignTo) {\n    if (_.isPlainObject(then)) {\n        if (then.oolType === 'ThrowExpression') {\n            let args;\n            if (then.args) {\n                args = translateArgs(startId, then.args, compileContext);\n            } else {\n                args = [];\n            }\n            return JsLang.astThrow(then.errorType || defaultError, then.message || args);\n        }\n\n        if (then.oolType === 'LogicalExpression') {\n            /*\n            switch (then.operator) {\n                case 'and':\n                    op = '&&';\n                    break;\n\n                case 'or':\n                    op = '||';\n                    break;\n\n                default:\n                    throw new Error('Unsupported test operator: ' + test.operator);\n            }\n            */\n        }\n\n        if (then.oolType === 'BinaryExpression') {\n            if (!hasModelField(then.left, compileContext)) {                \n                throw new Error('Invalid query condition: the left operand need to be an entity field.');\n            }\n\n            if (hasModelField(then.right, compileContext)) {                \n                throw new Error('Invalid query condition: the right operand should not be an entity field. Use dataset instead if joining is required.');\n            }\n\n            let condition = {};\n            let startRightId = createTopoId(compileContext, startId + '$binOp:right');\n            dependsOn(compileContext, startId, startRightId);\n\n            let lastRightId = compileConcreteValueExpression(startRightId, then.right, compileContext);\n            dependsOn(compileContext, lastRightId, endId);\n            \n            if (then.operator === '==') {\n                condition[then.left.name.split('.', 2)[1]] = compileContext.astMap[lastRightId];\n            } else {\n                condition[then.left.name.split('.', 2)[1]] = { [OPERATOR_TOKEN[op]]: compileContext.astMap[lastRightId] };\n            }\n\n            return JsLang.astAssign(assignTo, JsLang.astValue(condition));           \n        }\n\n        if (then.oolType === 'UnaryExpression') {\n            \n        }\n    }\n\n    //then expression is an oolong concrete value    \n    if (_.isArray(then) || _.isPlainObject(then)) {\n        let valueEndId = compileConcreteValueExpression(startId, then, compileContext);    \n        then = compileContext.astMap[valueEndId]; \n    }   \n\n    return JsLang.astAssign(assignTo, then);\n}\n\n/**\n * Translate a return clause from ool into ast\n * @param {string} startTopoId - The topo id of the starting state of return clause\n * @param {string} endTopoId - The topo id of the ending state of return clause\n * @param value\n * @param compileContext\n * @returns {object} AST object\n */\nfunction translateReturnValueAst(startTopoId, endTopoId, value, compileContext) {\n    let valueTopoId = compileConcreteValueExpression(startTopoId, value, compileContext);\n    if (valueTopoId !== startTopoId) {\n        dependsOn(compileContext, valueTopoId, endTopoId);\n    }\n\n    return JsLang.astReturn(getCodeRepresentationOf(valueTopoId, compileContext));\n}\n\n/**\n * Compile a return clause from ool into ast\n * @param {string} startTopoId - The topo id of the starting process to the target value expression\n * @param value\n * @param compileContext\n * @returns {object} AST object\n */\nfunction compileReturn(startTopoId, value, compileContext) {\n    let endTopoId = createTopoId(compileContext, '$return');\n    dependsOn(compileContext, startTopoId, endTopoId);\n\n    compileContext.astMap[endTopoId] = translateReturnValueAst(startTopoId, endTopoId, value, compileContext);\n\n    addCodeBlock(compileContext, endTopoId, {\n        type: AST_BLK_VIEW_RETURN\n    });\n\n    return endTopoId;\n}\n\n/**\n * Compile a find one operation from ool into ast\n * @param {int} index\n * @param {object} operation - Ool node\n * @param {object} compileContext -\n * @param {string} dependency\n * @returns {string} last topoId\n */\nfunction compileFindOne(index, operation, compileContext, dependency) {\n    pre: dependency;\n\n    let endTopoId = createTopoId(compileContext, 'op$' + index.toString());\n    let conditionVarName = endTopoId + '$condition';\n\n    let ast = [\n        JsLang.astVarDeclare(conditionVarName)\n    ];\n\n    assert: operation.condition;\n\n    compileContext.variables[operation.model] = { type: 'entity', source: 'findOne', ongoing: true };\n\n    if (operation.condition.oolType) {\n        //special condition\n\n        if (operation.condition.oolType === 'cases') {\n            let topoIdPrefix = endTopoId + '$cases';\n            let lastStatement;\n\n            if (operation.condition.else) {\n                let elseStart = createTopoId(compileContext, topoIdPrefix + ':else');\n                let elseEnd = createTopoId(compileContext, topoIdPrefix + ':end');\n                dependsOn(compileContext, elseStart, elseEnd);\n                dependsOn(compileContext, elseEnd, endTopoId);\n\n                lastStatement = translateThenAst(elseStart, elseEnd, operation.condition.else, compileContext, conditionVarName);\n            } else {\n                lastStatement = JsLang.astThrow('ServerError', 'Unexpected state.');\n            }\n\n            if (_.isEmpty(operation.condition.items)) {\n                throw new Error('Missing case items');\n            }\n\n            _.reverse(operation.condition.items).forEach((item, i) => {\n                if (item.oolType !== 'ConditionalStatement') {\n                    throw new Error('Invalid case item.');\n                }\n\n                i = operation.condition.items.length - i - 1;\n\n                let casePrefix = topoIdPrefix + '[' + i.toString() + ']';\n                let caseTopoId = createTopoId(compileContext, casePrefix);\n                dependsOn(compileContext, dependency, caseTopoId);\n\n                let caseResultVarName = '$' + topoIdPrefix + '_' + i.toString();\n\n                let lastTopoId = compileConditionalExpression(item.test, compileContext, caseTopoId);\n                let astCaseTtem = getCodeRepresentationOf(lastTopoId, compileContext);\n\n                assert: !Array.isArray(astCaseTtem), 'Invalid case item ast.';\n\n                astCaseTtem = JsLang.astVarDeclare(caseResultVarName, astCaseTtem, true, false, `Condition ${i} for find one ${operation.model}`);\n\n                let ifStart = createTopoId(compileContext, casePrefix + ':then');\n                let ifEnd = createTopoId(compileContext, casePrefix + ':end');\n                dependsOn(compileContext, lastTopoId, ifStart);\n                dependsOn(compileContext, ifStart, ifEnd);\n\n                lastStatement = [\n                    astCaseTtem,\n                    JsLang.astIf(JsLang.astVarRef(caseResultVarName), JsLang.astBlock(translateThenAst(ifStart, ifEnd, item.then, compileContext, conditionVarName)), lastStatement)\n                ];\n                dependsOn(compileContext, ifEnd, endTopoId);\n            });\n\n            ast = ast.concat(_.castArray(lastStatement));\n        } else {\n            throw new Error('todo');\n        }\n\n\n    } else {\n        throw new Error('todo');\n    }\n\n    ast.push(\n        JsLang.astVarDeclare(operation.model, JsLang.astAwait(`this.findOne_`, JsLang.astVarRef(conditionVarName)))\n    );\n\n    delete compileContext.variables[operation.model].ongoing;\n\n    let modelTopoId = createTopoId(compileContext, operation.model);\n    dependsOn(compileContext, endTopoId, modelTopoId);\n    compileContext.astMap[endTopoId] = ast;\n    return endTopoId;\n}\n\nfunction compileDbOperation(index, operation, compileContext, dependency) {\n    let lastTopoId;\n\n    switch (operation.oolType) {\n        case 'FindOneStatement':\n            lastTopoId = compileFindOne(index, operation, compileContext, dependency);\n            break;\n\n        case 'find':\n            //prepareDbConnection(compileContext);\n            throw new Error('tbi');\n            break;\n\n        case 'update':\n            throw new Error('tbi');\n            //prepareDbConnection(compileContext);\n            break;\n\n        case 'create':\n            throw new Error('tbi');\n            //prepareDbConnection(compileContext);\n            break;\n\n        case 'delete':\n            throw new Error('tbi');\n            //prepareDbConnection(compileContext);\n            break;\n\n        case 'DoStatement':\n            let doBlock = operation.do;\n            lastTopoId = compileDoStatement(index, doBlock, compileContext, dependency);\n            break;\n\n        case 'assignment':\n            throw new Error('tbi');\n            break;\n\n        default:\n            throw new Error('Unsupported operation type: ' + operation.type);\n    }\n\n    addCodeBlock(compileContext, lastTopoId, {\n        type: AST_BLK_INTERFACE_OPERATION\n    });\n\n    return lastTopoId;\n}\n\nfunction compileDoStatement(index, operation, compileContext, dependency) {\n        \n}\n\n/**\n * Compile exceptional return \n * @param {object} oolNode\n * @param {object} compileContext\n * @param {string} [dependency]\n * @returns {string} last topoId\n */\nfunction compileExceptionalReturn(oolNode, compileContext, dependency) {\n    pre: (_.isPlainObject(oolNode) && oolNode.oolType === 'ReturnExpression');\n\n    let endTopoId = createTopoId(compileContext, '$return'), lastExceptionId = dependency;\n\n    if (!_.isEmpty(oolNode.exceptions)) {\n        oolNode.exceptions.forEach((item, i) => {\n            if (_.isPlainObject(item)) {\n                if (item.oolType !== 'ConditionalStatement') {\n                    throw new Error('Unsupported exceptional type: ' + item.oolType);\n                }\n\n                let exceptionStartId = createTopoId(compileContext, endTopoId + ':except[' + i.toString() + ']');\n                let exceptionEndId = createTopoId(compileContext, endTopoId + ':except[' + i.toString() + ']:done');\n                if (lastExceptionId) {\n                    dependsOn(compileContext, lastExceptionId, exceptionStartId);\n                }\n\n                let lastTopoId = compileConditionalExpression(item.test, compileContext, exceptionStartId);\n\n                let thenStartId = createTopoId(compileContext, exceptionStartId + ':then');\n                dependsOn(compileContext, lastTopoId, thenStartId);\n                dependsOn(compileContext, thenStartId, exceptionEndId);\n\n                compileContext.astMap[exceptionEndId] = JsLang.astIf(\n                    getCodeRepresentationOf(lastTopoId, compileContext),\n                    JsLang.astBlock(translateReturnThenAst(\n                        thenStartId,\n                        exceptionEndId,\n                        item.then, compileContext)),\n                    null,\n                    `Return on exception #${i}`\n                );\n\n                addCodeBlock(compileContext, exceptionEndId, {\n                    type: AST_BLK_EXCEPTION_ITEM\n                });\n\n                lastExceptionId = exceptionEndId;\n            } else {\n                throw new Error('Unexpected.');\n            }\n        });\n    }\n\n    dependsOn(compileContext, lastExceptionId, endTopoId);\n\n    let returnStartTopoId = createTopoId(compileContext, '$return:value');\n    dependsOn(compileContext, returnStartTopoId, endTopoId);\n\n    compileContext.astMap[endTopoId] = translateReturnValueAst(returnStartTopoId, endTopoId, oolNode.value, compileContext);\n\n    addCodeBlock(compileContext, endTopoId, {\n        type: AST_BLK_INTERFACE_RETURN\n    });\n    \n    return endTopoId;\n}\n\nfunction createTopoId(compileContext, name) {\n    if (compileContext.topoNodes.has(name)) {\n        throw new Error(`Topo id \"${name}\" already created.`);\n    }\n\n    assert: !compileContext.topoSort.hasDependency(name), 'Already in topoSort!';\n\n    compileContext.topoNodes.add(name);\n\n    return name;\n}\n\nfunction dependsOn(compileContext, previousOp, currentOp) {\n    pre: previousOp !== currentOp, 'Self depending';\n\n    compileContext.linker.log('debug', currentOp + ' \\x1b[33mdepends on\\x1b[0m ' + previousOp);\n\n    if (!compileContext.topoNodes.has(currentOp)) {\n        throw new Error(`Topo id \"${currentOp}\" not created.`);\n    }\n\n    compileContext.topoSort.add(previousOp, currentOp);\n}\n\nfunction addCodeBlock(compileContext, topoId, blockMeta) {\n    if (!(topoId in compileContext.astMap)) {\n        throw new Error(`AST not found for block with topoId: ${topoId}`);\n    }\n\n    compileContext.mapOfTokenToMeta.set(topoId, blockMeta);\n\n    compileContext.linker.log('verbose', `Adding ${blockMeta.type} \"${topoId}\" into source code.`);    \n}\n\nfunction getCodeRepresentationOf(topoId, compileContext) {\n    let lastSourceType = compileContext.mapOfTokenToMeta.get(topoId);\n\n    if (lastSourceType && (lastSourceType.type === AST_BLK_PROCESSOR_CALL || lastSourceType.type === AST_BLK_ACTIVATOR_CALL)) {\n        //for modifier, just use the final result\n        return JsLang.astVarRef(lastSourceType.target, true);\n    }\n\n    let ast = compileContext.astMap[topoId];\n    if (ast.type === 'MemberExpression' && ast.object.name === 'latest') {\n        return JsLang.astConditional(\n            JsLang.astCall('latest.hasOwnProperty', [ ast.property.value ]), /** test */\n            ast, /** consequent */\n            { ...ast, object: { ...ast.object, name: 'existing' } }\n        );   \n    }\n\n    return compileContext.astMap[topoId];\n}\n\nfunction createCompileContext(moduleName, linker, sharedContext) {\n    let compileContext = {\n        moduleName,        \n        linker,\n        variables: {},\n        topoNodes: new Set(),\n        topoSort: new TopoSort(),\n        astMap: {}, // Store the AST for a node\n        mapOfTokenToMeta: new Map(), // Store the source code block point\n        modelVars: new Set(),\n        mapOfFunctorToFile: (sharedContext && sharedContext.mapOfFunctorToFile) || {}, // Use to record import lines\n        newFunctorFiles: (sharedContext && sharedContext.newFunctorFiles) || []\n    };\n\n    compileContext.mainStartId = createTopoId(compileContext, '$main');\n\n    linker.log('verbose', `Created compilation context for \"${moduleName}\".`);\n\n    return compileContext;\n}\n\nfunction isTopLevelBlock(topoId) {\n    return topoId.indexOf(':arg[') === -1 && topoId.indexOf('$cases[') === -1 && topoId.indexOf('$exceptions[') === -1;\n}\n\nfunction replaceVarRefScope(varRef, targetScope) {\n    if (_.isPlainObject(varRef)) {\n        assert: varRef.oolType === 'ObjectReference';\n\n        return { oolType: 'ObjectReference', name: replaceVarRefScope(varRef.name, targetScope) };        \n    } \n\n    assert: typeof varRef === 'string';\n\n    let parts = varRef.split('.');\n    assert: parts.length > 1;\n\n    parts.splice(0, 1, targetScope);\n    return parts.join('.');\n}\n\nmodule.exports = {\n    compileParam,\n    compileField,\n    compileDbOperation,\n    compileExceptionalReturn,\n    compileReturn,\n    createTopoId,\n    createCompileContext,\n    dependsOn,\n    addCodeBlock,\n\n    AST_BLK_FIELD_PRE_PROCESS,\n    AST_BLK_PROCESSOR_CALL,\n    AST_BLK_VALIDATOR_CALL,\n    AST_BLK_ACTIVATOR_CALL,\n    AST_BLK_VIEW_OPERATION,\n    AST_BLK_VIEW_RETURN,\n    AST_BLK_INTERFACE_OPERATION,\n    AST_BLK_INTERFACE_RETURN, \n    AST_BLK_EXCEPTION_ITEM,\n\n    OOL_MODIFIER_CODE_FLAG\n};"],"file":"gemlToAst.js"}