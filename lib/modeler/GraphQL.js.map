{"version":3,"sources":["../../src/modeler/GraphQL.js"],"names":["path","require","_","naming","fs","toGraphQLType","GraphQLModeler","constructor","context","linker","connector","outputPath","modelPath","manifestPath","modeling_","schema","log","name","_generateGraphQLModel","_generateEnumTypes","forOwn","entities","entity","entityInstanceName","fields","field","fieldName","type","generated","Set","typeDefs","capitalized","pascalCase","map","key","typeInfo","newType","has","add","typeName","push","values","v","snakeCase","toUpperCase","join","Error","isEmpty","associations","each","assoc","anchor","list","classCode","modelFilePath","resolve","ensureFileSync","writeFileSync","_generateEntityManifest","Object","keys","sort","reduce","result","outputFilePath","JSON","stringify","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst path = require('path');\nconst { _, naming }  = require('@genx/july');\nconst { fs } = require('@genx/sys');\n\nconst { toGraphQLType } = require('./graphql/lang');\n\n/**\n * GraphQL schemas modeler.\n * @class\n */\nclass GraphQLModeler {\n    /**     \n     * @param {object} context   \n     * @property {GemlLinker} context.linker - Geml linker\n     * @property {object} context.modelPath - Generated model output path\n     * @property {object} context.manifestPath - Entities manifest output path\n     * @param {Connector} connector      \n     */\n    constructor(context, linker, connector) {       \n        this.linker = linker;\n        this.outputPath = context.modelPath;\n        this.manifestPath = context.manifestPath;\n\n        this.connector = connector;        \n    }\n\n    modeling_(schema) {\n        this.linker.log('info', 'Generating graphql models for schema \"' + schema.name + '\"...');\n\n        //this._generateSchemaModel(schema);        \n        this._generateGraphQLModel(schema);\n    }\n\n    /*\n    _generateSchemaModel(schema) {\n        let capitalized = pascalCase(schema.name);\n\n        let locals = {\n            driver: this.connector.driver,\n            className: capitalized,\n            schemaName: schema.name,\n            entities: JSON.stringify(Object.keys(schema.entities))\n        };\n\n        let classTemplate = path.resolve(__dirname, 'database', this.connector.driver, 'Database.js.swig');\n        let classCode = swig.renderFile(classTemplate, locals);\n\n        let modelFilePath = path.resolve(this.outputPath, capitalized + '.js');\n        fs.ensureFileSync(modelFilePath);\n        fs.writeFileSync(modelFilePath, classCode);\n\n        this.linker.log('info', 'Generated database model: ' + modelFilePath);\n    }*/\n\n    _generateEnumTypes(schema) {\n        _.forOwn(schema.entities, (entity, entityInstanceName) => {\n            _.forOwn(entity.fields, (field, fieldName) => {\n                if (field.type === 'enum') {\n\n                }\n            });\n        });\n    }\n\n    _generateGraphQLModel(schema) {\n        const generated = new Set();\n\n        const typeDefs = [];\n\n        _.forOwn(schema.entities, (entity, entityInstanceName) => {            \n            let capitalized = naming.pascalCase(entityInstanceName);                  \n\n            let fields = _.map(entity.fields, (field, fieldName) => {  \n                if (fieldName === entity.key) {\n                    return `${fieldName}: ID!`;\n                }\n\n                const typeInfo = toGraphQLType(field);    \n                \n                if (typeInfo.newType) {\n                    if (!generated.has(typeInfo.newType)) {\n                        generated.add(typeInfo.newType);\n\n                        switch (typeInfo.typeName) {\n                            case 'scalar':\n                                typeDefs.push(`scalar ${typeInfo.newType}`);\n                                break;\n\n                            case 'enum':\n                                typeDefs.push(`enum ${typeInfo.newType} {\n    ${typeInfo.values.map(v => _.snakeCase(v).toUpperCase()).join('\\n    ')}\n}`);\n                                break;\n\n                            default:\n                                throw new Error(`Unsupported graphql type: ${typeInfo.newType}`);\n                        }\n                    } \n                }\n                \n                return `${fieldName}: ${typeInfo.type}`;\n            });\n\n            if (_.isEmpty(!entity.associations)) {\n                _.each(entity.associations, (assoc, anchor) => {\n                    const typeName = naming.pascalCase(assoc.entity);\n\n                    if (assoc.list) {\n                        fields.push(`${anchor}_: [${typeName}!]`);\n                    } else {\n                        fields.push(`${anchor}_: ${typeName}`);\n                    }\n                });\n            }\n\n            let classCode = `type ${capitalized} {\n    ${fields.join('\\n    ')}\n}`;                         \n\n            typeDefs.push(classCode);            \n        });\n\n        let modelFilePath = path.resolve(this.manifestPath, 'graphql', schema.name + '.graphql');\n        fs.ensureFileSync(modelFilePath);\n        fs.writeFileSync(modelFilePath, typeDefs.join('\\n\\n'));\n\n        this.linker.log('info', 'Generated graphql model: ' + modelFilePath);\n    }\n\n    _generateEntityManifest(schema) {\n        let entities = Object.keys(schema.entities).sort().reduce((result, v) => { result[v] = {}; return result; }, {});\n        /*\n        let manifest = {};\n\n        _.each(schema.entities, (entity, entityName) => {\n            if (entity.info.restful) {\n                _.each(entity.info.restful, ({ type, methods }, relativeUri) => {                    \n                    let apiInfo = {\n                        type,\n                        methods: {}                                            \n                    };\n\n                    if (type === 'entity') {\n                        apiInfo.entity = entityName;\n                        apiInfo.displayName = entity.displayName;\n\n                        if (entity.comment) {\n                            apiInfo.description = entity.comment;\n                        }\n                    }\n\n                    _.each(methods, (meta, methodName) => {\n\n                        switch (methodName) {\n                            case 'create':\n                                apiInfo.methods['post:' + relativeUri] = meta;\n                            break;\n\n                            case 'findOne':\n                            break;\n\n                            case 'fineAll':\n                            break;\n\n                            case 'updateOne':\n                            break;\n\n                            case 'updateMany':\n                            break;\n\n                            case 'deleteOne':\n                            break;\n\n                            case 'deleteMany':\n                            break;\n                        }\n\n                    });\n                });\n            }\n        });\n        */\n        let outputFilePath = path.resolve(this.manifestPath, schema.name + '.manifest.json');\n        fs.ensureFileSync(outputFilePath);\n        fs.writeFileSync(outputFilePath, JSON.stringify(entities, null, 4));\n\n        this.linker.log('info', 'Generated schema manifest: ' + outputFilePath);\n    }\n\n    /*\n    _generateViewModel(schema, dbService) {        \n        _.forOwn(schema.views, (viewInfo, viewName) => {\n            this.linker.info('Building view: ' + viewName);\n\n            let capitalized = _.upperFirst(viewName);\n\n            let ast = JsLang.astProgram();\n\n            JsLang.astPushInBody(ast, JsLang.astRequire('Mowa', 'mowa'));\n            JsLang.astPushInBody(ast, JsLang.astVarDeclare('Util', JsLang.astVarRef('Mowa.Util'), true));\n            JsLang.astPushInBody(ast, JsLang.astVarDeclare('_', JsLang.astVarRef('Util._'), true));\n            JsLang.astPushInBody(ast, JsLang.astRequire('View', 'mowa/lib/oolong/runtime/view'));\n\n            let compileContext = OolToAst.createCompileContext(viewName, dbService.serviceId, this.linker);\n\n            compileContext.modelVars.add(viewInfo.entity);\n\n            let paramMeta;\n\n            if (viewInfo.params) {\n                paramMeta = this._processParams(viewInfo.params, compileContext);\n            }\n\n            let viewMeta = {\n                isList: viewInfo.isList,\n                params: paramMeta\n            };\n\n            let viewBodyTopoId = OolToAst.createTopoId(compileContext, '$view');\n            OolToAst.dependsOn(compileContext, compileContext.mainStartId, viewBodyTopoId);\n\n            let viewModeler = require(path.resolve(__dirname, './dao/view', dbService.dbType + '.js'));\n            compileContext.astMap[viewBodyTopoId] = viewModeler(dbService, viewName, viewInfo);\n            OolToAst.addCodeBlock(compileContext, viewBodyTopoId, {\n                type: OolToAst.AST_BLK_VIEW_OPERATION\n            });\n\n            let returnTopoId = OolToAst.createTopoId(compileContext, '$return:value');\n            OolToAst.dependsOn(compileContext, viewBodyTopoId, returnTopoId);\n            OolToAst.compileReturn(returnTopoId, {\n                \"oolType\": \"ObjectReference\",\n                \"name\": \"viewData\"\n            }, compileContext);\n\n            let deps = compileContext.topoSort.sort();\n            this.linker.verbose('All dependencies:\\n' + JSON.stringify(deps, null, 2));\n\n            deps = deps.filter(dep => compileContext.mapOfTokenToMeta.has(dep));\n            this.linker.verbose('All necessary source code:\\n' + JSON.stringify(deps, null, 2));\n\n            let astDoLoadMain = [\n                JsLang.astVarDeclare('$meta', JsLang.astVarRef('this.meta'), true, false, 'Retrieving the meta data')\n            ];\n\n            _.each(deps, dep => {\n                let astMeta = compileContext.mapOfTokenToMeta.get(dep);\n\n                let astBlock = compileContext.astMap[dep];\n                assert: astBlock, 'Empty ast block';\n\n                if (astMeta.type === 'ModifierCall') {\n                    let fieldName = getFieldName(astMeta.target);\n                    let astCache = JsLang.astAssign(JsLang.astVarRef(astMeta.target), astBlock, `Modifying ${fieldName}`);\n                    astDoLoadMain.push(astCache);\n                    return;\n                }\n\n                astDoLoadMain = astDoLoadMain.concat(_.castArray(compileContext.astMap[dep]));\n            });\n\n            if (!_.isEmpty(compileContext.mapOfFunctorToFile)) {\n                _.forOwn(compileContext.mapOfFunctorToFile, (fileName, functionName) => {\n                    JsLang.astPushInBody(ast, JsLang.astRequire(functionName, '.' + fileName));\n                });\n            }\n\n            if (!_.isEmpty(compileContext.newFunctorFiles)) {\n                _.each(compileContext.newFunctorFiles, entry => {\n                    this._generateFunctionTemplateFile(dbService, entry);\n                });\n            }\n\n            JsLang.astPushInBody(ast, JsLang.astClassDeclare(capitalized, 'View', [\n                JsLang.astMemberMethod('_doLoad', Object.keys(paramMeta),\n                    astDoLoadMain,\n                    false, true, false, 'Populate view data'\n                )\n            ], `${capitalized} view`));\n            JsLang.astPushInBody(ast, JsLang.astAssign(capitalized + '.meta', JsLang.astValue(viewMeta)));\n            JsLang.astPushInBody(ast, JsLang.astAssign('module.exports', JsLang.astVarRef(capitalized)));\n\n            let modelFilePath = path.resolve(this.outputPath, dbService.dbType, dbService.name, 'views', viewName + '.js');\n            fs.ensureFileSync(modelFilePath);\n            fs.writeFileSync(modelFilePath + '.json', JSON.stringify(ast, null, 2));\n\n            DaoModeler._exportSourceCode(ast, modelFilePath);\n\n            this.linker.log('info', 'Generated view model: ' + modelFilePath);\n        });\n    };\n    */\n}\n\nmodule.exports = GraphQLModeler;"],"file":"GraphQL.js"}