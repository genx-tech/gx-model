{"version":3,"sources":["../../src/lang/Schema.js"],"names":["_","require","generateDisplayName","deepCloneField","Clonable","schemaNaming","Schema","constructor","linker","name","gemlModule","info","link","pre","linked","log","comment","displayName","entities","forEach","entityEntry","entity","loadEntity","Error","addEntity","isEmpty","views","viewName","view","loadView","addView","addType","type","typeLocation","existing","types","hasEntity","entityName","each","hasView","getDocumentHierachy","fromModule","datasetName","datasets","dataset","loadDataset","buildHierarchy","getReferencedEntity","refererModule","ensureGetEntity","newlyAdded","push","clone","schema","toJSON","mapValues","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { _ } = require('@genx/july');\nconst { generateDisplayName, deepCloneField, Clonable, schemaNaming } = require('./GemlUtils');\n\n/**\n * Geml schema class.\n * @class Schema\n */\nclass Schema extends Clonable {\n    /**\n     * Types in this schema, map of <typeName, typeInfo>\n     * @member {object.<String, Object>}\n     */\n     types = {};\n\n    /**\n     * Entities in this schema, map of <entityName, entityObject>\n     * @member {object.<string, Entity>}\n     */\n    entities = {};\n\n    /**\n     * Datasets, dataset = entity + relations + projection\n     * @member {object}\n     */\n    datasets = {};\n\n    /**\n     * Views, view = dataset + filters \n     * @member {object}\n     */\n    views = {};    \n\n    /**     \n     * @param {Linker} linker\n     * @param {string} name\n     * @param {object} gemlModule\n     * @param {object} info\n     */\n    constructor(linker, name, gemlModule, info) {\n        super();\n\n        /**\n         * Linker to process this schema\n         * @member {Linker}\n         */\n        this.linker = linker;\n\n        /**\n         * Name of this entity\n         * @member {string}\n         */\n        this.name = schemaNaming(name);\n\n        /**\n         * Owner geml module\n         * @member {object}\n         */\n        this.gemlModule = gemlModule;\n\n        /**\n         * Raw metadata\n         * @member {object}\n         */\n        this.info = info;        \n    }\n\n    /**\n     * Start linking this schema\n     * @returns {Schema}\n     */\n    link() {\n        pre: !this.linked;\n\n        this.linker.log('verbose', 'Linking schema [' + this.name + '] ...');\n\n        if (this.info.comment) {\n            /**\n             * @member {string}\n             */\n            this.comment = this.info.comment;\n        }\n\n        /**\n         * @member {string}\n         */\n        this.displayName = generateDisplayName(this.name);\n\n        //1st round, get direct output entities\n        this.info.entities || (this.info.entities = []);\n\n        this.info.entities.forEach(entityEntry => {            \n            let entity = this.linker.loadEntity(this.gemlModule, entityEntry.entity);\n            if (!entity.linked) {\n                throw new Error(`Entity [${entity.name}] not linked after loading.`);\n            }\n\n            this.addEntity(entity);\n        });\n\n        if (!_.isEmpty(this.info.views)) {\n            this.info.views.forEach(viewName => {\n                let view = this.linker.loadView(this.gemlModule, viewName);\n                if (!view.linked) {\n                    throw new Error(`View [${entity.name}] not linked after loading.`);\n                }\n\n                this.addView(view);\n            });\n        }\n\n        this.linked = true;\n\n        return this;\n    }\n\n    /**\n     * Add an type into the schema\n     * @param {*} type \n     * @param {*} typeLocation \n     * @returns \n     */\n    addType(type, typeLocation) {\n        const existing = this.types[type];\n        if (existing == null) {\n            this.types[type] = typeLocation;\n        } else {\n            if (existing !== typeLocation) {\n                //should never happen\n                throw new Error('Different used types appear in the same entity!');\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Check whether a entity with given name is in the schema\n     * @param {string} entityName\n     * @returns {boolean}\n     */\n    hasEntity(entityName) {\n        return (entityName in this.entities);\n    }\n\n    /**\n     * Add an entity into the schema\n     * @param {Entity} entity\n     * @returns {Schema}\n     */\n    addEntity(entity) {\n        if (this.hasEntity(entity.name)) {\n            throw new Error(`Entity name [${entity.name}] conflicts in schema [${this.name}].`);\n        }\n\n        this.entities[entity.name] = entity;\n\n        _.each(entity.types, (info, type) => this.addType(type, info));\n\n        return this;\n    }\n\n    /**\n     * Check whether a view with given name is in the schema\n     * @param {string} viewName\n     * @returns {boolean}\n     */\n    hasView(viewName) {\n        return (viewName in this.views);\n    }\n\n    /**\n     * Add a view into the schema\n     * @param {View} view \n     * @returns {Schema}\n     */\n    addView(view) {\n        pre: !this.hasView(view.name), `View name [${view.name}] conflicts in schema [${this.name}].`;\n\n        this.views[view.name] = view;\n\n        return this;\n    }\n\n    /**\n     * Get a document hierarchy\n     * @param {object} fromModule\n     * @param {string} datasetName\n     * @returns {object}\n     */\n    getDocumentHierachy(fromModule, datasetName) {\n        if (datasetName in this.datasets) {\n            return this.datasets[datasetName];\n        }\n\n        let dataset = this.linker.loadDataset(fromModule, datasetName);\n        return (this.datasets[datasetName] = dataset.buildHierarchy(this));\n    }\n\n    /**\n     * Get the referenced entity, add it into schema if not in schema\n     * @param {object} refererModule\n     * @param {string} entityName\n     * @returns {Entity}\n     */\n    getReferencedEntity(refererModule, entityName) {\n        let entity = this.linker.loadEntity(refererModule, entityName);\n\n        if (!this.hasEntity(entity.name)) {\n            throw new Error(`Entity \"${entity.name}\" not exists in schema \"${this.name}\".`);\n        }\n\n        return entity;\n    }\n\n    /**\n     * \n     * @param {*} refererModule \n     * @param {*} entityName \n     */\n    ensureGetEntity(refererModule, entityName, newlyAdded) {\n        if (this.hasEntity(entityName)) return this.entities[entityName];\n\n        let entity = this.linker.loadEntity(refererModule, entityName, false);\n\n        if (entity) {\n            this.addEntity(entity);   \n\n            if (newlyAdded) {\n                newlyAdded.push(entity.name);\n                this.linker.log('debug', `New entity \"${entity.name}\" added by association.`);\n            }\n        }\n\n        return entity;\n    }\n\n    /**\n     * Clone the schema\n     * @returns {Schema}\n     */\n    clone() {\n        super.clone();\n        \n        let schema = new Schema(this.linker, this.name, this.gemlModule, this.info);\n        \n        deepCloneField(this, schema, 'displayName');\n        deepCloneField(this, schema, 'comment');        \n        deepCloneField(this, schema, 'entities');   \n        deepCloneField(this, schema, 'types');        \n        deepCloneField(this, schema, 'datasets');\n        deepCloneField(this, schema, 'views');        \n\n        schema.linked = true;\n\n        return schema;\n    }\n\n    /**\n     * Translate the schema into a plain JSON object\n     * @returns {object}\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            displayName: this.displayName,\n            comment: this.comment,        \n            entities: _.mapValues(this.entities, entity => entity.toJSON()),   \n            types: this.types,         \n            datasets: _.mapValues(this.datasets, dataset => dataset.toJSON()), \n            views: _.mapValues(this.views, view => view.toJSON()) \n        };\n    }\n}\n\nmodule.exports = Schema;"],"file":"Schema.js"}