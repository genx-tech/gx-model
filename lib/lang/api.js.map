{"version":3,"sources":["../../src/lang/api.js"],"names":["path","require","_","eachAsync_","fs","Linker","Connector","Validators","createConnector","context","schemaName","deployment","schemaDeployment","Error","dataSource","connectionString","options","driver","split","logger","importDataFilesByList","migrator","dataSetPath","dataListFile","dataList","readFileSync","toString","match","line","trim","length","dataFile","join","existsSync","load_","exports","migrate_","reset","log","Object","keys","reverse","connector","assert","Migration","migration","reset_","error","end_","create_","extraOptions","importDataFiles","dataset_","scriptSourcePath","database","dataSets","readdirSync","validDs","forEach","ds","indexFile","push","import_","datasetName","reverse_","ReserveEngineering","connection","connOptions","modeler","dslReverseOutputPath","getValidatorList"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst path = require('path');\n\nconst { _, eachAsync_ } = require('@genx/july');\nconst { fs } = require('@genx/sys');\n\nconst Linker = require('./Linker');\nconst { Connector, Validators } = require('@genx/data');\n\n/**\n * Oolong DSL api\n * @module Oolong\n */\n\n function createConnector(context, schemaName) {\n    let deployment = context.schemaDeployment[schemaName];\n\n    if (!deployment) {\n        throw new Error(`Schema \"${schemaName}\" has no configured deployment and is ignored in modeling.`);\n    }\n\n    let { dataSource, connectionString, options } = deployment;\n    let [ driver ] = dataSource.split('.');\n\n    return Connector.createConnector(driver, connectionString, { logger: context.logger, ...options });       \n }\n\n async function importDataFilesByList(migrator, dataSetPath, dataListFile) {\n    let dataList = fs.readFileSync(dataListFile).toString().match(/^.+$/gm);\n\n    if (!dataList) {\n        return;\n    }\n\n    return eachAsync_(dataList, async line => {\n        line = line.trim();\n\n        if (line.length > 0 && line[0] !== '#') {            \n            let dataFile = path.join(dataSetPath, line);\n            if (!fs.existsSync(dataFile)) {\n                throw new Error(`Data file \"${dataFile}\" not found.`);\n            }\n\n            await migrator.load_(dataFile);\n        }\n    }); \n }\n\n\n\n\n\n/**\n * Deploy database scripts into database.\n * @param {object} context\n * @property {Logger} context.logger - Logger object\n * @property {string} context.modelPath\n * @property {string} context.dslSourcePath \n * @property {string} context.scriptSourcePath \n * @property {object} context.schemaDeployment   \n * @param {bool} reset\n * @returns {Promise}\n */\nexports.migrate_ = async (context, reset = false) => {\n    context.logger.log('verbose', 'Start deploying models ...');\n\n    if (reset) {\n        await eachAsync_(Object.keys(context.schemaDeployment).reverse(), async (schemaName) => {\n            let connector = createConnector(context, schemaName);\n            assert: connector;\n    \n            try {\n                let Migration = require(`../migration/${connector.driver}`);\n                let migration = new Migration(context, schemaName, connector);\n    \n                await migration.reset_();    \n            } catch (error) {\n                throw error;\n            } finally {\n                await connector.end_();\n            } \n        });\n    }\n\n    return eachAsync_(context.schemaDeployment, async (deployment, schemaName) => {\n        let connector = createConnector(context, schemaName);\n        assert: connector;\n\n        try {\n            let Migration = require(`../migration/${connector.driver}`);\n            let migration = new Migration(context, schemaName, connector);\n\n            await migration.create_(deployment.extraOptions);      \n\n            await importDataFiles(migration, '_init');  \n        } catch (error) {\n            throw error;\n        } finally {\n            await connector.end_();\n        } \n    });\n};\n\n/**\n * @param {object} context\n * @param {string} schemaName\n */\nexports.dataset_ = async (context, schemaName) => {\n    let connector = createConnector(context, schemaName);\n    assert: connector;\n    \n    let dataSetPath = path.join(context.scriptSourcePath, connector.driver, connector.database, 'data');\n\n    if (!fs.existsSync(dataSetPath)) {\n        return [];\n    } else {\n        let dataSets = fs.readdirSync(dataSetPath);\n        let validDs = [];\n        dataSets.forEach(ds => {\n            let indexFile = path.join(dataSetPath, ds, 'index.list');\n            if (fs.existsSync(indexFile)) {\n                validDs.push(ds);\n            }\n        });\n\n        return validDs;\n    }\n}\n\n/**\n * Import a data set into database\n * @param {object} context\n * @property {Logger} context.logger - Logger object\n * @property {string} context.scriptSourcePath  \n * @param {string} schemaName\n * @param {string} datasetName\n * @returns {Promise}\n */\nexports.import_ = async (context, schemaName, datasetName) => {\n    let connector = createConnector(context, schemaName);\n    assert: connector;\n    \n    try {\n        let Migration = require(`../migration/${connector.driver}`);\n        let migration = new Migration(context, schemaName, connector);\n\n        await importDataFiles(migration, datasetName);            \n    } catch (error) {\n        throw error;\n    } finally {\n        await connector.end_();\n    } \n};\n\n/**\n * Extract database structure into oolong dsl\n * @param {object} context\n * @property {Connector} context.connector\n * @property {Logger} context.logger \n * @property {string} context.dslReverseOutputPath \n * @property {string} context.driver\n * @property {object} context.connOptions \n * @returns {Promise}\n */\nexports.reverse_ = async (context) => {   \n    let ReserveEngineering = require(`../modeler/database/${context.driver}/ReverseEngineering`);\n    \n    let { connection: connectionString, ...options } = context.connOptions;  \n    let connector = Connector.createConnector(context.driver, connectionString, { logger: context.logger, ...options });     \n    assert: connector;  \n\n    try {\n        let modeler = new ReserveEngineering(context, connector);\n\n        await modeler.reverse_(context.dslReverseOutputPath);\n    } catch (error) {\n        throw error;\n    } finally {\n        await connector.end_();\n    } \n};\n\nexports.getValidatorList = () => {\n    return Object.keys(Validators);    \n}"],"file":"api.js"}