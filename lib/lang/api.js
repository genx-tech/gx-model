"use strict";

require("source-map-support/register");

const path = require('path');

const Util = require('rk-utils');

const {
  _,
  fs,
  eachAsync_
} = Util;

const Linker = require('./Linker');

const {
  Connector,
  Validators
} = require('@genx/data');

function createConnector(context, schemaName) {
  let deployment = context.schemaDeployment[schemaName];

  if (!deployment) {
    throw new Error(`Schema "${schemaName}" has no configured deployment and is ignored in modeling.`);
  }

  let {
    dataSource,
    connectionString,
    options
  } = deployment;
  let [driver] = dataSource.split('.');
  return Connector.createConnector(driver, connectionString, {
    logger: context.logger,
    ...options
  });
}

async function importDataFilesByList(migrator, dataSetPath, dataListFile) {
  let dataList = fs.readFileSync(dataListFile).toString().match(/^.+$/gm);

  if (!dataList) {
    return;
  }

  return eachAsync_(dataList, async line => {
    line = line.trim();

    if (line.length > 0 && line[0] !== '#') {
      let dataFile = path.join(dataSetPath, line);

      if (!fs.existsSync(dataFile)) {
        throw new Error(`Data file "${dataFile}" not found.`);
      }

      await migrator.load_(dataFile);
    }
  });
}

exports.migrate_ = async (context, reset = false) => {
  context.logger.log('verbose', 'Start deploying models ...');

  if (reset) {
    await eachAsync_(Object.keys(context.schemaDeployment).reverse(), async schemaName => {
      let connector = createConnector(context, schemaName);

      if (!connector) {
        throw new Error("Assertion failed: connector");
      }

      try {
        let Migration = require(`../migration/${connector.driver}`);

        let migration = new Migration(context, schemaName, connector);
        await migration.reset_();
      } catch (error) {
        throw error;
      } finally {
        await connector.end_();
      }
    });
  }

  return eachAsync_(context.schemaDeployment, async (deployment, schemaName) => {
    let connector = createConnector(context, schemaName);

    if (!connector) {
      throw new Error("Assertion failed: connector");
    }

    try {
      let Migration = require(`../migration/${connector.driver}`);

      let migration = new Migration(context, schemaName, connector);
      await migration.create_(deployment.extraOptions);
      await importDataFiles(migration, '_init');
    } catch (error) {
      throw error;
    } finally {
      await connector.end_();
    }
  });
};

exports.dataset_ = async (context, schemaName) => {
  let connector = createConnector(context, schemaName);

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  let dataSetPath = path.join(context.scriptSourcePath, connector.driver, connector.database, 'data');

  if (!fs.existsSync(dataSetPath)) {
    return [];
  } else {
    let dataSets = fs.readdirSync(dataSetPath);
    let validDs = [];
    dataSets.forEach(ds => {
      let indexFile = path.join(dataSetPath, ds, 'index.list');

      if (fs.existsSync(indexFile)) {
        validDs.push(ds);
      }
    });
    return validDs;
  }
};

exports.import_ = async (context, schemaName, datasetName) => {
  let connector = createConnector(context, schemaName);

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  try {
    let Migration = require(`../migration/${connector.driver}`);

    let migration = new Migration(context, schemaName, connector);
    await importDataFiles(migration, datasetName);
  } catch (error) {
    throw error;
  } finally {
    await connector.end_();
  }
};

exports.reverse_ = async context => {
  let ReserveEngineering = require(`../modeler/database/${context.driver}/ReverseEngineering`);

  let {
    connection: connectionString,
    ...options
  } = context.connOptions;
  let connector = Connector.createConnector(context.driver, connectionString, {
    logger: context.logger,
    ...options
  });

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  try {
    let modeler = new ReserveEngineering(context, connector);
    await modeler.reverse_(context.dslReverseOutputPath);
  } catch (error) {
    throw error;
  } finally {
    await connector.end_();
  }
};

exports.getValidatorList = () => {
  return Object.keys(Validators);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYW5nL2FwaS5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIlV0aWwiLCJfIiwiZnMiLCJlYWNoQXN5bmNfIiwiTGlua2VyIiwiQ29ubmVjdG9yIiwiVmFsaWRhdG9ycyIsImNyZWF0ZUNvbm5lY3RvciIsImNvbnRleHQiLCJzY2hlbWFOYW1lIiwiZGVwbG95bWVudCIsInNjaGVtYURlcGxveW1lbnQiLCJFcnJvciIsImRhdGFTb3VyY2UiLCJjb25uZWN0aW9uU3RyaW5nIiwib3B0aW9ucyIsImRyaXZlciIsInNwbGl0IiwibG9nZ2VyIiwiaW1wb3J0RGF0YUZpbGVzQnlMaXN0IiwibWlncmF0b3IiLCJkYXRhU2V0UGF0aCIsImRhdGFMaXN0RmlsZSIsImRhdGFMaXN0IiwicmVhZEZpbGVTeW5jIiwidG9TdHJpbmciLCJtYXRjaCIsImxpbmUiLCJ0cmltIiwibGVuZ3RoIiwiZGF0YUZpbGUiLCJqb2luIiwiZXhpc3RzU3luYyIsImxvYWRfIiwiZXhwb3J0cyIsIm1pZ3JhdGVfIiwicmVzZXQiLCJsb2ciLCJPYmplY3QiLCJrZXlzIiwicmV2ZXJzZSIsImNvbm5lY3RvciIsIk1pZ3JhdGlvbiIsIm1pZ3JhdGlvbiIsInJlc2V0XyIsImVycm9yIiwiZW5kXyIsImNyZWF0ZV8iLCJleHRyYU9wdGlvbnMiLCJpbXBvcnREYXRhRmlsZXMiLCJkYXRhc2V0XyIsInNjcmlwdFNvdXJjZVBhdGgiLCJkYXRhYmFzZSIsImRhdGFTZXRzIiwicmVhZGRpclN5bmMiLCJ2YWxpZERzIiwiZm9yRWFjaCIsImRzIiwiaW5kZXhGaWxlIiwicHVzaCIsImltcG9ydF8iLCJkYXRhc2V0TmFtZSIsInJldmVyc2VfIiwiUmVzZXJ2ZUVuZ2luZWVyaW5nIiwiY29ubmVjdGlvbiIsImNvbm5PcHRpb25zIiwibW9kZWxlciIsImRzbFJldmVyc2VPdXRwdXRQYXRoIiwiZ2V0VmFsaWRhdG9yTGlzdCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFFQSxNQUFNQSxJ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Q0MsSUFBUCxDQUFZakMsVUFBWixDQUFQO0FBQ0gsQ0FGRCIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5jb25zdCBVdGlsID0gcmVxdWlyZSgncmstdXRpbHMnKTtcbmNvbnN0IHsgXywgZnMsIGVhY2hBc3luY18gfSA9IFV0aWw7XG5cbmNvbnN0IExpbmtlciA9IHJlcXVpcmUoJy4vTGlua2VyJyk7XG5jb25zdCB7IENvbm5lY3RvciwgVmFsaWRhdG9ycyB9ID0gcmVxdWlyZSgnQGdlbngvZGF0YScpO1xuXG4vKipcbiAqIE9vbG9uZyBEU0wgYXBpXG4gKiBAbW9kdWxlIE9vbG9uZ1xuICovXG5cbiBmdW5jdGlvbiBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSkge1xuICAgIGxldCBkZXBsb3ltZW50ID0gY29udGV4dC5zY2hlbWFEZXBsb3ltZW50W3NjaGVtYU5hbWVdO1xuXG4gICAgaWYgKCFkZXBsb3ltZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiIGhhcyBubyBjb25maWd1cmVkIGRlcGxveW1lbnQgYW5kIGlzIGlnbm9yZWQgaW4gbW9kZWxpbmcuYCk7XG4gICAgfVxuXG4gICAgbGV0IHsgZGF0YVNvdXJjZSwgY29ubmVjdGlvblN0cmluZywgb3B0aW9ucyB9ID0gZGVwbG95bWVudDtcbiAgICBsZXQgWyBkcml2ZXIgXSA9IGRhdGFTb3VyY2Uuc3BsaXQoJy4nKTtcblxuICAgIHJldHVybiBDb25uZWN0b3IuY3JlYXRlQ29ubmVjdG9yKGRyaXZlciwgY29ubmVjdGlvblN0cmluZywgeyBsb2dnZXI6IGNvbnRleHQubG9nZ2VyLCAuLi5vcHRpb25zIH0pOyAgICAgICBcbiB9XG5cbiBhc3luYyBmdW5jdGlvbiBpbXBvcnREYXRhRmlsZXNCeUxpc3QobWlncmF0b3IsIGRhdGFTZXRQYXRoLCBkYXRhTGlzdEZpbGUpIHtcbiAgICBsZXQgZGF0YUxpc3QgPSBmcy5yZWFkRmlsZVN5bmMoZGF0YUxpc3RGaWxlKS50b1N0cmluZygpLm1hdGNoKC9eLiskL2dtKTtcblxuICAgIGlmICghZGF0YUxpc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBlYWNoQXN5bmNfKGRhdGFMaXN0LCBhc3luYyBsaW5lID0+IHtcbiAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuXG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDAgJiYgbGluZVswXSAhPT0gJyMnKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgZGF0YUZpbGUgPSBwYXRoLmpvaW4oZGF0YVNldFBhdGgsIGxpbmUpO1xuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGRhdGFGaWxlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YSBmaWxlIFwiJHtkYXRhRmlsZX1cIiBub3QgZm91bmQuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IG1pZ3JhdG9yLmxvYWRfKGRhdGFGaWxlKTtcbiAgICAgICAgfVxuICAgIH0pOyBcbiB9XG5cblxuXG5cblxuLyoqXG4gKiBEZXBsb3kgZGF0YWJhc2Ugc2NyaXB0cyBpbnRvIGRhdGFiYXNlLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAqIEBwcm9wZXJ0eSB7TG9nZ2VyfSBjb250ZXh0LmxvZ2dlciAtIExvZ2dlciBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0Lm1vZGVsUGF0aFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQuZHNsU291cmNlUGF0aCBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LnNjcmlwdFNvdXJjZVBhdGggXG4gKiBAcHJvcGVydHkge29iamVjdH0gY29udGV4dC5zY2hlbWFEZXBsb3ltZW50ICAgXG4gKiBAcGFyYW0ge2Jvb2x9IHJlc2V0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuZXhwb3J0cy5taWdyYXRlXyA9IGFzeW5jIChjb250ZXh0LCByZXNldCA9IGZhbHNlKSA9PiB7XG4gICAgY29udGV4dC5sb2dnZXIubG9nKCd2ZXJib3NlJywgJ1N0YXJ0IGRlcGxveWluZyBtb2RlbHMgLi4uJyk7XG5cbiAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgYXdhaXQgZWFjaEFzeW5jXyhPYmplY3Qua2V5cyhjb250ZXh0LnNjaGVtYURlcGxveW1lbnQpLnJldmVyc2UoKSwgYXN5bmMgKHNjaGVtYU5hbWUpID0+IHtcbiAgICAgICAgICAgIGxldCBjb25uZWN0b3IgPSBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSk7XG4gICAgICAgICAgICBhc3NlcnQ6IGNvbm5lY3RvcjtcbiAgICBcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IE1pZ3JhdGlvbiA9IHJlcXVpcmUoYC4uL21pZ3JhdGlvbi8ke2Nvbm5lY3Rvci5kcml2ZXJ9YCk7XG4gICAgICAgICAgICAgICAgbGV0IG1pZ3JhdGlvbiA9IG5ldyBNaWdyYXRpb24oY29udGV4dCwgc2NoZW1hTmFtZSwgY29ubmVjdG9yKTtcbiAgICBcbiAgICAgICAgICAgICAgICBhd2FpdCBtaWdyYXRpb24ucmVzZXRfKCk7ICAgIFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubmVjdG9yLmVuZF8oKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBlYWNoQXN5bmNfKGNvbnRleHQuc2NoZW1hRGVwbG95bWVudCwgYXN5bmMgKGRlcGxveW1lbnQsIHNjaGVtYU5hbWUpID0+IHtcbiAgICAgICAgbGV0IGNvbm5lY3RvciA9IGNyZWF0ZUNvbm5lY3Rvcihjb250ZXh0LCBzY2hlbWFOYW1lKTtcbiAgICAgICAgYXNzZXJ0OiBjb25uZWN0b3I7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBNaWdyYXRpb24gPSByZXF1aXJlKGAuLi9taWdyYXRpb24vJHtjb25uZWN0b3IuZHJpdmVyfWApO1xuICAgICAgICAgICAgbGV0IG1pZ3JhdGlvbiA9IG5ldyBNaWdyYXRpb24oY29udGV4dCwgc2NoZW1hTmFtZSwgY29ubmVjdG9yKTtcblxuICAgICAgICAgICAgYXdhaXQgbWlncmF0aW9uLmNyZWF0ZV8oZGVwbG95bWVudC5leHRyYU9wdGlvbnMpOyAgICAgIFxuXG4gICAgICAgICAgICBhd2FpdCBpbXBvcnREYXRhRmlsZXMobWlncmF0aW9uLCAnX2luaXQnKTsgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBjb25uZWN0b3IuZW5kXygpO1xuICAgICAgICB9IFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtYU5hbWVcbiAqL1xuZXhwb3J0cy5kYXRhc2V0XyA9IGFzeW5jIChjb250ZXh0LCBzY2hlbWFOYW1lKSA9PiB7XG4gICAgbGV0IGNvbm5lY3RvciA9IGNyZWF0ZUNvbm5lY3Rvcihjb250ZXh0LCBzY2hlbWFOYW1lKTtcbiAgICBhc3NlcnQ6IGNvbm5lY3RvcjtcbiAgICBcbiAgICBsZXQgZGF0YVNldFBhdGggPSBwYXRoLmpvaW4oY29udGV4dC5zY3JpcHRTb3VyY2VQYXRoLCBjb25uZWN0b3IuZHJpdmVyLCBjb25uZWN0b3IuZGF0YWJhc2UsICdkYXRhJyk7XG5cbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGF0YVNldFBhdGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGF0YVNldHMgPSBmcy5yZWFkZGlyU3luYyhkYXRhU2V0UGF0aCk7XG4gICAgICAgIGxldCB2YWxpZERzID0gW107XG4gICAgICAgIGRhdGFTZXRzLmZvckVhY2goZHMgPT4ge1xuICAgICAgICAgICAgbGV0IGluZGV4RmlsZSA9IHBhdGguam9pbihkYXRhU2V0UGF0aCwgZHMsICdpbmRleC5saXN0Jyk7XG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhpbmRleEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWREcy5wdXNoKGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkRHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEltcG9ydCBhIGRhdGEgc2V0IGludG8gZGF0YWJhc2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gKiBAcHJvcGVydHkge0xvZ2dlcn0gY29udGV4dC5sb2dnZXIgLSBMb2dnZXIgb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5zY3JpcHRTb3VyY2VQYXRoICBcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWFOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldE5hbWVcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5leHBvcnRzLmltcG9ydF8gPSBhc3luYyAoY29udGV4dCwgc2NoZW1hTmFtZSwgZGF0YXNldE5hbWUpID0+IHtcbiAgICBsZXQgY29ubmVjdG9yID0gY3JlYXRlQ29ubmVjdG9yKGNvbnRleHQsIHNjaGVtYU5hbWUpO1xuICAgIGFzc2VydDogY29ubmVjdG9yO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAgIGxldCBNaWdyYXRpb24gPSByZXF1aXJlKGAuLi9taWdyYXRpb24vJHtjb25uZWN0b3IuZHJpdmVyfWApO1xuICAgICAgICBsZXQgbWlncmF0aW9uID0gbmV3IE1pZ3JhdGlvbihjb250ZXh0LCBzY2hlbWFOYW1lLCBjb25uZWN0b3IpO1xuXG4gICAgICAgIGF3YWl0IGltcG9ydERhdGFGaWxlcyhtaWdyYXRpb24sIGRhdGFzZXROYW1lKTsgICAgICAgICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCBjb25uZWN0b3IuZW5kXygpO1xuICAgIH0gXG59O1xuXG4vKipcbiAqIEV4dHJhY3QgZGF0YWJhc2Ugc3RydWN0dXJlIGludG8gb29sb25nIGRzbFxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAqIEBwcm9wZXJ0eSB7Q29ubmVjdG9yfSBjb250ZXh0LmNvbm5lY3RvclxuICogQHByb3BlcnR5IHtMb2dnZXJ9IGNvbnRleHQubG9nZ2VyIFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQuZHNsUmV2ZXJzZU91dHB1dFBhdGggXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5kcml2ZXJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjb250ZXh0LmNvbm5PcHRpb25zIFxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmV4cG9ydHMucmV2ZXJzZV8gPSBhc3luYyAoY29udGV4dCkgPT4geyAgIFxuICAgIGxldCBSZXNlcnZlRW5naW5lZXJpbmcgPSByZXF1aXJlKGAuLi9tb2RlbGVyL2RhdGFiYXNlLyR7Y29udGV4dC5kcml2ZXJ9L1JldmVyc2VFbmdpbmVlcmluZ2ApO1xuICAgIFxuICAgIGxldCB7IGNvbm5lY3Rpb246IGNvbm5lY3Rpb25TdHJpbmcsIC4uLm9wdGlvbnMgfSA9IGNvbnRleHQuY29ubk9wdGlvbnM7ICBcbiAgICBsZXQgY29ubmVjdG9yID0gQ29ubmVjdG9yLmNyZWF0ZUNvbm5lY3Rvcihjb250ZXh0LmRyaXZlciwgY29ubmVjdGlvblN0cmluZywgeyBsb2dnZXI6IGNvbnRleHQubG9nZ2VyLCAuLi5vcHRpb25zIH0pOyAgICAgXG4gICAgYXNzZXJ0OiBjb25uZWN0b3I7ICBcblxuICAgIHRyeSB7XG4gICAgICAgIGxldCBtb2RlbGVyID0gbmV3IFJlc2VydmVFbmdpbmVlcmluZyhjb250ZXh0LCBjb25uZWN0b3IpO1xuXG4gICAgICAgIGF3YWl0IG1vZGVsZXIucmV2ZXJzZV8oY29udGV4dC5kc2xSZXZlcnNlT3V0cHV0UGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgY29ubmVjdG9yLmVuZF8oKTtcbiAgICB9IFxufTtcblxuZXhwb3J0cy5nZXRWYWxpZGF0b3JMaXN0ID0gKCkgPT4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhWYWxpZGF0b3JzKTsgICAgXG59Il19