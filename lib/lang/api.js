"use strict";

require("source-map-support/register");

const path = require('path');

const Util = require('rk-utils');

const {
  _,
  fs,
  eachAsync_
} = Util;

const Linker = require('./Linker');

const {
  Connector,
  Validators
} = require('@genx/data');

function createConnector(context, schemaName) {
  let deployment = context.schemaDeployment[schemaName];

  if (!deployment) {
    throw new Error(`Schema "${schemaName}" has no configured deployment and is ignored in modeling.`);
  }

  let {
    dataSource,
    connectionString,
    options
  } = deployment;
  let [driver] = dataSource.split('.');
  return Connector.createConnector(driver, connectionString, {
    logger: context.logger,
    ...options
  });
}

async function importDataFilesByList(migrator, dataSetPath, dataListFile) {
  let dataList = fs.readFileSync(dataListFile).toString().match(/^.+$/gm);

  if (!dataList) {
    return;
  }

  return eachAsync_(dataList, async line => {
    line = line.trim();

    if (line.length > 0 && line[0] !== '#') {
      let dataFile = path.join(dataSetPath, line);

      if (!fs.existsSync(dataFile)) {
        throw new Error(`Data file "${dataFile}" not found.`);
      }

      await migrator.load_(dataFile);
    }
  });
}

async function importDataFiles(migrator, folderName) {
  let dataSetPath = path.join(migrator.dbScriptPath, 'data', folderName);
  let dataListFile = path.join(dataSetPath, 'index.list');
  let runtimeDataSetPath,
      runtimeDataSetFile,
      imported = false;

  if (migrator.appModule.runtimeEnv) {
    runtimeDataSetPath = path.join(dataSetPath, migrator.appModule.runtimeEnv);
    runtimeDataSetFile = path.join(runtimeDataSetPath, 'index.list');
  }

  if (fs.existsSync(dataListFile)) {
    await importDataFilesByList(migrator, dataSetPath, dataListFile);
    imported = true;
  } else {
    migrator.appModule.log('warn', `Dataset index file "${dataListFile}" not exist.`);
  }

  if (runtimeDataSetFile && fs.existsSync(runtimeDataSetFile)) {
    await importDataFilesByList(migrator, runtimeDataSetPath, runtimeDataSetFile);
    imported = true;
  } else if (migrator.appModule.runtimeEnv) {
    migrator.appModule.log(imported ? 'info' : 'warn', `Dataset index file of "${migrator.appModule.runtimeEnv}" env "${runtimeDataSetFile}" not exist.`);
  }

  if (!imported) {
    throw new Error(`Entry file of dataset "${folderName}" not found.`);
  }
}

exports.migrate_ = async (context, reset = false) => {
  context.logger.log('verbose', 'Start deploying models ...');

  if (reset) {
    await eachAsync_(Object.keys(context.schemaDeployment).reverse(), async schemaName => {
      let connector = createConnector(context, schemaName);

      if (!connector) {
        throw new Error("Assertion failed: connector");
      }

      try {
        let Migration = require(`../migration/${connector.driver}`);

        let migration = new Migration(context, schemaName, connector);
        await migration.reset_();
      } catch (error) {
        throw error;
      } finally {
        await connector.end_();
      }
    });
  }

  return eachAsync_(context.schemaDeployment, async (deployment, schemaName) => {
    let connector = createConnector(context, schemaName);

    if (!connector) {
      throw new Error("Assertion failed: connector");
    }

    try {
      let Migration = require(`../migration/${connector.driver}`);

      let migration = new Migration(context, schemaName, connector);
      await migration.create_(deployment.extraOptions);
      await importDataFiles(migration, '_init');
    } catch (error) {
      throw error;
    } finally {
      await connector.end_();
    }
  });
};

exports.dataset_ = async (context, schemaName) => {
  let connector = createConnector(context, schemaName);

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  let dataSetPath = path.join(context.scriptSourcePath, connector.driver, connector.database, 'data');

  if (!fs.existsSync(dataSetPath)) {
    return [];
  } else {
    let dataSets = fs.readdirSync(dataSetPath);
    let validDs = [];
    dataSets.forEach(ds => {
      let indexFile = path.join(dataSetPath, ds, 'index.list');

      if (fs.existsSync(indexFile)) {
        validDs.push(ds);
      }
    });
    return validDs;
  }
};

exports.import_ = async (context, schemaName, datasetName) => {
  let connector = createConnector(context, schemaName);

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  try {
    let Migration = require(`../migration/${connector.driver}`);

    let migration = new Migration(context, schemaName, connector);
    await importDataFiles(migration, datasetName);
  } catch (error) {
    throw error;
  } finally {
    await connector.end_();
  }
};

exports.reverse_ = async context => {
  let ReserveEngineering = require(`../modeler/database/${context.driver}/ReverseEngineering`);

  let {
    connection: connectionString,
    ...options
  } = context.connOptions;
  let connector = Connector.createConnector(context.driver, connectionString, {
    logger: context.logger,
    ...options
  });

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  try {
    let modeler = new ReserveEngineering(context, connector);
    await modeler.reverse_(context.dslReverseOutputPath);
  } catch (error) {
    throw error;
  } finally {
    await connector.end_();
  }
};

exports.getValidatorList = () => {
  return Object.keys(Validators);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYW5nL2FwaS5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIlV0aWwiLCJfIiwiZnMiLCJlYWNoQXN5bmNfIiwiTGlua2VyIiwiQ29ubmVjdG9yIiwiVmFsaWRhdG9ycyIsImNyZWF0ZUNvbm5lY3RvciIsImNvbnRleHQiLCJzY2hlbWFOYW1lIiwiZGVwbG95bWVudCIsInNjaGVtYURlcGxveW1lbnQiLCJFcnJvciIsImRhdGFTb3VyY2UiLCJjb25uZWN0aW9uU3RyaW5nIiwib3B0aW9ucyIsImRyaXZlciIsInNwbGl0IiwibG9nZ2VyIiwiaW1wb3J0RGF0YUZpbGVzQnlMaXN0IiwibWlncmF0b3IiLCJkYXRhU2V0UGF0aCIsImRhdGFMaXN0RmlsZSIsImRhdGFMaXN0IiwicmVhZEZpbGVTeW5jIiwidG9TdHJpbmciLCJtYXRjaCIsImxpbmUiLCJ0cmltIiwibGVuZ3RoIiwiZGF0YUZpbGUiLCJqb2luIiwiZXhpc3RzU3luYyIsImxvYWRfIiwiaW1wb3J0RGF0YUZpbGVzIiwiZm9sZGVyTmFtZSIsImRiU2NyaXB0UGF0aCIsInJ1bnRpbWVEYXRhU2V0UGF0aCIsInJ1bnRpbWVEYXRhU2V0RmlsZSIsImltcG9ydGVkIiwiYXBwTW9kdWxlIiwicnVudGltZUVudiIsImxvZyIsImV4cG9ydHMiLCJtaWdyYXRlXyIsInJlc2V0IiwiT2JqZWN0Iiwia2V5cyIsInJldmVyc2UiLCJjb25uZWN0b3IiLCJNaWdyYXRpb24iLCJtaWdyYXRpb24iLCJyZXNldF8iLCJlcnJvciIsImVuZF8iLCJjcmVhdGVfIiwiZXh0cmFPcHRpb25zIiwiZGF0YXNldF8iLCJzY3JpcHRTb3VyY2VQYXRoIiwiZGF0YWJhc2UiLCJkYXRhU2V0cyIsInJlYWRkaXJTeW5jIiwidmFsaWREcyIsImZvckVhY2giLCJkcyIsImluZGV4RmlsZSIsInB1c2giLCJpbXBvcnRfIiwiZGF0YXNldE5hbWUiLCJyZXZlcnNlXyIsIlJlc2VydmVFbmdpbmVlcmluZyIsImNvbm5lY3Rpb24iLCJjb25uT3B0aW9ucyIsIm1vZGVsZXIiLCJkc2xSZXZlcnNlT3V0cHV0UGF0aCIsImdldFZhbGlkYXRvckxpc3QiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBRUEsTUFBTUEsSUFBSSxHQUFHQyxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFFQSxNQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQyxVQUFELENBQXBCOztBQUNBLE1BQU07QUFBRUUsRUFBQUEsQ0FBRjtBQUFLQyxFQUFBQSxFQUFMO0FBQVNDLEVBQUFBO0FBQVQsSUFBd0JILElBQTlCOztBQUVBLE1BQU1JLE1BQU0sR0FBR0wsT0FBTyxDQUFDLFVBQUQsQ0FBdEI7O0FBQ0EsTUFBTTtBQUFFTSxFQUFBQSxTQUFGO0FBQWFDLEVBQUFBO0FBQWIsSUFBNEJQLE9BQU8sQ0FBQyxZQUFELENBQXpDOztBQU9DLFNBQVNRLGVBQVQsQ0FBeUJDLE9BQXpCLEVBQWtDQyxVQUFsQyxFQUE4QztBQUMzQyxNQUFJQyxVQUFVLEdBQUdGLE9BQU8sQ0FBQ0csZ0JBQVIsQ0FBeUJGLFVBQXpCLENBQWpCOztBQUVBLE1BQUksQ0FBQ0MsVUFBTCxFQUFpQjtBQUNiLFVBQU0sSUFBSUUsS0FBSixDQUFXLFdBQVVILFVBQVcsNERBQWhDLENBQU47QUFDSDs7QUFFRCxNQUFJO0FBQUVJLElBQUFBLFVBQUY7QUFBY0MsSUFBQUEsZ0JBQWQ7QUFBZ0NDLElBQUFBO0FBQWhDLE1BQTRDTCxVQUFoRDtBQUNBLE1BQUksQ0FBRU0sTUFBRixJQUFhSCxVQUFVLENBQUNJLEtBQVgsQ0FBaUIsR0FBakIsQ0FBakI7QUFFQSxTQUFPWixTQUFTLENBQUNFLGVBQVYsQ0FBMEJTLE1BQTFCLEVBQWtDRixnQkFBbEMsRUFBb0Q7QUFBRUksSUFBQUEsTUFBTSxFQUFFVixPQUFPLENBQUNVLE1BQWxCO0FBQTBCLE9BQUdIO0FBQTdCLEdBQXBELENBQVA7QUFDRjs7QUFFRCxlQUFlSSxxQkFBZixDQUFxQ0MsUUFBckMsRUFBK0NDLFdBQS9DLEVBQTREQyxZQUE1RCxFQUEwRTtB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QUFBQSxNQUFNLEVBQUVWLE9BQU8sQ0FBQ1UsTUFBbEI7QUFBMEIsT0FBR0g7QUFBN0IsR0FBNUQsQ0FBaEI7O0FBSmtDLE9BSzFCa0MsU0FMMEI7QUFBQTtBQUFBOztBQU9sQyxNQUFJO0FBQ0EsUUFBSXdCLE9BQU8sR0FBRyxJQUFJSCxrQkFBSixDQUF1QjlELE9BQXZCLEVBQWdDeUMsU0FBaEMsQ0FBZDtBQUVBLFVBQU13QixPQUFPLENBQUNKLFFBQVIsQ0FBaUI3RCxPQUFPLENBQUNrRSxvQkFBekIsQ0FBTjtBQUNILEdBSkQsQ0FJRSxPQUFPckIsS0FBUCxFQUFjO0FBQ1osVUFBTUEsS0FBTjtBQUNILEdBTkQsU0FNVTtBQUNOLFVBQU1KLFNBQVMsQ0FBQ0ssSUFBVixFQUFOO0FBQ0g7QUFDSixDQWhCRDs7QUFrQkFYLE9BQU8sQ0FBQ2dDLGdCQUFSLEdBQTJCLE1BQU07QUFDN0IsU0FBTzdCLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZekMsVUFBWixDQUFQO0FBQ0gsQ0FGRCIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5jb25zdCBVdGlsID0gcmVxdWlyZSgncmstdXRpbHMnKTtcbmNvbnN0IHsgXywgZnMsIGVhY2hBc3luY18gfSA9IFV0aWw7XG5cbmNvbnN0IExpbmtlciA9IHJlcXVpcmUoJy4vTGlua2VyJyk7XG5jb25zdCB7IENvbm5lY3RvciwgVmFsaWRhdG9ycyB9ID0gcmVxdWlyZSgnQGdlbngvZGF0YScpO1xuXG4vKipcbiAqIE9vbG9uZyBEU0wgYXBpXG4gKiBAbW9kdWxlIE9vbG9uZ1xuICovXG5cbiBmdW5jdGlvbiBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSkge1xuICAgIGxldCBkZXBsb3ltZW50ID0gY29udGV4dC5zY2hlbWFEZXBsb3ltZW50W3NjaGVtYU5hbWVdO1xuXG4gICAgaWYgKCFkZXBsb3ltZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiIGhhcyBubyBjb25maWd1cmVkIGRlcGxveW1lbnQgYW5kIGlzIGlnbm9yZWQgaW4gbW9kZWxpbmcuYCk7XG4gICAgfVxuXG4gICAgbGV0IHsgZGF0YVNvdXJjZSwgY29ubmVjdGlvblN0cmluZywgb3B0aW9ucyB9ID0gZGVwbG95bWVudDtcbiAgICBsZXQgWyBkcml2ZXIgXSA9IGRhdGFTb3VyY2Uuc3BsaXQoJy4nKTtcblxuICAgIHJldHVybiBDb25uZWN0b3IuY3JlYXRlQ29ubmVjdG9yKGRyaXZlciwgY29ubmVjdGlvblN0cmluZywgeyBsb2dnZXI6IGNvbnRleHQubG9nZ2VyLCAuLi5vcHRpb25zIH0pOyAgICAgICBcbiB9XG5cbiBhc3luYyBmdW5jdGlvbiBpbXBvcnREYXRhRmlsZXNCeUxpc3QobWlncmF0b3IsIGRhdGFTZXRQYXRoLCBkYXRhTGlzdEZpbGUpIHtcbiAgICBsZXQgZGF0YUxpc3QgPSBmcy5yZWFkRmlsZVN5bmMoZGF0YUxpc3RGaWxlKS50b1N0cmluZygpLm1hdGNoKC9eLiskL2dtKTtcblxuICAgIGlmICghZGF0YUxpc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBlYWNoQXN5bmNfKGRhdGFMaXN0LCBhc3luYyBsaW5lID0+IHtcbiAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuXG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDAgJiYgbGluZVswXSAhPT0gJyMnKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgZGF0YUZpbGUgPSBwYXRoLmpvaW4oZGF0YVNldFBhdGgsIGxpbmUpO1xuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGRhdGFGaWxlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YSBmaWxlIFwiJHtkYXRhRmlsZX1cIiBub3QgZm91bmQuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IG1pZ3JhdG9yLmxvYWRfKGRhdGFGaWxlKTtcbiAgICAgICAgfVxuICAgIH0pOyBcbiB9XG5cbiBhc3luYyBmdW5jdGlvbiBpbXBvcnREYXRhRmlsZXMobWlncmF0b3IsIGZvbGRlck5hbWUpIHtcbiAgICBsZXQgZGF0YVNldFBhdGggPSBwYXRoLmpvaW4obWlncmF0b3IuZGJTY3JpcHRQYXRoLCAnZGF0YScsIGZvbGRlck5hbWUpO1xuICAgIGxldCBkYXRhTGlzdEZpbGUgPSBwYXRoLmpvaW4oZGF0YVNldFBhdGgsICdpbmRleC5saXN0Jyk7XG5cbiAgICBsZXQgcnVudGltZURhdGFTZXRQYXRoLCBydW50aW1lRGF0YVNldEZpbGUsIGltcG9ydGVkID0gZmFsc2U7ICAgIFxuXG4gICAgaWYgKG1pZ3JhdG9yLmFwcE1vZHVsZS5ydW50aW1lRW52KSB7XG4gICAgICAgIHJ1bnRpbWVEYXRhU2V0UGF0aCA9IHBhdGguam9pbihkYXRhU2V0UGF0aCwgbWlncmF0b3IuYXBwTW9kdWxlLnJ1bnRpbWVFbnYpOyAgICAgICAgXG4gICAgICAgIHJ1bnRpbWVEYXRhU2V0RmlsZSA9IHBhdGguam9pbihydW50aW1lRGF0YVNldFBhdGgsICdpbmRleC5saXN0Jyk7XG4gICAgfSAgICBcblxuICAgIGlmIChmcy5leGlzdHNTeW5jKGRhdGFMaXN0RmlsZSkpIHtcbiAgICAgICAgYXdhaXQgaW1wb3J0RGF0YUZpbGVzQnlMaXN0KG1pZ3JhdG9yLCBkYXRhU2V0UGF0aCwgZGF0YUxpc3RGaWxlKTsgICAgICBcbiAgICAgICAgaW1wb3J0ZWQgPSB0cnVlOyAgXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWlncmF0b3IuYXBwTW9kdWxlLmxvZygnd2FybicsIGBEYXRhc2V0IGluZGV4IGZpbGUgXCIke2RhdGFMaXN0RmlsZX1cIiBub3QgZXhpc3QuYClcbiAgICB9XG4gICAgXG4gICAgaWYgKHJ1bnRpbWVEYXRhU2V0RmlsZSAmJiBmcy5leGlzdHNTeW5jKHJ1bnRpbWVEYXRhU2V0RmlsZSkpIHtcbiAgICAgICAgYXdhaXQgaW1wb3J0RGF0YUZpbGVzQnlMaXN0KG1pZ3JhdG9yLCBydW50aW1lRGF0YVNldFBhdGgsIHJ1bnRpbWVEYXRhU2V0RmlsZSk7ICAgIFxuICAgICAgICBpbXBvcnRlZCA9IHRydWU7ICAgICAgXG4gICAgfSBlbHNlIGlmIChtaWdyYXRvci5hcHBNb2R1bGUucnVudGltZUVudikge1xuICAgICAgICBtaWdyYXRvci5hcHBNb2R1bGUubG9nKGltcG9ydGVkID8gJ2luZm8nIDogJ3dhcm4nLCBgRGF0YXNldCBpbmRleCBmaWxlIG9mIFwiJHttaWdyYXRvci5hcHBNb2R1bGUucnVudGltZUVudn1cIiBlbnYgXCIke3J1bnRpbWVEYXRhU2V0RmlsZX1cIiBub3QgZXhpc3QuYClcbiAgICB9XG4gICAgXG4gICAgaWYgKCFpbXBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVudHJ5IGZpbGUgb2YgZGF0YXNldCBcIiR7Zm9sZGVyTmFtZX1cIiBub3QgZm91bmQuYCk7XG4gICAgfSAgICBcbiB9XG5cblxuXG4vKipcbiAqIERlcGxveSBkYXRhYmFzZSBzY3JpcHRzIGludG8gZGF0YWJhc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICogQHByb3BlcnR5IHtMb2dnZXJ9IGNvbnRleHQubG9nZ2VyIC0gTG9nZ2VyIG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQubW9kZWxQYXRoXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5kc2xTb3VyY2VQYXRoIFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQuc2NyaXB0U291cmNlUGF0aCBcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjb250ZXh0LnNjaGVtYURlcGxveW1lbnQgICBcbiAqIEBwYXJhbSB7Ym9vbH0gcmVzZXRcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5leHBvcnRzLm1pZ3JhdGVfID0gYXN5bmMgKGNvbnRleHQsIHJlc2V0ID0gZmFsc2UpID0+IHtcbiAgICBjb250ZXh0LmxvZ2dlci5sb2coJ3ZlcmJvc2UnLCAnU3RhcnQgZGVwbG95aW5nIG1vZGVscyAuLi4nKTtcblxuICAgIGlmIChyZXNldCkge1xuICAgICAgICBhd2FpdCBlYWNoQXN5bmNfKE9iamVjdC5rZXlzKGNvbnRleHQuc2NoZW1hRGVwbG95bWVudCkucmV2ZXJzZSgpLCBhc3luYyAoc2NoZW1hTmFtZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGNvbm5lY3RvciA9IGNyZWF0ZUNvbm5lY3Rvcihjb250ZXh0LCBzY2hlbWFOYW1lKTtcbiAgICAgICAgICAgIGFzc2VydDogY29ubmVjdG9yO1xuICAgIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgTWlncmF0aW9uID0gcmVxdWlyZShgLi4vbWlncmF0aW9uLyR7Y29ubmVjdG9yLmRyaXZlcn1gKTtcbiAgICAgICAgICAgICAgICBsZXQgbWlncmF0aW9uID0gbmV3IE1pZ3JhdGlvbihjb250ZXh0LCBzY2hlbWFOYW1lLCBjb25uZWN0b3IpO1xuICAgIFxuICAgICAgICAgICAgICAgIGF3YWl0IG1pZ3JhdGlvbi5yZXNldF8oKTsgICAgXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uZWN0b3IuZW5kXygpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVhY2hBc3luY18oY29udGV4dC5zY2hlbWFEZXBsb3ltZW50LCBhc3luYyAoZGVwbG95bWVudCwgc2NoZW1hTmFtZSkgPT4ge1xuICAgICAgICBsZXQgY29ubmVjdG9yID0gY3JlYXRlQ29ubmVjdG9yKGNvbnRleHQsIHNjaGVtYU5hbWUpO1xuICAgICAgICBhc3NlcnQ6IGNvbm5lY3RvcjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IE1pZ3JhdGlvbiA9IHJlcXVpcmUoYC4uL21pZ3JhdGlvbi8ke2Nvbm5lY3Rvci5kcml2ZXJ9YCk7XG4gICAgICAgICAgICBsZXQgbWlncmF0aW9uID0gbmV3IE1pZ3JhdGlvbihjb250ZXh0LCBzY2hlbWFOYW1lLCBjb25uZWN0b3IpO1xuXG4gICAgICAgICAgICBhd2FpdCBtaWdyYXRpb24uY3JlYXRlXyhkZXBsb3ltZW50LmV4dHJhT3B0aW9ucyk7ICAgICAgXG5cbiAgICAgICAgICAgIGF3YWl0IGltcG9ydERhdGFGaWxlcyhtaWdyYXRpb24sICdfaW5pdCcpOyAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IGNvbm5lY3Rvci5lbmRfKCk7XG4gICAgICAgIH0gXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1hTmFtZVxuICovXG5leHBvcnRzLmRhdGFzZXRfID0gYXN5bmMgKGNvbnRleHQsIHNjaGVtYU5hbWUpID0+IHtcbiAgICBsZXQgY29ubmVjdG9yID0gY3JlYXRlQ29ubmVjdG9yKGNvbnRleHQsIHNjaGVtYU5hbWUpO1xuICAgIGFzc2VydDogY29ubmVjdG9yO1xuICAgIFxuICAgIGxldCBkYXRhU2V0UGF0aCA9IHBhdGguam9pbihjb250ZXh0LnNjcmlwdFNvdXJjZVBhdGgsIGNvbm5lY3Rvci5kcml2ZXIsIGNvbm5lY3Rvci5kYXRhYmFzZSwgJ2RhdGEnKTtcblxuICAgIGlmICghZnMuZXhpc3RzU3luYyhkYXRhU2V0UGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkYXRhU2V0cyA9IGZzLnJlYWRkaXJTeW5jKGRhdGFTZXRQYXRoKTtcbiAgICAgICAgbGV0IHZhbGlkRHMgPSBbXTtcbiAgICAgICAgZGF0YVNldHMuZm9yRWFjaChkcyA9PiB7XG4gICAgICAgICAgICBsZXQgaW5kZXhGaWxlID0gcGF0aC5qb2luKGRhdGFTZXRQYXRoLCBkcywgJ2luZGV4Lmxpc3QnKTtcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGluZGV4RmlsZSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZERzLnB1c2goZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmFsaWREcztcbiAgICB9XG59XG5cbi8qKlxuICogSW1wb3J0IGEgZGF0YSBzZXQgaW50byBkYXRhYmFzZVxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAqIEBwcm9wZXJ0eSB7TG9nZ2VyfSBjb250ZXh0LmxvZ2dlciAtIExvZ2dlciBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LnNjcmlwdFNvdXJjZVBhdGggIFxuICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtYU5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0TmFtZVxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmV4cG9ydHMuaW1wb3J0XyA9IGFzeW5jIChjb250ZXh0LCBzY2hlbWFOYW1lLCBkYXRhc2V0TmFtZSkgPT4ge1xuICAgIGxldCBjb25uZWN0b3IgPSBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSk7XG4gICAgYXNzZXJ0OiBjb25uZWN0b3I7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IE1pZ3JhdGlvbiA9IHJlcXVpcmUoYC4uL21pZ3JhdGlvbi8ke2Nvbm5lY3Rvci5kcml2ZXJ9YCk7XG4gICAgICAgIGxldCBtaWdyYXRpb24gPSBuZXcgTWlncmF0aW9uKGNvbnRleHQsIHNjaGVtYU5hbWUsIGNvbm5lY3Rvcik7XG5cbiAgICAgICAgYXdhaXQgaW1wb3J0RGF0YUZpbGVzKG1pZ3JhdGlvbiwgZGF0YXNldE5hbWUpOyAgICAgICAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGF3YWl0IGNvbm5lY3Rvci5lbmRfKCk7XG4gICAgfSBcbn07XG5cbi8qKlxuICogRXh0cmFjdCBkYXRhYmFzZSBzdHJ1Y3R1cmUgaW50byBvb2xvbmcgZHNsXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICogQHByb3BlcnR5IHtDb25uZWN0b3J9IGNvbnRleHQuY29ubmVjdG9yXG4gKiBAcHJvcGVydHkge0xvZ2dlcn0gY29udGV4dC5sb2dnZXIgXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5kc2xSZXZlcnNlT3V0cHV0UGF0aCBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LmRyaXZlclxuICogQHByb3BlcnR5IHtvYmplY3R9IGNvbnRleHQuY29ubk9wdGlvbnMgXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuZXhwb3J0cy5yZXZlcnNlXyA9IGFzeW5jIChjb250ZXh0KSA9PiB7ICAgXG4gICAgbGV0IFJlc2VydmVFbmdpbmVlcmluZyA9IHJlcXVpcmUoYC4uL21vZGVsZXIvZGF0YWJhc2UvJHtjb250ZXh0LmRyaXZlcn0vUmV2ZXJzZUVuZ2luZWVyaW5nYCk7XG4gICAgXG4gICAgbGV0IHsgY29ubmVjdGlvbjogY29ubmVjdGlvblN0cmluZywgLi4ub3B0aW9ucyB9ID0gY29udGV4dC5jb25uT3B0aW9uczsgIFxuICAgIGxldCBjb25uZWN0b3IgPSBDb25uZWN0b3IuY3JlYXRlQ29ubmVjdG9yKGNvbnRleHQuZHJpdmVyLCBjb25uZWN0aW9uU3RyaW5nLCB7IGxvZ2dlcjogY29udGV4dC5sb2dnZXIsIC4uLm9wdGlvbnMgfSk7ICAgICBcbiAgICBhc3NlcnQ6IGNvbm5lY3RvcjsgIFxuXG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IG1vZGVsZXIgPSBuZXcgUmVzZXJ2ZUVuZ2luZWVyaW5nKGNvbnRleHQsIGNvbm5lY3Rvcik7XG5cbiAgICAgICAgYXdhaXQgbW9kZWxlci5yZXZlcnNlXyhjb250ZXh0LmRzbFJldmVyc2VPdXRwdXRQYXRoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCBjb25uZWN0b3IuZW5kXygpO1xuICAgIH0gXG59O1xuXG5leHBvcnRzLmdldFZhbGlkYXRvckxpc3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKFZhbGlkYXRvcnMpOyAgICBcbn0iXX0=