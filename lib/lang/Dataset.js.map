{"version":3,"sources":["../../src/lang/Dataset.js"],"names":["_","require","deepCloneField","Clonable","isDotSeparateName","Dataset","constructor","linker","name","gemlModule","info","camelCase","link","pre","linked","entity","getReferencedEntity","mainEntity","dataset","loadDataset","assert","joinWith","cloneDeep","isEmpty","concat","buildHierarchy","inSchema","_flattenDataset","hierarchy","leftEntity","entities","forEach","joining","leftField","rightEntity","rightField","on","left","lastPos","lastIndexOf","fieldRef","substr","entityRef","getEntityAttribute","Error","rightHierarchy","getDocumentHierachy","right","parts","split","length","Object","assign","linkWithField","oolType","subDocuments","clone","toJSON","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { _ } = require('@genx/july');\nconst { deepCloneField, Clonable, isDotSeparateName } = require('./GemlUtils');\n\n/**\n * Geml dataset class.\n * @class Dataset\n */\nclass Dataset extends Clonable {\n    /**     \n     * @param {Linker} linker\n     * @param {string} name - Dataset name\n     * @param {object} gemlModule - Source ool module\n     * @param {object} info - Dataset info\n     */\n    constructor(linker, name, gemlModule, info) {\n        /**\n         * Linker to process this document\n         * @member {Linker}\n         */\n        this.linker = linker;\n\n        /**\n         * Name of this document\n         * @member {string}\n         */\n        this.name = _.camelCase(name);\n\n        /**\n         * Owner oolong module\n         * @member {object}\n         */\n        this.gemlModule = gemlModule;\n\n        /**\n         * Raw metadata\n         * @member {Object}\n         */\n        this.info = info;\n    }\n\n    /**\n     * Start linking this dataset\n     * @returns {Dataset}\n     */\n    link() {\n        pre: !this.linked;\n\n        if (this.info.entity) {\n            let entity = this.linker.getReferencedEntity(this.gemlModule, this.info.entity);\n            this.mainEntity = entity.name;\n        } else {\n            let dataset = this.linker.loadDataset(this.gemlModule, this.info.dataset);\n            assert: dataset.linked;\n\n            this.mainEntity = dataset.mainEntity;\n            this.joinWith = _.cloneDeep(dataset.joinWith);\n        }\n        \n        if (!_.isEmpty(this.info.joinWith)) {\n            if (!this.joinWith) {\n                this.joinWith = _.cloneDeep(this.info.joinWith);\n            } else {\n                this.joinWith = this.joinWith.concat(this.info.joinWith);\n            }\n        }\n\n        this.linked = true;\n\n        return this;\n    }\n\n    buildHierarchy(inSchema) {\n        return this._flattenDataset(inSchema, this);\n    }\n\n    _flattenDataset(inSchema, dataset) {\n        let hierarchy = {};\n        let leftEntity = inSchema.entities[dataset.mainEntity];\n\n        if (dataset.joinWith) {\n            dataset.joinWith.forEach(joining => {\n                let leftField, rightEntity, rightField;\n\n                if (isDotSeparateName(joining.on.left)) {\n                    let lastPos = joining.on.left.lastIndexOf('.');\n                    let fieldRef = joining.on.left.substr(lastPos+1);\n                    let entityRef = joining.on.left.substr(0, lastPos);\n\n                    if (entityRef === leftEntity.name) {\n                        leftField = leftEntity.getEntityAttribute(fieldRef);\n                    } else {\n                        throw new Error(`Unsupported syntax of left side joining field \"${joining.on.left}\".`);\n                    }\n\n                } else {\n                    //field of leftEntity\n                    leftField = leftEntity.getEntityAttribute(joining.on.left);\n                }\n\n                if (joining.dataset) {\n                    let rightHierarchy = inSchema.getDocumentHierachy(this.gemlModule, joining.dataset);\n\n                    if (isDotSeparateName(joining.on.right)) {\n                        let parts = joining.on.right.split('.');\n                        if (parts.length > 2) {\n                            throw new Error('Joining a document should only referencing to a field of its main entity.');\n                        }\n\n                        let [ entityRef, fieldRef ] = parts;\n\n                        if (entityRef !== rightHierarchy.entity) {\n\n                            throw new Error(`Referenced field \"${joining.on.right}\" not found while linking to document \"${joining.dataset}\".`);\n                        }\n\n                        assert: !hierarchy[leftField.name], 'Duplicate joinings on the same field of the left side entity.';\n\n                        rightEntity = inSchema.entities[entityRef];\n                        rightField = rightEntity.getEntityAttribute(fieldRef);\n\n                        hierarchy[leftField.name] = Object.assign({}, rightHierarchy, {\n                            linkWithField: rightField.name\n                        });\n\n                        return;\n                    }\n\n                    //joining.on.right is field name of the main entity\n                    rightEntity = inSchema.entities[joining.dataset.mainEntity];\n                } else {\n                    rightEntity = inSchema.entities[joining.entity];\n\n                    if (isDotSeparateName(joining.on.right)) {\n                        throw new Error(`Referenced field \"${joining.on.right}\" not found while linking to entity \"${joining.entity}\".`);\n                    }\n                }\n\n                //field of rightEntity\n                rightField = rightEntity.getEntityAttribute(joining.on.right);\n\n                assert: !hierarchy[leftField.name], 'Duplicate joinings on the same field of the left side entity.';\n\n                hierarchy[leftField.name] = {\n                    oolType: 'DocumentHierarchyNode',\n                    entity: rightEntity.name,\n                    linkWithField: rightField.name\n                };\n            });\n        }\n\n        return {\n            oolType: 'DocumentHierarchyNode',\n            entity: leftEntity.name,\n            subDocuments: hierarchy\n        };\n    }\n\n    /**\n     * Clone the document\n     * @returns {Dataset}\n     */\n    clone() {\n        super.clone();\n\n        let dataset = new Dataset(this.linker, this.name, this.gemlModule, this.info);\n\n        dataset.mainEntity = this.mainEntity;\n        deepCloneField(this, dataset, 'joinWith');\n\n        dataset.linked = true;\n\n        return dataset;\n    }\n\n\n    /**\n     * Translate the document into a plain JSON object\n     * @returns {object}\n     */\n    toJSON() {\n        return {            \n            name: this.name,\n            mainEntity: this.mainEntity.toJSON(),\n            joinWith: this.joinWith\n        };\n    }\n}\n\nmodule.exports = Dataset;"],"file":"Dataset.js"}